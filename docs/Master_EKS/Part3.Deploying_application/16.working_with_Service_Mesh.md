# Working with AWS App Mesh

## Overview

Service mesh provides granular control over application-to-application traffic communication, better visibility, and additional capabilities like encryption. As microservices ecosystems grow to tens or thousands of services, a service mesh becomes essential for consistent management without requiring code changes from development teams.

## What is a Service Mesh?

### Problems it Solves
- Static security groups and network policies become complex as application topology changes
- IP addresses change as applications scale in/out
- Operational burden increases with more services across multiple clusters
- Configuration management becomes increasingly difficult

### Service Mesh Architecture
```
Control Plane
    ↓ (Policy deployment)
Data Plane (Namespaces/Pods)
    ↓ (Network traffic telemetry)
Control Plane
```

**Key Components:**
- **Control Plane**: Deploys policy changes consistently, responds dynamically to topology changes
- **Data Plane**: Provides consistent control across namespaces/Pods
- **API**: Exposes capabilities for management

## Data Plane Options

### 1. DNS Service Discovery
- **Purpose**: Simple service discovery only
- **Implementation**: CoreDNS forwarding to external DNS
- **Use Case**: Connect K8s services with AWS or on-premises services
- **Limitations**: No traffic control or telemetry

### 2. Kernel-based (eBPF)
- **Technology**: Enhanced Berkeley Packet Filter
- **Advantages**: More performant than iptables, flexible
- **Use Case**: High-performance networking, deep packet inspection
- **Status**: Emergent technology

### 3. Sidecar Container Pattern
- **Most Common**: Deployed in same Pod as application
- **Proxy**: Usually Envoy proxy
- **Features**: Traffic encryption (mTLS), load balancing, observability
- **Advantage**: Localized network rules, enhanced capabilities

## AWS App Mesh

### Key Features
- Fully managed service
- Consistent network controls across EKS, Fargate, ECS, EC2
- Based on Envoy proxy sidecar pattern
- Cross-service traffic control and visibility

### Main Constructs

#### 1. Mesh
- Logical network boundary for applications/services
- Groups related services that communicate with each other
- First construct that must be created

#### 2. Virtual Node
- **Required**: One per K8s Deployment
- Abstraction of K8s Deployment/Service
- Links K8s resources with mesh constructs
- Uses service discovery method

#### 3. Virtual Service
- **Required**: Points to virtual node or virtual router
- Used by other services to connect to K8s service
- **Important**: `awsName` must be DNS resolvable

#### 4. Virtual Router (Optional)
- Routes traffic between services
- Useful for blue/green deployments
- Supports weighted traffic distribution

#### 5. Virtual Gateway (Optional)
- Acts like K8s Ingress for north/south traffic
- Routes and controls external traffic

## Installation and Setup

### Prerequisites
```bash
# Create namespace
kubectl create ns appmesh-system

# Create IAM service account
eksctl create iamserviceaccount \
  --cluster myipv4cluster \
  --namespace appmesh-system \
  --name appmesh-controller \
  --attach-policy-arn arn:aws:iam::aws:policy/AWSCloudMapFullAccess,arn:aws:iam::aws:policy/AWSAppMeshFullAccess \
  --override-existing-serviceaccounts \
  --approve
```

### Install Controller
```bash
# Install using Helm
helm install appmesh-controller eks/appmesh-controller \
  --namespace appmesh-system \
  --set region=eu-central-1 \
  --set serviceAccount.create=false \
  --set serviceAccount.name=appmesh-controller

# Verify installation
kubectl -n appmesh-system get all
kubectl get crds | grep appmesh
```

### Create Mesh
```yaml
apiVersion: appmesh.k8s.aws/v1beta2
kind: Mesh
metadata:
  name: webapp
spec:
  namespaceSelector:
    matchLabels:
      mesh: webapp
```

### Update Worker Node Policy
Attach `AWSAppMeshEnvoyAccess` policy to worker node IAM role.

## Application Integration

### Traffic Types
- **North/South**: External traffic (users/internet) → typically handled by frontend services
- **East/West**: Service-to-service traffic → backend services, focus of service mesh

### Namespace Configuration
```bash
# Label namespaces for mesh integration
kubectl label namespace <namespace> mesh=webapp
kubectl label namespace <namespace> appmesh.k8s.aws/sidecarInjectorWebhook=enabled
```

### Virtual Node Configuration
```yaml
apiVersion: appmesh.k8s.aws/v1beta2
kind: VirtualNode
metadata:
  name: service-v1
  namespace: service-ns
spec:
  podSelector:
    matchLabels:
      app.kubernetes.io/name: service-v1
  listeners:
    - portMapping:
        port: 8080
        protocol: http
      healthCheck:
        protocol: http
        path: '/health'
        healthyThreshold: 2
        unhealthyThreshold: 2
        timeoutMillis: 2000
        intervalMillis: 5000
  serviceDiscovery:
    dns:
      hostname: service-v1.service-ns.svc.cluster.local
  backends:  # For client services
    - virtualService:
        virtualServiceRef:
          namespace: target-ns
          name: target-service
```

### Virtual Service Configuration
```yaml
apiVersion: appmesh.k8s.aws/v1beta2
kind: VirtualService
metadata:
  name: service
  namespace: service-ns
spec:
  awsName: service.service-ns.svc.cluster.local
  provider:
    virtualNode:
      virtualNodeRef:
        name: service-v1
        namespace: service-ns
```

**Important**: Create dummy K8s service for DNS resolution:
```yaml
apiVersion: v1
kind: Service
metadata:
  name: service
  namespace: service-ns
spec:
  ports:
  - port: 8080
    name: http
```

### Sidecar Injection
After creating Virtual Node, restart deployment to inject Envoy sidecar:
```bash
kubectl rollout restart deployment <deployment-name> -n <namespace>
```

Pod will now have:
- Application container
- Envoy sidecar container  
- Proxy init container

## Advanced Features

### Virtual Router for Blue/Green Deployments
```yaml
apiVersion: appmesh.k8s.aws/v1beta2
kind: VirtualRouter
metadata:
  name: app-router
  namespace: consumer
spec:
  listeners:
    - portMapping:
        port: 8085
        protocol: http
  routes:
    - name: app-route
      httpRoute:
        match:
          prefix: /
        action:
          weightedTargets:
            - virtualNodeRef:
                name: green-v1
                namespace: green
              weight: 100
              port: 8081
            - virtualNodeRef:
                name: blue-v1
                namespace: blue
              weight: 0
              port: 8080
```

**Benefits:**
- Gradual traffic shifting
- Zero-downtime deployments
- Easy rollback capability

### Virtual Gateway for External Access
```yaml
apiVersion: appmesh.k8s.aws/v1beta2
kind: VirtualGateway
metadata:
  name: ingress-gw
  namespace: gateway-ns
spec:
  namespaceSelector:
    matchLabels:
      gateway: ingress-gw
  podSelector:
    matchLabels:
      app: ingress-gw
  listeners:
    - portMapping:
        port: 8080
        protocol: http
```

**Gateway Route:**
```yaml
apiVersion: appmesh.k8s.aws/v1beta2
kind: GatewayRoute
metadata:
  name: app-route
  namespace: gateway-ns
spec:
  httpRoute:
    match:
      prefix: "/"
    action:
      target:
        virtualService:
          virtualServiceRef:
            name: app-service
            port: 8080
            namespace: app-ns
```

**Standalone Envoy Deployment:**
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: ingress-gw
  namespace: gateway-ns
spec:
  replicas: 2
  selector:
    matchLabels:
      app: ingress-gw
  template:
    metadata:
      labels:
        app: ingress-gw
    spec:
      containers:
        - name: envoy
          image: 840364872350.dkr.ecr.region.amazonaws.com/aws-appmesh-envoy:v1.24.0.0-prod
          env:
          - name: APPMESH_RESOURCE_ARN
            value: "arn:aws:appmesh:region:account:mesh/webapp/virtualGateway/ingress-gw_gateway-ns"
          - name: ENVOY_LOG_LEVEL
            value: "info"  # Use "debug" for troubleshooting
          ports:
            - containerPort: 8080
```

## AWS Cloud Map Integration

### Benefits
- External service discovery without K8s dependency
- Cross-platform service registration
- Eliminates need for dummy K8s services

### Setup
```bash
# Create private DNS namespace
aws servicediscovery create-private-dns-namespace \
  --name prod.company.com \
  --description 'Production private DNS namespace' \
  --vpc vpc-xxxxxxxxx

# Create service
aws servicediscovery create-service \
  --name myapp \
  --description 'Discovery service for myapp' \
  --namespace-id ns-xxxxxxxxx \
  --dns-config 'RoutingPolicy=MULTIVALUE,DnsRecords=[{Type=A,TTL=300}]' \
  --health-check-custom-config FailureThreshold=1
```

### Virtual Node with Cloud Map
```yaml
serviceDiscovery:
  awsCloudMap:
    namespaceName: prod.company.com
    serviceName: myapp
```

## Troubleshooting

### Common Issues
1. **Backend/VirtualGateway route configurations incorrect**
2. **Envoy lacks AWS credentials or cannot connect to App Mesh endpoints**
3. **DNS resolution not configured properly**
4. **Envoy cannot connect to App Mesh control plane**

### Debugging Steps

#### 1. Increase Logging Level
```bash
# For deployed Pods
kubectl port-forward -n <namespace> <pod-name> 8080:9901

# Change log level via admin interface
curl -X POST http://localhost:8080/logging?level=debug

# View logs
kubectl logs -n <namespace> <pod-name> envoy -f
```

#### 2. Key Debug Messages to Look For

| Message Pattern | Description |
|----------------|-------------|
| `cluster 'cds_...' match for URL '/path'` | Envoy receiving and routing request |
| `Establishing new gRPC bidi stream to appmesh-envoy-management...` | Connecting to App Mesh endpoints |
| `Obtained following AWS credentials from EC2MetadataService` | Pod getting AWS credentials |
| `dns resolution for ... completed with status 0` | Successful DNS resolution |
| `Control Plane connection state changed to: CONNECTED` | Successfully connected to control plane |

#### 3. Verification Commands
```bash
# Check virtual resources
kubectl get virtualnode --all-namespaces
kubectl get virtualservice --all-namespaces
kubectl get virtualrouter --all-namespaces

# Verify in AWS
aws appmesh list-virtual-nodes --mesh-name <mesh-name>
aws appmesh list-virtual-services --mesh-name <mesh-name>
```

## Best Practices

### Security
- Use IRSA (IAM Roles for Service Accounts) for fine-grained permissions
- Enable mTLS for service-to-service communication
- Set appropriate logging levels (avoid debug in production)

### Performance
- Monitor Envoy proxy resource usage
- Use appropriate health check intervals
- Consider eBPF-based solutions for high-performance scenarios

### Operations
- Implement gradual traffic shifting for deployments
- Use consistent naming conventions across virtual resources
- Monitor control plane connectivity
- Set up proper observability and metrics collection

### Development
- Use descriptive names for virtual resources
- Maintain clear service dependency mappings
- Document service mesh topology
- Test traffic routing changes in non-production environments

## Key Takeaways

1. **Service Mesh Value**: Provides consistent traffic control and observability without application code changes
2. **AWS App Mesh**: Fully managed solution with Envoy-based sidecars
3. **Virtual Constructs**: Abstract K8s resources for mesh management
4. **Traffic Management**: Supports both east/west and north/south traffic patterns
5. **Service Discovery**: Can integrate with both K8s DNS and AWS Cloud Map
6. **Troubleshooting**: Envoy admin interface and logging are key debugging tools

## Further Reading

- [AWS App Mesh User Guide](https://docs.aws.amazon.com/app-mesh/)
- [Envoy Proxy Documentation](https://www.envoyproxy.io/)
- [Service Mesh Landscape](https://layer5.io/service-mesh-landscape)
- [External DNS with AWS Cloud Map](https://github.com/kubernetes-sigs/external-dns/blob/master/docs/tutorials/aws-sd.md)