# AWS EKS IAM and IRSA Notes

## Overview
This chapter covers how to grant IAM permissions to Kubernetes Pods running on Amazon EKS, focusing on IAM Roles for Service Accounts (IRSA) as a secure alternative to traditional EC2 instance profiles.

## Prerequisites
- Network connectivity to EKS cluster API endpoint
- AWS CLI, Docker, and kubectl installed
- Basic understanding of AWS IAM and EKS architecture
- Familiarity with YAML

## Traditional EC2 IAM Role Assignment

### How EC2 Instance Profiles Work
- **Instance Profile**: Container for IAM role attached to EC2 instance
- **Process**:
  1. EC2 instance created with assigned role
  2. AWS automatically creates instance profile
  3. Instance queries Instance Metadata Service (IMDS) at `169.254.169.254`
  4. Retrieves access credentials (AccessKeyId, SecretAccessKey, Token)

### Example Credential Response
```json
{
  "Code": "Success",
  "LastUpdated": "2022-04-26T16:39:16Z",
  "Type": "AWS-HMAC",
  "AccessKeyId": "ASIAIOSFODNN7EXAMPLE",
  "SecretAccessKey": "bPxRfiCYEXAMPLEKEY",
  "Token": "token",
  "Expiration": "2022-05-17T15:09:54Z"
}
```

### Checking Instance Profile
```bash
aws sts get-caller-identity
```

## Instance Metadata Service Version 2 (IMDSv2)

### Security Enhancements
- **Session-oriented requests** with token-based authentication
- **TTL hop count** restriction (default: 1)
- **Prevents Pod access** to host credentials (Pods increment hop count to 2)

### Configuring IMDSv2
```bash
aws ec2 modify-instance-metadata-options \
  --instance-id i-1122233 \
  --http-tokens required \
  --http-put-response-hop-limit 1
```

### Limitations
- Only works if Pod uses IMDSv2
- Pods using IMDSv1 can still retrieve host credentials
- **Best Practice**: Give worker nodes minimal permissions only

## IAM Roles for Service Accounts (IRSA)

### What IRSA Solves
- Assigns specific privileges to specific Pods
- Eliminates inheritance of worker node permissions
- Implements least-privilege principle
- Maps Kubernetes Service Accounts to IAM roles

### How IRSA Works
1. **Association**: Kubernetes Service Account mapped to IAM role
2. **API Call**: Pod uses Service Account credentials with IAM role annotation
3. **Token Exchange**: `AssumeRoleWithWebIdentity` call to AWS STS
4. **Credential Exchange**: Kubernetes credentials exchanged for AWS IAM credentials

## Implementing IRSA

### Step 1: Verify OIDC Provider
```bash
# Check if OIDC provider exists
aws eks describe-cluster --name myipv4cluster \
  --query "cluster.identity.oidc.issuer" --output text

# Create OIDC provider if needed
eksctl utils associate-iam-oidc-provider --cluster cluster_name --approve
```

### Step 2: Create IAM Policy
Example S3 access policy:
```json
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Action": [
        "s3:GetAccountPublicAccessBlock",
        "s3:GetBucketAcl",
        "s3:GetBucketLocation",
        "s3:GetBucketPolicyStatus",
        "s3:GetBucketPublicAccessBlock",
        "s3:ListAccessPoints",
        "s3:ListAllMyBuckets"
      ],
      "Resource": "*"
    }
  ]
}
```

```bash
aws iam create-policy --policy-name bespoke-pod-policy \
  --policy-document file://s3-policy.json
```

### Step 3: Set Environment Variables
```bash
export account_id=$(aws sts get-caller-identity --query "Account" --output text)
export oidc_provider=$(aws eks describe-cluster --name myipv4cluster \
  --region eu-central-1 --query "cluster.identity.oidc.issuer" \
  --output text | sed -e "s/^https:\/\///")
export namespace=default
export service_account=s3-access
```

### Step 4: Create Trust Relationship
```bash
cat >trust-relationship.json <<EOF
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Principal": {
        "Federated": "arn:aws:iam::$account_id:oidc-provider/$oidc_provider"
      },
      "Action": "sts:AssumeRoleWithWebIdentity",
      "Condition": {
        "StringEquals": {
          "$oidc_provider:aud": "sts.amazonaws.com",
          "$oidc_provider:sub": "system:serviceaccount:$namespace:$service_account"
        }
      }
    }
  ]
}
EOF
```

### Step 5: Create IAM Role and Attach Policy
```bash
# Create role
aws iam create-role --role-name s3-access-default \
  --assume-role-policy-document file://trust-relationship.json \
  --description "s3 access role for pod SA s3-access/default"

# Attach policy
aws iam attach-role-policy --role-name s3-access-default \
  --policy-arn=arn:aws:iam::$account_id:policy/bespoke-pod-policy
```

### Step 6: Create and Annotate Service Account
```bash
# Create Service Account
cat >my-service-account.yaml <<EOF
apiVersion: v1
kind: ServiceAccount
metadata:
  name: s3-access
  namespace: default
EOF

kubectl apply -f my-service-account.yaml

# Annotate with IAM role
kubectl annotate serviceaccount -n $namespace $service_account \
  eks.amazonaws.com/role-arn=arn:aws:iam::$account_id:role/s3-access-default
```

### Step 7: Test Pod with IRSA
```bash
kubectl run --rm -ti cli --image=amazon/aws-cli \
  --overrides='{ "spec": { "serviceAccount": "s3-access" } }' \
  s3 ls
```

## Programmatic IRSA Creation with eksctl

### Simplified Command
```bash
eksctl create iamserviceaccount \
  --cluster=<clusterName> \
  --name=<serviceAccountName> \
  --namespace=<serviceAccountNamespace> \
  --attach-policy-arn=<policyARN>
```

### What eksctl Does Automatically
1. Determines EKS cluster OIDC provider
2. Creates role with trust policy
3. Attaches pre-created policy to IAM role
4. Creates Kubernetes Service Account with annotations

## Troubleshooting IRSA Issues

### Step 1: Identify IAM Permission Errors
Look for `AccessDenied` errors in AWS API operations:
```
An error occurred (AccessDenied) when calling the ListBuckets operation: Access Denied
```

### Step 2: Check Service Account
```bash
# Find which service account is being used
kubectl get po <pod-name> -o yaml | grep serviceAccountName

# Check service account annotations
kubectl describe sa <service-account-name>
```

### Step 3: Verify IAM Role and Policies
```bash
# List attached policies
aws iam list-attached-role-policies --role-name <role-name>

# Get policy details
aws iam get-policy --policy-arn <policy-arn>

# Get specific policy version
aws iam get-policy-version --policy-arn <policy-arn> --version-id v1
```

### Step 4: Validate Trust Relationship
```bash
# Check if role trusts correct OIDC provider
aws iam get-role --role-name <role-name>
```

### Step 5: Verify Pod Identity Webhook
```bash
kubectl get mutatingwebhookconfiguration pod-identity-webhook -o yaml
```

## Key Troubleshooting Areas
- Missing Service Account annotations
- Incorrect IAM policy permissions
- Wrong trust relationship configuration
- OIDC provider not configured
- Pod identity webhook issues

## Best Practices
- Use IMDSv2 with hop limit restrictions
- Implement least-privilege principle
- Give worker nodes minimal permissions only
- Use IRSA instead of inheriting worker node permissions
- Regularly audit and review IAM policies

## Summary
IRSA provides a secure way to assign specific AWS permissions to individual Pods without relying on worker node permissions. It uses Kubernetes Service Accounts mapped to IAM roles through OIDC identity providers, enabling fine-grained access control and following security best practices.

## Further Reading
- [Understanding the EC2 metadata service](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-metadata.html)
- [EKS updates to support IMDSv2](https://aws.amazon.com/about-aws/whats-new/2020/08/amazon-eks-supports-ec2-instance-metadata-service-v2/)
- [Troubleshooting IRSA errors](https://aws.amazon.com/premiumsupport/knowledge-center/eks-troubleshoot-IRSA-errors/)