# Setting Load Balancing for Applications on EKS

## Overview

Load balancers (LBs) are essential for scaling and providing resilience in modern cloud-native applications. They hide Kubernetes actions (replacing, removing, adding Pods) from clients by providing a consistent endpoint.

### Key Benefits
- **Resilience**: Application remains available to clients
- **Scalability**: Handles Pod scaling automatically
- **Consistent Access**: Single endpoint regardless of Pod location/number

## Technical Requirements

Before implementing load balancing:

- Network connectivity to EKS cluster API endpoint
- AWS CLI, Docker, and kubectl installed
- Basic understanding of AWS networking
- Familiarity with YAML, IAM, and EKS architecture

## Load Balancer Fundamentals

### Concept 1: Layer 4 vs Layer 7 Load Balancing

#### Layer 7 (Application Layer)
- **Protocol Understanding**: HTTP/HTTPS, HTTPv2
- **Traffic Inspection**: HTTP paths, URLs, headers
- **Capabilities**: Redirection, health checks, content-based routing
- **HTTPS Handling**: Must terminate encryption (proxy mode)
- **Use Cases**: Web applications, RESTful APIs, gRPC

#### Layer 4 (Transport Layer)
- **Protocol Understanding**: TCP/UDP only
- **Traffic Inspection**: Port-based routing
- **Capabilities**: Protocol-agnostic, faster processing
- **Operating Modes**: Both proxy and DSR modes
- **Use Cases**: Any TCP/UDP traffic (SSH, SMTP, web)

### Concept 2: Proxy vs DSR Modes

#### Proxy Mode (Reverse Proxy)
```
Client → LB → Backend Server → LB → Client
```
- LB handles both request and response traffic
- Source IP replaced by LB IP
- X-Forwarded-For header preserves original client IP
- Required for HTTPS inspection

#### DSR Mode (Direct Server Return)
```
Client → LB → Backend Server → Client (direct)
```
- Only request traffic goes through LB
- Response traffic bypasses LB
- Lower latency and higher scalability
- Backend must know client IP for direct response

## AWS Elastic Load Balancers (ELB)

### Application Load Balancer (ALB)

#### Characteristics
- **Layer**: 7 (Application)
- **Protocols**: HTTP/HTTPS, HTTPv2
- **Mode**: Reverse proxy only
- **Addressing**: DNS CNAME (IP addresses can change)
- **Security**: Security groups supported
- **Advanced Features**: WAF integration, AWS Shield

#### Target Types
- IP addresses (VPC and on-premises RFC 1918)
- EC2 instances
- Lambda functions

#### Configuration Components
1. **Listener**: Defines protocol and URL path
2. **Target Group**: Defines targets and health checks
3. **VPC Integration**: Attaches to availability zones

### Network Load Balancer (NLB)

#### Characteristics
- **Layer**: 4 (Transport)
- **Protocols**: TCP, UDP, TLS
- **Mode**: Both proxy and DSR
- **Addressing**: Static IP addresses via ENIs
- **Security**: No security groups (external NLBs open to internet)
- **Performance**: Lower latency, faster scaling

#### Target Types
- IP addresses (VPC and on-premises RFC 1918)
- EC2 instances
- ALBs (for static IP requirement)

#### Client IP Preservation Rules
- **EC2 Instance ID targets**: Client IP preserved
- **IP address targets**:
  - TCP/TLS protocols: Client IP not preserved (use proxy protocol)
  - UDP/TCP_UDP protocols: Client IP preserved

## Choosing the Right Load Balancer

### Decision Matrix

| Requirement | ALB | NLB |
|-------------|-----|-----|
| Non-HTTP protocols | ❌ | ✅ |
| SSL/TLS termination | ✅ | ✅ |
| End-to-end encryption | ❌ | ✅ |
| WAF integration | ✅ | ❌ |
| DDoS protection | ✅ (Shield) | ✅ (Shield Advanced only) |
| Static IP addresses | ❌ | ✅ |
| Low latency | Good | Excellent |
| Path-based routing | ✅ | ❌ |
| Complex routing rules | ✅ | ❌ |

### Use Case Guidelines

**Choose ALB when:**
- HTTP/HTTPS applications
- Need path-based routing
- Require WAF protection
- Using Kubernetes Ingress
- Complex routing requirements

**Choose NLB when:**
- Non-HTTP protocols
- Need static IP addresses
- Require lowest latency
- Large traffic bursts
- End-to-end encryption needed
- Using Kubernetes Services

## AWS Load Balancer Controller (ALBC)

### Installation Steps

#### 1. VPC Subnet Tagging
```bash
# Tag public subnets
aws ec2 create-tags --resources "subnet-id" --tags Key=kubernetes.io/role/elb,Value=1

# Tag private subnets  
aws ec2 create-tags --resources "subnet-id" --tags Key=kubernetes.io/role/internal-elb,Value=1
```

#### 2. IAM Policy Creation
```bash
# Download policy
curl -o iam-policy.json https://raw.githubusercontent.com/kubernetes-sigs/aws-load-balancer-controller/v2.4.5/docs/install/iam_policy.json

# Create policy
aws iam create-policy --policy-name AWSLoadBalancerControllerIAMPolicy --policy-document file://iam-policy.json
```

#### 3. Service Account Creation
```bash
eksctl create iamserviceaccount \
  --cluster myipv4cluster \
  --namespace kube-system \
  --name aws-load-balancer-controller \
  --attach-policy-arn arn:aws:iam::ACCOUNT:policy/AWSLoadBalancerControllerIAMPolicy \
  --override-existing-serviceaccounts \
  --approve
```

#### 4. Helm Installation
```bash
# Add repository
helm repo add eks https://aws.github.io/eks-charts
helm repo update

# Install controller
helm install aws-load-balancer-controller eks/aws-load-balancer-controller \
  -n kube-system \
  --set clusterName=myipv4cluster \
  --set serviceAccount.create=false \
  --set serviceAccount.name=aws-load-balancer-controller \
  --set region=eu-central-1 \
  --set vpcId=vpc-xxxxxx
```

## ALB Implementation

### Ingress Configuration
```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  namespace: game-2048
  name: ingress-2048
  annotations:
    alb.ingress.kubernetes.io/scheme: internet-facing
    alb.ingress.kubernetes.io/target-type: ip
spec:
  ingressClassName: alb
  rules:
    - http:
        paths:
        - path: /
          pathType: Prefix
          backend:
            service:
              name: service-2048
              port:
                number: 80
```

### Key ALB Annotations
- `alb.ingress.kubernetes.io/scheme`: `internet-facing` or `internal`
- `alb.ingress.kubernetes.io/target-type`: `ip` or `instance`
- `alb.ingress.kubernetes.io/certificate-arn`: SSL certificate
- `alb.ingress.kubernetes.io/ssl-redirect`: Force HTTPS

## NLB Implementation

### Service Configuration
```yaml
apiVersion: v1
kind: Service
metadata:
  name: nlb-service
  namespace: game-2048
  annotations:
    service.beta.kubernetes.io/aws-load-balancer-type: external
    service.beta.kubernetes.io/aws-load-balancer-nlb-target-type: ip
    service.beta.kubernetes.io/aws-load-balancer-scheme: internet-facing
spec:
  ports:
    - port: 80
      targetPort: 80
      protocol: TCP
  type: LoadBalancer
  selector:
    app.kubernetes.io/name: app-2048
```

### Key NLB Annotations
- `service.beta.kubernetes.io/aws-load-balancer-type`: `external` or `internal`
- `service.beta.kubernetes.io/aws-load-balancer-nlb-target-type`: `ip` or `instance`
- `service.beta.kubernetes.io/aws-load-balancer-scheme`: `internet-facing` or `internal`

## Advanced Configurations

### Reusing Existing Load Balancers

Use TargetGroupBinding to connect services to existing ELBs:

```yaml
apiVersion: elbv2.k8s.aws/v1beta1
kind: TargetGroupBinding
metadata:
  name: existing-nlb
  namespace: game-2048
spec:
  serviceRef:
    name: nlb-service
    port: 80
  targetGroupARN: arn:aws:elasticloadbalancing:region:account:targetgroup/name/id
```

**Important**: Manual security group configuration required for NLB access to worker nodes.

### Health Check Configuration

#### ALB Health Checks
- Protocol: HTTP/HTTPS
- Path-based: `/health` endpoint
- Interval: Configurable (default 15s)
- Thresholds: Healthy/unhealthy counts

#### NLB Health Checks  
- Protocol: TCP/UDP
- Port-based: Connection establishment
- Interval: Configurable
- Simpler than ALB checks

## Best Practices

### Security
- Use internal load balancers for internal services
- Configure appropriate security groups for ALBs
- Implement WAF rules for ALBs facing internet traffic
- Use SSL/TLS certificates from AWS Certificate Manager

### Performance
- Choose NLB for latency-sensitive applications
- Use IP target types for better performance
- Configure appropriate health check intervals
- Monitor target group health status

### Cost Optimization
- Reuse existing load balancers where possible
- Use internal load balancers for internal communication
- Monitor data processing charges
- Consider ALB vs NLB cost implications

### Monitoring
- CloudWatch metrics for load balancer performance
- Access logs for traffic analysis
- Target group health monitoring
- Integration with AWS X-Ray for tracing

## Troubleshooting

### Common Issues
1. **Subnet tagging**: Ensure proper ELB role tags
2. **IAM permissions**: Verify ALBC service account permissions
3. **Security groups**: Check ALB security group rules
4. **Health checks**: Verify target health status
5. **DNS resolution**: Confirm load balancer DNS names

### Verification Commands
```bash
# Check controller deployment
kubectl get deployment -n kube-system aws-load-balancer-controller

# View load balancer resources
kubectl get ingress -A
kubectl get svc -A --field-selector spec.type=LoadBalancer

# Check target group bindings
kubectl get targetgroupbinding -A
```

## References

- [OSI Network Model](https://www.imperva.com/learn/application-security/osi-model/)
- [HTTPS Fundamentals](https://www.cloudflare.com/learning/ssl/what-is-https/)
- [AWS Load Balancer Controller](https://github.com/kubernetes-sigs/aws-load-balancer-controller)
- [NLB Client IP Preservation](https://docs.aws.amazon.com/elasticloadbalancing/latest/network/load-balancer-target-groups.html#client-ip-preservation)
- [AWS WAF Documentation](https://docs.aws.amazon.com/waf/latest/developerguide/what-is-aws-waf.html)