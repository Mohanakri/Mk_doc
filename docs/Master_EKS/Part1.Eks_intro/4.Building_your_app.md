# Running Your First Application on EKS

## Overview
This chapter covers deploying your first application on Amazon EKS (Elastic Kubernetes Service) cluster, exploring different deployment methods and visualization tools.

!!! info "Prerequisites"
    - EKS cluster with administrative access
    - At least two worker nodes
    - Network connectivity to EKS API endpoint
    - AWS CLI and kubectl installed

## Application Configuration Options

The following table shows different configuration domains for applications:

| Configuration Domain | Description | Chapter Reference |
|---------------------|-------------|-------------------|
| Single Pod | Deploy a single Pod from repository image to specific namespace | Current |
| Resilient deployment | Use Kubernetes Deployment for multiple Pods across worker nodes | Current |
| Updating Deployment | Update container images with rolling updates | Current |
| External service | Expose Deployment as node-port service | Current |
| Ingress controller | Expose using NGINX Ingress controller | Current |
| Multi-container Pod | Sidecar containers for health checks/service mesh | Chapter 16 |
| Load balancer | Advanced load balancing configurations | Chapter 14 |
| Auto-scaling Pods | Horizontal Pod Autoscaling | Chapter 18 |
| Storage for Pods | Persistent storage solutions | Chapter 12 |



## kubectl Configuration

### Setting up kubeconfig

kubectl requires cluster details in the kubeconfig file to communicate with the Kubernetes API server.

```bash
# Update kubeconfig for your cluster
aws eks update-kubeconfig --name mycluster --region eu-central-1
```

!!! warning "IAM Permissions Required"
    The AWS user running this command needs IAM permissions to access the EKS API.

### kubeconfig File Structure

The configuration file contains three main sections:

#### 1. Clusters Section
```yaml
clusters:
- cluster:
    certificate-authority-data: xxxxxx
    server: https://hfjhf.gr7.eu-central-1.eks.amazonaws.com
    name: arn:aws:eks:eu-central-1:334:cluster/mycluster
```

#### 2. Users Section
```yaml
users:
- name: arn:aws:eks:eu-central-1:334:cluster/mycluster
  user:
    exec:
      apiVersion: client.authentication.k8s.io/v1beta1
      args:
      - --region
      - eu-central-1
      - eks
      - get-token
      - --cluster-name
      - education-eks-D20eNmiw
      command: aws
```

#### 3. Contexts Section
```yaml
contexts:
- context:
    cluster: arn:aws:eks:eu-central-1:334:cluster/mycluster
    user: arn:aws:eks:eu-central-1:334:cluster/mycluster
    name: arn:aws:eks:eu-central-1:334:cluster/mycluster
```



## Verifying Connectivity

### Version Check
```bash
kubectl version
```

Expected output:
```
Client Version: version.Info{Major:"1", Minor:"22+", GitVersion:"v1.22.6-eks-7d68063"...}
Server Version: version.Info{Major:"1", Minor:"20+", GitVersion:"v1.20.15-eks-18ef993"...}
```

### Common Connectivity Issues

| Error | Description | Solution |
|-------|-------------|----------|
| `executable aws failed with exit code 253` | kubectl can't retrieve AWS IAM credentials | Update/add AWS credentials |
| `dial tcp 10.1.3.51:443: i/o timeout` | Network connectivity issue to private endpoint | Check IP routing and firewall settings |
| `server has asked for client to provide credentials` | RBAC permission issue | Verify IAM user has Kubernetes permissions |



## Creating Your First EKS Application

### Deploying a Single Pod

#### Quick Pod Deployment
```bash
# Interactive Pod deployment
kubectl run -it busybox --image=busybox --restart=Never
```

#### Pod Manifest (Dry Run)
```bash
kubectl run busybox --image=busybox --restart=Never --dry-run=client -o yaml
```

Generated manifest:
```yaml
apiVersion: v1
kind: Pod
metadata:
  creationTimestamp: null
  labels:
    run: busybox
  name: busybox
spec:
  containers:
  - image: busybox
    name: busybox
    resources: {}
  dnsPolicy: ClusterFirst
  restartPolicy: Never
status: {}
```



### Pod Deployment Process

1. **kubectl command** → Creates manifest and submits to Kubernetes API
2. **API server** → Persists Pod specification
3. **Scheduler** → Selects worker node through filtering and scoring
4. **kubelet** → Monitors etcd and creates Pod on assigned node
5. **Pod starts** → kubectl session attaches (with -it flag)

## Kubernetes Deployments

### Deployment Manifest
Create `chapter4-deployment.yaml`:

```yaml
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: simple-deployment
spec:
  replicas: 2
  selector:
    matchLabels:
      app: simple-deployment-app
  template:
    metadata:
      labels:
        app: simple-deployment-app
    spec:
      containers:
        - name: busybox
          image: busybox:1.34.1
          command:
            - sleep
            - "3600"
```

### Deploy and Verify
```bash
# Create deployment
kubectl create -f chapter4-deployment.yaml

# Verify deployment
kubectl get deployment simple-deployment

# View all resources
kubectl get all
```



### Modifying Deployments

#### Scaling
```bash
# Scale to 3 replicas
kubectl scale deployment simple-deployment --replicas=3
```

#### Image Updates
```bash
# Update image version
kubectl set image deployment simple-deployment busybox=busybox:1.35.0

# Check rollout status
kubectl rollout status deployment/simple-deployment
```

#### Verify Update
```bash
# Access Pod shell
kubectl exec --stdin --tty <POD_ID> -- /bin/sh

# Check version inside Pod
busybox | head -1
```



## Exposing Applications

### ClusterIP Service

Create `chapter4-basic-service.yaml`:
```yaml
---
apiVersion: v1
kind: Service
metadata:
   name: myapp 
spec:
   type: ClusterIP
   ports:
     - protocol: TCP
       port: 80
       targetPort: 9376
   selector:
     app: simple-deployment-app
```

```bash
# Deploy service
kubectl create -f chapter4-basic-service.yaml

# Verify service
kubectl get svc -o wide

# Describe service details
kubectl describe service myapp
```



### NodePort Service

Create `chapter4-basic-nodeport-service.yaml`:
```yaml
---
apiVersion: v1
kind: Service
metadata:
   name: myapp-ext
spec:
   type: NodePort
   ports:
     - protocol: TCP
       port: 80
   selector:
     app: simple-nginx-app
```

```bash
# Check NodePort service
kubectl get service
```

Output shows port mapping (e.g., `80:30496/TCP`)



### Ingress Configuration

#### Install NGINX Ingress Controller
```bash
# Deploy bare-metal controller
kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.2.0/deploy/static/provider/baremetal/deploy.yaml

# Verify controller
kubectl get service ingress-nginx-controller --namespace=ingress-nginx
```

#### Create Ingress Resource
Create `chapter4-ingress.yaml`:
```yaml
---
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: myapp-web
  annotations:
      kubernetes.io/ingress.class: nginx
      nginx.ingress.kubernetes.io/rewrite-target: /
spec:
  rules:
   - host: "myweb.packt.com"
     http:
      paths:
      - pathType: Prefix
        path: "/login"
        backend:
          service:
            name: myapp-ext
            port:
              number: 80
```

#### Test Ingress
```bash
curl -H 'Host: myweb.packt.com' http://<WORKER_NODE_IP>:31371/login
```



### AWS Load Balancer Integration

#### Deploy AWS-Integrated Controller
```bash
# Remove previous controller
kubectl delete -f chapter4-ingress.yaml
kubectl delete -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.2.0/deploy/static/provider/baremetal/deploy.yaml

# Deploy AWS-integrated controller  
kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.2.0/deploy/static/provider/aws/deploy.yaml
```

#### Verify Load Balancer
```bash
# Check service with AWS annotations
kubectl describe service ingress-nginx-controller --namespace=ingress-nginx

# Verify AWS ELB creation
aws elbv2 describe-load-balancers
```

Key annotations for AWS NLB:
- `service.beta.kubernetes.io/aws-load-balancer-type: nlb`
- `service.beta.kubernetes.io/aws-load-balancer-backend-protocol: tcp`
- `service.beta.kubernetes.io/aws-load-balancer-cross-zone-load-balancing-enabled: true`

#### Test Public Access
```bash
curl -H 'Host: myweb.packt.com' http://111-22.elb.eu-central-1.amazonaws.com/login
```



## Visualizing Workloads

### AWS Management Console

The following figure shows the main cluster panel:

**Figure 4.1 – The main cluster panel**

Access through: `http://aws.amazon.com` → Amazon Elastic Kubernetes Service → Clusters

Features available:
- Cluster overview and status
- One-click control plane upgrades
- Resource viewing (Pods, Deployments, Services)
- Node group management
- Configuration management

!!! note "RBAC Permissions"
    The IAM User/Role used in the console must have cluster (RBAC) permissions to read/get resources.

**Figure 4.2 – mycluster details panel**

The mycluster | Resources window can be used to get a list of currently running Pods, Deployments, and Services. You can also create node groups and manage configuration items such as Public Endpoint IP whitelists and add-ons.

### Third-Party Tools: Lens

#### Installation and Setup
1. Install Lens from https://k8slens.dev/
2. Configure `.kube/config` with AWS profile:

```yaml
users:
- name: arn:aws:eks:eu-central-1:11222:cluster/mycluster
  # ... other config ...
  env:
  - name: AWS_PROFILE
    value: eksprofile
```

3. Launch Lens:
```bash
# macOS command line launch
open -a lens
```

#### Lens Features
- Multi-cluster management
- Resource visualization
- Real-time monitoring
- Extension support

**Figure 4.3 – A Lens cluster view**

#### Lens Extensions
Popular extensions:
- **Resource Map Extension**: Visualize resource relationships
- **Pod Security Standards**: Security policy insights
- **Prometheus**: Metrics integration

**Figure 4.4 – An example Resource Map**

The Resource Map Extension (https://github.com/nevalla/lens-resource-map-extension) from Lauri Nevala provides visualization of cluster resources and their relationships. For a complete list of extensions, see https://github.com/lensapp/lens-extensions/blob/main/README.md.

## Best Practices Summary

### Deployment Strategy
- Use Deployments instead of bare Pods for production
- Implement proper resource requests and limits
- Use appropriate restart policies
- Label resources consistently

### Service Exposure
- Start with ClusterIP for internal services
- Use NodePort for simple external access
- Implement Ingress for HTTP/HTTPS routing
- Integrate with cloud load balancers for production

### Security Considerations
- Follow least privilege principle for RBAC
- Use network policies to restrict traffic
- Implement proper authentication and authorization
- Regular security updates and patches

### Monitoring and Observability
- Use multiple visualization tools
- Implement proper logging strategy
- Set up monitoring and alerting
- Regular cluster health checks

## Useful Commands Reference

### Basic Operations
```bash
# Check cluster connectivity
kubectl version

# View all resources
kubectl get all

# Describe specific resource
kubectl describe <resource-type> <resource-name>

# Access Pod shell
kubectl exec -it <pod-name> -- /bin/sh

# View logs
kubectl logs <pod-name>
```

### Deployment Management
```bash
# Scale deployment
kubectl scale deployment <name> --replicas=<number>

# Update image
kubectl set image deployment <name> <container>=<image>

# Check rollout status
kubectl rollout status deployment/<name>

# Rollback deployment
kubectl rollout undo deployment/<name>
```

### Service and Network
```bash
# Port forward for testing
kubectl port-forward service/<service-name> <local-port>:<service-port>

# Test service connectivity
kubectl run test-pod --image=busybox -it --rm -- wget -qO- <service-name>

# View endpoints
kubectl get endpoints
```

## Further Reading

- [Understanding Deployments](https://kubernetes.io/docs/concepts/workloads/controllers/deployment/)
- [Understanding Services](https://kubernetes.io/docs/concepts/services-networking/service/)
- [NGINX Ingress Controller with AWS NLB](https://aws.amazon.com/blogs/opensource/network-load-balancer-nginx-ingress-controller-eks/)
- [NGINX Ingress Examples](https://kubernetes.github.io/ingress-nginx/examples/)
- [Kubernetes Lens](https://k8slens.dev/)
- [kubectl Cheat Sheet](https://kubernetes.io/docs/reference/kubectl/cheatsheet/)

---

!!! tip "Next Steps"
    In the next chapter, learn how Helm can create flexible, parameterized manifests for different environments and requirements.