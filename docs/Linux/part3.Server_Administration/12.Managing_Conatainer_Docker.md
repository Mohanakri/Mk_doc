# Managing Containers with Docker

## Overview

Docker is one of the most well-known tools for creating and managing containers, serving as the foundation of modern cloud technology. This guide covers essential Docker concepts and practical implementation.

## Understanding Linux Containers

### Comparing Containers and VMs

**Virtual Machines (VMs):**
- Emulate machine hardware
- Create multiple isolated machines on single hardware
- Include full operating system

**Containers:**
- Share the base OS kernel with host
- Use shared libraries and binaries
- Provide OS-level virtualization
- Much more lightweight than VMs

![Containers versus VMs](images/containers-vs-vms.png)
*Figure 12.1 – Containers versus VMs (general scheme)*

### Key Differences

| Aspect | Containers | VMs |
|--------|------------|-----|
| Resource Usage | Lightweight | Heavy |
| OS | Shared kernel | Separate OS |
| Isolation | Process-level | Hardware-level |
| Boot Time | Seconds | Minutes |
| Portability | High | Medium |

## Underlying Container Technology

### Historical Context

- **1982**: Unix `chroot` - early containerization
- **2008**: Linux Containers (LXC) introduced
- **2013**: Docker revolutionized container landscape

### Core Technologies

#### Linux Namespaces

Namespaces provide isolation by wrapping global system resources in abstraction layers:

- **Mount**: Restricts filesystem mount point visibility
- **UTS (Unix Time Sharing)**: Isolates hostname and domain name
- **IPC (Interprocess Communication)**: Private IPC resources
- **PID (Process Identification)**: Process ID mapping and isolation
- **Network**: Private network stack with interfaces, routing tables
- **User**: UID/GID mapping including root privileges
- **cgroup**: Filesystem paths relative to namespace root

**View namespaces:**
```bash
lsns
```

![Using lsns to view namespaces](images/lsns-namespaces.png)
*Figure 12.2 – Using lsns to view the available namespaces*

#### Linux cgroups (Control Groups)

- Restrict and manage resource allocation to processes
- Control memory, CPU, I/O, and network usage
- Hierarchical structure with inheritance
- Combined with namespaces to create container isolation

## Docker Architecture

### Core Components

![Docker Architecture](images/docker-architecture.png)
*Figure 12.3 – Docker architecture*

#### Container Runtime
- **containerd**: Downloads and runs Docker images
- **runc**: Manages namespaces and cgroups (OCI compliant)

#### Docker Engine
- **dockerd daemon**: Core service
- **API interface**: RESTful API
- **CLI**: Command-line interface

![Docker Architecture Details](images/docker-architecture-details.png)
*Figure 12.4 – Docker architecture details*

### Docker Workflow

![Docker Workflow](images/docker-workflow.png)
*Figure 12.5 – Docker workflow*

**Components:**
1. **Client**: User interface for Docker commands
2. **Host/Daemon**: Manages images, containers, networks, volumes
3. **Registry**: Stores Docker images (Docker Hub, private registries)

## Installing Docker

### Prerequisites
- Working Linux installation (Ubuntu/Debian or Fedora/RHEL)
- Administrative privileges

### Installation Steps (Debian/Ubuntu)

1. **Install prerequisites:**
```bash
sudo apt update -y && sudo apt install ca-certificates curl gnupg
```

2. **Add Docker GPG key:**
```bash
sudo install -m 0755 -d /etc/apt/keyrings
curl -fsSL https://download.docker.com/linux/debian/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg
sudo chmod a+r /etc/apt/keyrings/docker.gpg
```

3. **Set up repository:**
```bash
echo "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/debian $(. /etc/os-release && echo "$VERSION_CODENAME") stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
```

4. **Update package list:**
```bash
sudo apt update -y
```

5. **Install Docker packages:**
```bash
sudo apt install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
```

6. **Verify installation source:**
```bash
apt-cache policy docker-ce
```

![Verifying source repository](images/verify-docker-source.png)
*Figure 12.6 – Verifying the source repository*

7. **Check Docker daemon status:**
```bash
sudo systemctl status docker
```

8. **Add user to docker group:**
```bash
sudo usermod -aG docker ${USER}
```

9. **Enable Docker at startup:**
```bash
sudo systemctl enable docker
```

## Essential Docker Commands

### Testing Installation

```bash
docker run hello-world
```

![First Docker run command](images/first-docker-run.png)
*Figure 12.7 – Running the first docker run command*

### Image Management

#### Search for images:
```bash
docker search ubuntu
```

![Searching for Ubuntu image](images/docker-search-ubuntu.png)
*Figure 12.8 – Searching for the Ubuntu image*

#### Download images:
```bash
docker pull ubuntu
```

#### List local images:
```bash
docker images
```

![Docker images command](images/docker-images-list.png)
*Figure 12.9 – Running the docker images command*

### Container Management

#### Running Containers

**Interactive mode:**
```bash
docker run -it ubuntu
```

**Detached mode:**
```bash
docker run -d ubuntu
```

**With network specification:**
```bash
docker run -itd --network=bridge ubuntu
```

#### Listing Containers

```bash
# Active containers only
docker ps

# All containers (active and inactive)
docker ps -a

# Latest created container
docker ps -l
```

![Listing containers](images/docker-ps-commands.png)
*Figure 12.10 – Listing containers with the docker ps command*

#### Container Lifecycle Management

**Start container:**
```bash
docker start container_name_or_id
```

**Stop container:**
```bash
docker stop container_name_or_id
```

**Remove container:**
```bash
docker rm container_name_or_id
```

![Starting and stopping containers](images/start-stop-containers.png)
*Figure 12.11 – Starting and stopping containers*

### Docker Networking

#### Network Commands

**List networks:**
```bash
docker network ls
```

![Available networks](images/docker-networks.png)
*Figure 12.14 – Showing the available networks*

**Connect container to network:**
```bash
docker network connect bridge container_name
```

### Committing Changes

**Save container state as new image:**
```bash
docker commit -m "commit message" -a "author" container_id new_image_name
```

![New image committed](images/docker-commit-image.png)
*Figure 12.17 – A new image committed locally*

## Working with Dockerfiles

### Dockerfile Instructions

| Instruction | Purpose | Example |
|-------------|---------|---------|
| `FROM` | Base image (must be first) | `FROM ubuntu:20.04` |
| `LABEL` | Add metadata | `LABEL version="1.0"` |
| `RUN` | Execute commands | `RUN apt-get update` |
| `ADD` | Copy files (with URL support) | `ADD file.txt /app/` |
| `COPY` | Copy files/directories | `COPY . /app/` |
| `CMD` | Default command | `CMD ["python", "app.py"]` |
| `USER` | Set user context | `USER www-data` |
| `WORKDIR` | Set working directory | `WORKDIR /app` |
| `ENTRYPOINT` | Configure executable | `ENTRYPOINT ["python"]` |

### Building Images from Dockerfiles

#### Example Dockerfile Structure:
```dockerfile
# Use official base image
FROM debian:11

# Set maintainer information
LABEL maintainer="user@example.com"

# Update package list and install Python
RUN apt-get update -y && \
    apt-get install -y python3 python3-pip && \
    apt-get clean

# Set working directory
WORKDIR /app

# Default command
CMD ["python3", "--version"]
```

![Creating Dockerfile](images/create-dockerfile.png)
*Figure 12.18 – Creating the Dockerfile*

#### Build Command:
```bash
docker build -f dockerfile_name -t image_name path_to_context
```

**Example:**
```bash
docker build ~/my_docker_images -f py_env_dockerfile -t pydeb
```

![Building custom image](images/build-custom-image.png)
*Figure 12.19 – Building a new custom image from a Dockerfile*

## Deploying Applications

### Web Application Deployment

#### Example: Static Website with NGINX

1. **Prepare application files:**
```bash
wget https://www.free-css.com/assets/files/free-css-templates/download/page262/focus.zip
unzip focus.zip
```

2. **Create Dockerfile:**
```dockerfile
FROM nginx:latest
COPY . /usr/share/nginx/html
```

![Dockerfile contents](images/webapp-dockerfile.png)
*Figure 12.21 – Contents of a new Dockerfile*

3. **Build image:**
```bash
docker build -f webapp_dockerfile -t webapp .
```

![Webapp Docker image](images/webapp-image-created.png)
*Figure 12.22 – The new webapp Docker image was created*

4. **Run container with port mapping:**
```bash
docker run -it -d -p 8080:80 webapp
```

![Docker run output](images/docker-run-webapp.png)
*Figure 12.23 – The output of the docker run command*

5. **Access application:**
   - Open browser and navigate to `http://localhost:8080`

![Running web app](images/webapp-browser.png)
*Figure 12.24 – Running the web app in our web browser*

## Best Practices

### Security
- Use official base images when possible
- Keep images updated
- Don't run containers as root user
- Use multi-stage builds to reduce image size

### Performance
- Minimize image layers
- Use `.dockerignore` to exclude unnecessary files
- Clean up package caches in same RUN instruction
- Use specific version tags instead of `latest`

### Development Workflow
- Use volume mounts for development
- Leverage Docker Compose for multi-container applications
- Tag images appropriately for different environments

## Common Docker Commands Cheat Sheet

| Command | Purpose |
|---------|---------|
| `docker --help` | Show help |
| `docker version` | Show Docker version |
| `docker info` | Display system information |
| `docker pull image:tag` | Download image |
| `docker push image:tag` | Upload image to registry |
| `docker build -t name .` | Build image from Dockerfile |
| `docker run -it image` | Run interactive container |
| `docker exec -it container bash` | Execute command in running container |
| `docker logs container` | View container logs |
| `docker inspect container` | Detailed container information |

## Troubleshooting

### Common Issues

1. **Permission denied errors:**
   - Ensure user is in docker group
   - Log out and back in after adding to group

2. **Network connectivity issues:**
   - Check network configuration with `docker network ls`
   - Connect container to appropriate network

3. **Image build failures:**
   - Check Dockerfile syntax
   - Verify base image availability
   - Review build context

4. **Container won't start:**
   - Check logs with `docker logs container_name`
   - Verify port conflicts
   - Check resource availability

## Next Steps

After mastering these Docker fundamentals:
- Explore Docker Compose for multi-container applications
- Learn about container orchestration with Kubernetes
- Implement CI/CD pipelines with Docker
- Study container security best practices
- Investigate Docker Swarm for clustering

## Summary

Docker revolutionizes application deployment by providing:
- Lightweight containerization
- Consistent environments across development and production
- Easy application packaging and distribution
- Efficient resource utilization
- Simplified deployment processes

This foundation prepares you for modern DevOps practices and cloud-native application development.