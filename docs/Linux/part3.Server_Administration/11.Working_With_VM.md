# Chapter 11: Working with Virtual Machines

## Introduction to Virtualization on Linux

### What is Virtualization?

Virtualization is a way to make more efficient use of computer hardware through an abstraction layer that takes advantage of the computer's resources. This allows better utilization of all the physical machine's capabilities and resources.

### Efficiency in Resource Usage

The abstraction layer that virtualization uses is a software layer that allows more efficient use of all computer components. This enables better utilization of physical machine capabilities and resources.

**Example scenario:**
- Physical machines: Intel NUCs with i3 CPU (4 cores), 16GB RAM
- Traditional use: One service per machine = underutilized resources
- Virtualized use: Four VMs per machine (1 CPU core, 2GB RAM each) = efficient resource usage

![Comparison between single computer use and using multiple VMs](images/figure_11_1.png)

### How Virtualization Works on Host OS

Virtualization works on top of a host operating system, with the hypervisor managing multiple virtual machines.

![How virtualization works on a host OS](images/figure_11_2.png)

**Benefits of virtualization:**
- More efficient hardware usage
- Increased energy efficiency
- Reduced carbon footprint
- Better resource allocation in data centers

## Introduction to Hypervisors

### What is a Hypervisor?

The software layer that virtualization is based on is called a **hypervisor**. Physical resources are divided and used as virtual computers (VMs) through the process of emulation.

> **Important Note:** The process of emulation is basically an imitation process through which software replicates the functions of another system. The hypervisor simulates hardware usage as if it were a different system altogether.

### Types of Hypervisors

**Type 1 Hypervisors (Bare Metal):**
- Run directly on hardware
- Examples: Citrix Xen Server, VMware ESXi

**Type 2 Hypervisors (Host-based):**
- Run on top of existing OS
- Examples: Oracle VirtualBox, VMware Workstation/Fusion

**KVM Classification:**
- Mostly classified as Type 1 (bare-metal)
- Underlying system is a full OS, so also classified as Type 2
- Hybrid classification due to its unique architecture

## Understanding Linux KVM

### What is a Virtual Machine?

A VM is similar to a standalone computer - a software-based emulator that:
- Has access to host computer's resources (CPU, RAM, storage, networking)
- Functions as a virtual environment with same capabilities as physical computer
- Is isolated from other VMs and the host computer
- Can run different guest operating systems

### Choosing KVM as Hypervisor

**Why KVM?**
- Open source virtualization project
- Available on all major Linux distributions
- Modern hypervisor using specific kernel modules
- Takes advantage of Linux kernel benefits:
  - Memory support
  - Scheduler
  - Nested virtualization
  - GPU pass-through

**Alternative: GNOME Boxes**
- Available for GNOME desktop environment
- Shares libvirt and QEMU code with KVM
- Good option for newcomers to Linux

### KVM Architecture: QEMU and libvirt

**QEMU (Quick Emulator):**
- Emulator software for hardware components and peripherals
- Functions as both emulator and virtualizer
- Uses Tiny Code Generator (TCG) for binary translation

**libvirt:**
- Main management tool and daemon
- Controls the hypervisor
- Provides API for KVM
- CLI tool: `virsh`
- GUI tool: `virt-manager`

![Comparison between software- and hardware-assisted virtualization](images/figure_11_3.png)

**Software-assisted vs Hardware-assisted Virtualization:**
- **Software-assisted:** Uses dynamic binary translation, unprivileged instructions go directly to hardware
- **Hardware-assisted:** Better performance, less complexity, different instruction paths

## Installing KVM on Major Linux Distributions

### Installation Commands

**Debian/Ubuntu:**
```bash
sudo apt install qemu-kvm libvirt-clients libvirt-daemon-system bridge-utils virtinst libvirt-daemon virt-manager
```

**Fedora:**
```bash
sudo dnf group install --with-optional virtualization
```

**openSUSE:**
```bash
sudo zypper install -t pattern kvm_server kvm_tools
sudo zypper install libvirt-daemon
```

### Starting and Enabling Services

```bash
sudo systemctl start libvirtd
sudo systemctl enable libvirtd
```

### Validation

Check KVM compatibility:
```bash
sudo virt-host-validate
```

![Running the host validation program](images/figure_11_4.png)

## Working with Basic KVM Commands

### Setting Up Network Bridge

Check network configuration:
```bash
sudo virsh net-list
```

Start default bridge network:
```bash
sudo virsh net-start default
sudo virsh net-autostart default
```

![Enabling the default bridge connection](images/figure_11_5.png)

### Creating Your First VM

1. **Download OS image:**
```bash
wget https://releases.ubuntu.com/22.04.2/ubuntu-22.04.2-live-server-amd64.iso
```

2. **Move ISO to libvirt directory:**
```bash
sudo mv ubuntu-22.04.2-live-server-amd64.iso /var/lib/libvirt/images/
```

3. **Create VM using virt-install:**
```bash
virt-install --virt-type=kvm --name ubuntu-vm1 --vcpus=2 --memory=2048 --os-variant=ubuntufocal --cdrom=/var/lib/libvirt/images/ubuntu-22.04.2-live-server-amd64.iso --network=default --disk size=20
```

**Mandatory Arguments:**
- `--virt-type`: Type of the new VM
- `--name`: VM name
- `--memory`: Amount of RAM
- `--vcpus`: Number of virtual CPUs
- `--disk size`: Storage amount
- `--os-variant`: Guest OS type
- `--network`: Bridge network
- `--cdrom`: ISO file location

## Basic VM Management

### Essential VM Commands

**List VMs:**
```bash
sudo virsh list
```

**VM State Management:**
```bash
# Force stop a VM
sudo virsh destroy ubuntu-vm1

# Reboot a VM
sudo virsh reboot ubuntu-vm1

# Pause (suspend) a VM
sudo virsh suspend ubuntu-vm1

# Start a VM
sudo virsh start ubuntu-vm1

# Resume a suspended VM
sudo virsh resume ubuntu-vm1

# Delete a VM completely
sudo virsh undefine ubuntu-vm1
```

![Commands for VM management](images/figure_11_6.png)

> **Important Note:** VM management commands require root privileges or sudo access.

## Advanced KVM Management

### Connecting to VMs

**Find VM IP addresses:**
```bash
# List all VMs
sudo virsh list --all

# Get specific VM IP
sudo virsh domifaddr [vm_name]
```

![Showing the IP addresses for VMs](images/figure_11_8.png)

**Connect via SSH:**
```bash
ssh username@vm_ip_address
```

![Connect to a VM through SSH](images/figure_11_9.png)

**Connect via virt-viewer:**
```bash
virt-viewer --connect qemu:///system ubuntu-vm1
```

![Connecting to VM using virt-viewer](images/figure_11_10.png)

### Cloning VMs

**Prerequisites:**
- VM must be stopped or suspended

**Clone process:**
```bash
# Stop the VM
sudo virsh shutdown ubuntu-vm1

# Clone the VM
sudo virt-clone --original ubuntu-vm1 --name ubuntu-vm1-clone1 --auto-clone
```

![Cloning virtual machines using virt-clone](images/figure_11_11.png)

**Cloning transfers:**
- vCPU configuration
- RAM settings
- Bridge networking configuration
- MAC address (can cause conflicts)
- IP address (can cause conflicts)

### Creating VM Templates

**Install required tools:**
```bash
sudo apt install libguestfs-tools
```

**Template creation process:**
1. Create base VM
2. Install and update OS
3. Shut down VM
4. Backup VM file (optional):
```bash
sudo cp /var/lib/libvirt/images/ubuntu-template.qcow2 /var/lib/libvirt/images/ubuntu-back-template.qcow2
```
5. Prepare template:
```bash
sudo virt-sysprep -d ubuntu-template
```

![Creating a template with virt-sysprep](images/figure_11_12.png)

**Template benefits:**
- Removes configuration files
- Resets MAC and IP configurations
- Clears user settings and SSH host keys
- Creates clean, reusable base image

### Resource Management

**Get host information:**
```bash
sudo virsh nodeinfo
```

![Finding host information with the nodeinfo command](images/figure_11_13.png)

**Get VM information:**
```bash
sudo virsh dominfo vm_name
```

![Showing the VMs' resource usage](images/figure_11_15.png)

**Check disk usage:**
```bash
virt-df -d vm_name -h
```

![Showing disk usage for a VM](images/figure_11_16.png)

**Modify VM resources:**
```bash
# Change vCPU count
sudo virsh setvcpus vm_name new_cpu_count

# Change memory allocation
sudo virsh setmem vm_name new_memory_amount
sudo virsh setmaxmem vm_name new_max_memory
```

![Changing the vCPU count for a VM](images/figure_11_17.png)
![Changing the memory used by a VM](images/figure_11_18.png)

## Provisioning VMs using Cloud-init

### Understanding Cloud-init

Cloud-init is a tool developed by Canonical for configuring VM instances on cloud platforms. It's written in Python and considered an industry standard for provisioning cloud images.

**Key features:**
- Configuration during specific boot stages
- Manages networking, boot sequence, and local configuration
- Available on most Linux distributions
- Uses YAML configuration files

### Installing and Configuring Cloud-init

**Install required packages:**
```bash
sudo apt install cloud-image-utils cloud-init
```

**Prepare cloud image:**
```bash
# Create directory
mkdir local-cloud-images && cd local-cloud-images

# Download cloud image
wget https://cloud-images.ubuntu.com/jammy/current/jammy-server-cloudimg-amd64.img

# Get image info
qemu-img info jammy-server-cloudimg-amd64.img

# Resize image
qemu-img resize jammy-server-cloudimg-amd64.img 15G

# Create qcow2 base image
qemu-img create -f qcow2 -F qcow2 -b jammy-server-cloudimg-amd64.img ubuntu.qcow2 15G

# Copy to libvirt directory
sudo cp ubuntu.qcow2 /var/lib/libvirt/images/
```

**Create configuration files:**
```bash
# Create directory for config files
sudo mkdir /var/lib/libvirt/images/cloud-init
cd /var/lib/libvirt/images/cloud-init/

# Create configuration files
sudo touch user-data meta-data network-config
```

**Configure user-data file:**
![The user-data file contents](images/figure_11_20.png)

**Create configuration disk:**
```bash
cloud-localds -v ubuntu-provisioning.qcow2 user-data meta-data
```

**Deploy VM:**
```bash
sudo virt-install --name vm01 --virt-type kvm --vcpus 1 --memory 2048 \
--disk path=/var/lib/libvirt/images/ubuntu.qcow2,device=disk \
--disk path=/var/lib/libvirt/images/cloud-init/ubuntu-provisioning.qcow2,device=cdrom \
--os-type linux --os-variant generic --import --network network=default --noautoconsole
```

![Creating a new VM](images/figure_11_21.png)

## Public Key Authentication with SSH

### Understanding SSH Key Authentication

Public key authentication provides better security than password authentication through cryptographic key pairs:
- **Private key:** Stored on local machine
- **Public key:** Stored on target VM/server
- Keys stored in `~/.ssh/` directory

### Generating SSH Keys

**Create key pair:**
```bash
ssh-keygen
```

**Options:**
- `-t`: Specify encryption algorithm
- `-b`: Specify key bits
- Default: RSA with 3,072-bit key

![Using the ssh-keygen to create a pair of SSH keys](images/figure_11_23.png)

**Key files:**
- `id_rsa`: Private key
- `id_rsa.pub`: Public key

![The SSH public key](images/figure_11_24.png)

### Copying Public Keys

**Copy key to remote machine:**
```bash
ssh-copy-id username@ip_address
```

This command safely copies your public key to the target machine for passwordless authentication.

## Summary

This chapter covered essential virtualization concepts and practical KVM management:

- **Virtualization fundamentals:** Understanding efficiency and resource usage
- **Hypervisor types:** Type 1 (bare-metal) vs Type 2 (host-based)
- **KVM architecture:** QEMU emulation and libvirt management
- **Installation:** Setting up KVM on major Linux distributions
- **Basic operations:** Creating, starting, stopping, and managing VMs
- **Advanced management:** Cloning, templating, and resource allocation
- **Cloud-init:** Automated VM provisioning
- **SSH authentication:** Secure key-based access

These skills provide the foundation for modern cloud technologies and efficient server management in Linux environments.

## Exercises

1. **Enumerate and describe the types of hypervisors**
   - Research Type 1 vs Type 2 hypervisors
   - Compare their advantages and disadvantages

2. **Practice installing hypervisors**
   - Install KVM on different Linux distributions
   - Compare installation processes

3. **Verify hypervisor functionality**
   - Use `virt-host-validate` command
   - Troubleshoot any compatibility issues

4. **Compare hypervisors**
   - Test both KVM and VirtualBox
   - Document performance and feature differences

5. **VM networking practice**
   - Find VM IP addresses using `virsh domifaddr`
   - Practice SSH connections to VMs