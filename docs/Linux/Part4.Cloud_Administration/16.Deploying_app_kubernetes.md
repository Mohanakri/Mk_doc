# Chapter 16: Deploying Applications with Kubernetes

## Table of Contents
- [Introduction](#introduction)
- [Technical Requirements](#technical-requirements)
- [Introducing Kubernetes](#introducing-kubernetes)
- [Understanding Kubernetes Architecture](#understanding-kubernetes-architecture)
- [Kubernetes Object Model](#kubernetes-object-model)
- [Anatomy of a Kubernetes Cluster](#anatomy-of-a-kubernetes-cluster)
- [Installing and Configuring Kubernetes](#installing-and-configuring-kubernetes)
- [Working with Kubernetes](#working-with-kubernetes)
- [Summary](#summary)

## Introduction

Kubernetes is an open source container orchestrator that can be your platform of choice whether you are:
- A seasoned system administrator managing containerized applications
- A DevOps engineer automating app orchestration workflows

This chapter covers:
- Kubernetes architecture and API object model
- Installing and configuring Kubernetes
- Working with kubectl command-line tool
- Deploying and scaling applications

## Technical Requirements

### Prerequisites
- Familiarity with Linux and CLI
- Good grasp of TCP/IP networking
- Understanding of Docker containers

### Hardware Requirements
- Local desktop machine with Linux distribution (Debian/Ubuntu LTS)
- Powerful desktop system with:
  - At least 8 CPU cores
  - At least 16 GB of RAM
- Desktop hypervisor

## Introducing Kubernetes

### What is Kubernetes?
Kubernetes is an open source container orchestrator initially developed by Google. A container orchestrator automatically manages containerized applications including:
- Provisioning
- Deployment
- Scaling

### Key Features of Container Orchestration

#### 1. Elastic Orchestration (Autoscaling)
- Automatically starts and stops application services based on requirements
- Example: Launching multiple web server instances with increasing requests

#### 2. Workload Management
- Optimally deploys and distributes application services across cluster
- Ensures mandatory dependencies and redundancy

#### 3. Infrastructure Abstraction
- Provides container runtime, networking, and load-balancing capabilities
- Distributes load among multiple containers

#### 4. Declarative Configuration
- Describes and ensures desired state of multi-tiered applications
- Example: Web server ready only when database backend is running

### Real-World Example: Video-on-Demand Service
With a popular new TV show:
- **Scale Out**: Increase web servers based on streaming volume
- **Control Components**: Scale database instances and storage cache
- **Scale Down**: Terminate surplus instances when demand drops
- **Cost Reduction**: Automatically reduces deployment footprint

### Benefits of Kubernetes

1. **Speedy Deployment**: Fast container creation and launch
2. **Quick Iterations**: Straightforward application upgrades
3. **Rapid Recovery**: Automatic restoration from failures
4. **Reduced Operation Costs**: Minimal administration with low resource usage

## Understanding Kubernetes Architecture

### Three Core Concepts

1. **Declarative Configuration/Desired State**
   - Describes overall application state and microservices
   - Deploys required containers and related resources

2. **Controllers/Controller Loops**
   - Monitors desired state of system
   - Takes corrective action when needed

3. **API Object Model**
   - Represents actual implementation of desired state
   - Uses configuration objects and APIs for interaction

![Figure 16.1 – Kubernetes cluster architecture](images/figure-16-1-kubernetes-architecture.png)

## Kubernetes Object Model

### Configuration Models

#### Declarative Configuration Model
- Describes system state using configuration files (YAML/JSON)
- Usually includes multiple API objects
- Regards system as a whole

#### Imperative Configuration Model
- Uses individual commands for specific API objects
- Acts on single target or subsystem

### Key API Objects

#### 1. API Server
The central hub of Kubernetes object model:
- **Internal Access**: By other API objects
- **External Access**: By configuration and management workflows
- Acts as gateway for cluster interaction
- Exposes HTTP REST interface using JSON payloads

#### 2. Pods
Basic working unit in Kubernetes:
- Represents single- or multi-container application
- Known as "unit of scheduling"
- Containers within same pod deployed together on same node

**Essential Features of Pods:**
- **Ephemeral Nature**: Once terminated, gone forever
- **Atomic Unit**: Either deployed or not (all containers must deploy)
- **Health Monitoring**: Uses probes (liveness and readiness)

**Example Pod Types:**
- Web server (Nginx)
- Authentication (Vault)
- Database (PostgreSQL)
- Storage (NAS)

#### 3. Controllers
Control loops responsible for maintaining desired state:

**ReplicaSets:**
- Manage collection of pod replicas
- Accommodate specific number of pod replicas
- Replace failed pods automatically

**Deployment Controllers:**
- Monitor Kubernetes Deployments
- Create ReplicaSets with required pods
- Manage rollout/upgrade scenarios
- Handle transition between ReplicaSet versions

#### 4. Services
Provide persistent access to pods:
- Route traffic to corresponding application endpoints
- Provide network abstraction (IP addresses, routing, DNS)
- Dynamically update endpoints as pods change
- Load-balance traffic between pods

#### 5. Storage
Various storage types for cluster applications:

**Volumes:**
- Data lost when pod terminates (ephemeral)

**Persistent Volumes:**
- Defined at cluster level
- Independent of pods
- Reserved through Persistent Volume Claims
- Maintain state across pod replacements

## Anatomy of a Kubernetes Cluster

A Kubernetes cluster consists of:
- **One Control Plane (CP) node**
- **One or more worker nodes**

### Kubernetes Control Plane (CP)

The CP provides essential services and runs on dedicated node (master node):

#### Key Subsystems:
- **API Server**: Central communication hub and management endpoint
- **Scheduler**: Decides when and which nodes to deploy pods
- **Controller Manager**: Maintains control loops for desired state
- **etcd**: Highly available database maintaining cluster state
- **kubectl**: Primary administrative CLI

### Kubernetes Worker Nodes

Nodes run actual application pods and maintain their lifecycle:

#### Key Elements:
- **Kubelet**: Processes CP requests to deploy pods, monitors state
- **Kube-Proxy**: Configures virtual networking, routes traffic
- **Container Runtime**: Provides runtime environment using CRI

## Installing and Configuring Kubernetes

### Desktop Installation Options

For experimentation, desktop versions deploy single-node clusters:

- **Docker Desktop** (macOS, Windows)
- **minikube** (Linux, macOS, Windows)
- **Microk8s** (Linux, macOS, Windows)
- **k3s** (Linux)

#### Installing Microk8s on Debian/Ubuntu

```bash
# Install snapd if not already installed
sudo apt install snapd

# Install snap core runtime
sudo snap install core

# Install microk8s
sudo snap install microk8s --classic
```

![Figure 16.2 – Installing Microk8s on Linux](images/figure-16-2-microk8s-install.png)

**Setup user permissions:**
```bash
sudo usermod -aG microk8s $USER
sudo chown -f -R $USER ~/.kube
```

**Basic commands:**
```bash
# Get help
microk8s help

# Check status
microk8s status
```

### VM Installation

#### Lab Environment Specifications
- **Hypervisor**: VMware Fusion/KVM
- **Cluster**: 1 CP node + 3 worker nodes
- **CP Node**: k8s-cp1 (192.168.122.104)
- **Worker Nodes**:
  - k8s-n1 (192.168.122.146)
  - k8s-n2 (192.168.122.233)  
  - k8s-n3 (192.168.122.163)
- **VMs**: Ubuntu Server 22.04.3 LTS, 2 vCPUs, 2 GB RAM, 20 GB disk
- **User**: packt (with SSH access)

#### Preparing Lab Environment

**Configure /etc/hosts on each node:**

![Figure 16.3 – The /etc/hosts file on the CP node](images/figure-16-3-hosts-file.png)

**Required Firewall Ports:**

![Figure 16.4 – Ports used by Kubernetes cluster nodes](images/figure-16-4-kubernetes-ports.png)

#### Installation Steps

**Step 1: Disable Swapping**

```bash
# Disable swap immediately
sudo swapoff -a

# Persist across reboots
sudo sed -i '/\s*swap\s*/s/^\(.*\)$/# \1/g' /etc/fstab

# Verify changes
cat /etc/fstab
```

![Figure 16.5 – Disabling swap entries in /etc/fstab](images/figure-16-5-disable-swap.png)

**Step 2: Installing containerd**

```bash
# Enable kernel modules
sudo modprobe br_netfilter
sudo modprobe overlay

# Persist modules across reboots
cat <<EOF | sudo tee /etc/modules-load.d/containerd.conf
br_netfilter
overlay
EOF

# Apply sysctl parameters
cat <<EOF | sudo tee /etc/sysctl.d/containerd.conf
net.bridge.bridge-nf-call-iptables = 1
net.bridge.bridge-nf-call-ip6tables = 1
net.ipv4.ip_forward = 1
EOF

# Apply changes immediately
sudo sysctl --system
```

![Figure 16.6 – Setting containerd prerequisites](images/figure-16-6-containerd-prerequisites.png)

**Verify system variables:**
```bash
sudo sysctl net.bridge.bridge-nf-call-iptables net.bridge.bridge-nf-call-ip6tables net.ipv4.ip_forward
```

![Figure 16.7 – Verifying system variables](images/figure-16-7-verify-sysctl.png)

**Install and configure containerd:**
```bash
# Update repository
sudo apt update

# Install containerd
sudo apt install -y containerd

# Generate default configuration
sudo mkdir -p /etc/containerd
containerd config default | sudo tee /etc/containerd/config.toml
```

**Configure systemd cgroup driver:**
Edit `/etc/containerd/config.toml` and add:

```toml
[plugins."io.containerd.grpc.v1.cri".containerd.runtimes.runc.options]
SystemdCgroup = true
```

![Figure 16.8 – Modifying containerd configuration](images/figure-16-8-containerd-config.png)

```bash
# Restart containerd
sudo systemctl restart containerd

# Check status
sudo systemctl status containerd
```

**Step 3: Installing Kubernetes Packages**

```bash
# Install prerequisites
sudo apt install -y apt-transport-https ca-certificates curl

# Download GPG key
sudo curl -fsSL https://pkgs.k8s.io/core:/stable:/v1.28/deb/Release.key | sudo gpg --dearmor -o /etc/apt/keyrings/kubernetes-apt-keyring.gpg

# Add repository
echo 'deb [signed-by=/etc/apt/keyrings/kubernetes-apt-keyring.gpg] https://pkgs.k8s.io/core:/stable:/v1.28/deb/ /' | sudo tee /etc/apt/sources.list.d/kubernetes.list

# Update repository
sudo apt update -y

# Install Kubernetes packages
sudo apt install -y kubelet kubeadm kubectl

# Pin package versions
sudo apt-mark hold containerd kubelet kubeadm kubectl

# Enable services
sudo systemctl enable containerd
sudo systemctl enable kubelet
```

![Figure 16.9 – Pinning Kubernetes packages](images/figure-16-9-pin-packages.png)

**Check kubelet status:**
```bash
sudo systemctl start kubelet && sudo systemctl status kubelet
```

![Figure 16.10 – kubelet crashing without cluster configuration](images/figure-16-10-kubelet-status.png)

### Introducing kubeadm

kubeadm is a helper tool for creating Kubernetes clusters:

- `kubeadm init`: Bootstraps/initializes cluster
- `kubeadm join`: Adds node to cluster

#### kubeadm init Process

1. **Running preliminary checks**: CPU, memory, permissions, container runtime
2. **Creating Certificate Authority**: Self-signed CA for cluster certificates
3. **Generating kubeconfig files**: Configuration for API server communication
4. **Generating static pod manifests**: System pods (API server, scheduler, etc.)
5. **Waiting for static pods**: Ensures pods are running
6. **Tainting CP node**: Excludes CP from user pods
7. **Generating bootstrap token**: For joining new nodes
8. **Starting add-on pods**: DNS and kube-proxy

### Creating Kubernetes CP Node

**Download Calico manifest:**
```bash
curl https://raw.githubusercontent.com/projectcalico/calico/v3.26.1/manifests/calico.yaml -O
```

**Create cluster configuration:**
```bash
kubeadm config print init-defaults | tee k8s-config.yaml
```

**Modify k8s-config.yaml:**

1. Change `advertiseAddress` to CP node IP:

![Figure 16.11 – Modifying advertiseAddress parameter](images/figure-16-11-advertise-address.png)

2. Update `criSocket` and `name`:

![Figure 16.12 – Changing criSocket parameter](images/figure-16-12-cri-socket.png)

3. Update `kubernetesVersion`:

![Figure 16.13 – Changing kubernetesVersion](images/figure-16-13-kubernetes-version.png)

**Check Kubernetes version:**
```bash
kubeadm version
```

![Figure 16.14 – Retrieving Kubernetes version](images/figure-16-14-kubeadm-version.png)

**Add kubelet configuration:**
```bash
cat <<EOF | cat >> k8s-config.yaml
---
apiVersion: kubelet.config.k8s.io/v1beta1
kind: KubeletConfiguration
cgroupDriver: systemd
EOF
```

**Bootstrap the cluster:**
```bash
sudo kubeadm init --config=k8s-config.yaml
```

![Figure 16.15 – Successfully bootstrapping Kubernetes cluster](images/figure-16-15-cluster-bootstrap.png)

**Configure kubectl for current user:**
```bash
mkdir -p ~/.kube
sudo cp -i /etc/kubernetes/admin.conf ~/.kube/config
sudo chown $(id -u):$(id -g) ~/.kube/config
```

**Deploy Calico networking:**
```bash
kubectl apply -f calico.yaml
```

**Verify cluster status:**
```bash
# Get all pods
kubectl get pods --all-namespaces
```

![Figure 16.16 – Retrieving pods in cluster](images/figure-16-16-get-pods.png)

```bash
# Get nodes
kubectl get nodes
```

![Figure 16.17 – Listing current nodes](images/figure-16-17-get-nodes.png)

**Check kubelet status:**
```bash
sudo systemctl status kubelet
```

![Figure 16.18 – Healthy kubelet in cluster](images/figure-16-18-kubelet-healthy.png)

**Explore cluster files:**
```bash
# Static pod manifests
ls /etc/kubernetes/manifests/
```

![Figure 16.19 – Static pod configuration files](images/figure-16-19-manifests.png)

```bash
# Kubeconfig files
ls /etc/kubernetes/
```

### Joining Nodes to Cluster

**Get bootstrap token (from CP node):**
```bash
kubeadm token list
```

![Figure 16.20 – Getting bootstrap tokens](images/figure-16-20-token-list.png)

**Get CA certificate hash:**
```bash
openssl x509 -pubkey \
    -in /etc/kubernetes/pki/ca.crt | \
    openssl rsa -pubin -outform der 2>/dev/null | \
    openssl dgst -sha256 -hex | sed 's/^.* //'
```

![Figure 16.21 – Getting CA certificate hash](images/figure-16-21-ca-hash.png)

**Alternative - Generate join command:**
```bash
kubeadm token create --print-join-command
```

**Join worker node:**
```bash
sudo kubeadm join 192.168.122.104:6443 \
    --token abcdef.0123456789abcdef \
    --discovery-token-ca-cert-hash sha256:af8e659bc8a9069cf58d3100e94644bb6ee804c1372a0ab7e74801cf8340a15d
```

**Verify node addition:**
```bash
kubectl get nodes
```

![Figure 16.22 – New node added to cluster](images/figure-16-22-node-added.png)

**Final cluster with all nodes:**

![Figure 16.23 – Kubernetes cluster with all nodes running](images/figure-16-23-all-nodes.png)

## Working with Kubernetes

### Using kubectl

kubectl is the primary tool for managing Kubernetes clusters.

**General syntax:**
```bash
kubectl [command] [TYPE] [NAME] [flags]
```

![Figure 16.24 – General usage pattern of kubectl](images/figure-16-24-kubectl-pattern.png)

#### Common kubectl Commands

- `create`, `apply`: Create resources
- `get`: Read resources  
- `edit`, `set`: Update resources
- `delete`: Delete resources
- `run`: Start a pod
- `exec`: Execute command in pod
- `describe`: Show detailed information
- `explain`: Provide documentation
- `logs`: Show container logs

#### Common Parameters
- `--dry-run`: Run without changing system state
- `--output`: Specify output format (yaml, json, wide)

### Connecting from Local Machine

**Install kubectl locally:**
```bash
# Download latest release
curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"

# Install kubectl
sudo install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl

# Test installation
kubectl version --client
```

![Figure 16.25 – Installing kubectl locally](images/figure-16-25-kubectl-install.png)

**Copy kubeconfig:**
```bash
# Copy from CP node
scp packt@192.168.122.104:~/.kube/config /tmp/config.cp
mv /tmp/config.cp ~/.kube/config
```

**Configure context:**
```bash
# View contexts
kubectl config get-contexts
```

![Figure 16.26 – New kubeconfig contexts](images/figure-16-26-contexts.png)

```bash
# Rename and set context
kubectl config rename-context kubernetes-admin@kubernetes k8s-local
kubectl config use-context k8s-local
```

![Figure 16.27 – Current context set](images/figure-16-27-current-context.png)

### Working with kubectl Commands

**Cluster information:**
```bash
kubectl cluster-info
```

![Figure 16.28 – Kubernetes cluster information](images/figure-16-28-cluster-info.png)

**Detailed node information:**
```bash
kubectl get nodes --output=wide
```

![Figure 16.29 – Detailed node information](images/figure-16-29-nodes-wide.png)

**Get pods:**
```bash
# Default namespace
kubectl get pods

# All namespaces
kubectl get pods --all-namespaces
```

![Figure 16.30 – Getting all pods in system](images/figure-16-30-all-pods.png)

**Get all resources:**
```bash
kubectl get all --all-namespaces
```

**API resources:**
```bash
kubectl api-resources
```

![Figure 16.31 – Getting all API object types](images/figure-16-31-api-resources.png)

**Explain resources:**
```bash
kubectl explain nodes
```

![Figure 16.32 – Showing nodes detailed information](images/figure-16-32-explain-nodes.png)

```bash
kubectl explain nodes.apiVersion
```

![Figure 16.33 – Details about apiVersion field](images/figure-16-33-api-version.png)

**Describe resources:**
```bash
kubectl describe nodes
kubectl describe nodes k8s-n1
```

#### Enabling kubectl Autocompletion

```bash
# Install bash-completion if needed
sudo apt-get install -y bash-completion

# Enable autocompletion
echo "source <(kubectl completion bash)" >> ~/.bashrc
source ~/.bashrc
```

**Using autocompletion:**
```bash
kubectl create [Tab][Tab]
```

![Figure 16.34 – Autocompletion use with kubectl](images/figure-16-34-autocompletion.png)

## Deploying Applications

### Imperative Deployments

#### Creating a Deployment

```bash
# Create deployment
kubectl create deployment packt --image=nginxdemos/hello

# Create standalone pod
kubectl run packt-web --image=nginxdemos/hello
```

**View pods:**
```bash
kubectl get pods -o wide
```

![Figure 16.35 – Getting application pods with detailed information](images/figure-16-35-app-pods.png)

**Describe pods:**
```bash
kubectl describe pod packt-579bb9c999-rtvzr
```

![Figure 16.36 – Pod information](images/figure-16-36-pod-info.png)

```bash
kubectl describe pod packt-web
```

![Figure 16.37 – Relevant pod information](images/figure-16-37-pod-info-web.png)

**Check containers on node:**
```bash
sudo crictl --runtime-endpoint unix:///run/containerd/containerd.sock ps
```

![Figure 16.38 – Getting containers running on cluster node](images/figure-16-38-containers-node.png)

#### Accessing Processes in Pods

```bash
# Access shell in container
kubectl exec -it packt-web -- /bin/sh

# Inside container - check processes
ps aux

# Get IP address
ifconfig | grep 'inet addr:' | cut -d: -f2 | awk '{print $1}' | grep -v '127.0.0.1'

# Get hostname
hostname

# Exit container
exit
```

![Figure 16.39 – Processes running inside container](images/figure-16-39-processes-container.png)

**Test application:**
```bash
# Get pod IP
kubectl get pods packt-web -o jsonpath='{.status.podIP}{"\n"}'

# Run test pod
kubectl run test --image=curlimages/curl sleep 600
```

![Figure 16.40 – Testing application pod](images/figure-16-40-test-pod.png)

![Figure 16.41 – Running test with curl](images/figure-16-41-curl-test.png)

```bash
# Test application
kubectl exec test -- curl http://172.16.57.193
```

![Figure 16.42 – Response of running curl test](images/figure-16-42-curl-response.png)

**View logs:**
```bash
kubectl logs packt-web
```

![Figure 16.43 – Logs for packt-web pod](images/figure-16-43-logs.png)

```bash
# Check nginx log symlinks
kubectl exec packt-web -- ls -la /var/log/nginx
```

![Figure 16.44 – Related symlinks](images/figure-16-44-symlinks.png)

#### Exposing Deployments as Services

```bash
# Get deployment resources
kubectl get deployments -l app=packt
kubectl get replicasets -l app=packt  
kubectl get pods -l app=packt

# Expose deployment
kubectl expose deployment packt \
    --port=80 \
    --target-port=80 \
    --type=NodePort
```

**View service:**
```bash
kubectl get service packt
```

![Figure 16.45 – Service exposing packt deployment](images/figure-16-45-service.png)

**Get node IPs:**
```bash
kubectl get nodes -o jsonpath='{range .items[*]}{.status.addresses[*].address}{"\n"}'
```

![Figure 16.46 – List of cluster nodes](images/figure-16-46-node-list.png)

**Access application in browser:**
URL: `http://192.168.122.104:32664`

![Figure 16.47 – Accessing packt application service](images/figure-16-47-access-app.png)

**Verify pod information:**
```bash
kubectl get pod packt-579bb9c999-rtvzr -o jsonpath='{.status.podIP}{"\n"}{.metadata.name}{"\n"}'
```

![Figure 16.48 – Verify information with kubectl](images/figure-16-48-verify-info.png)

#### Scaling Application Deployments

```bash
# Check current replicas
kubectl describe deployment packt
```

![Figure 16.49 – Pod details](images/figure-16-49-pod-details.png)

```bash
# Scale up to 10 replicas
kubectl scale deployment packt --replicas=10

# View scaled pods
kubectl get pods -l app=packt
```

![Figure 16.50 – Scaling up deployment replicas](images/figure-16-50-scale-up.png)

**Test load balancing with Lynx:**
```bash
# Install lynx
sudo apt-get install -y lynx

# Access application
lynx 172.16.191.6:32081
# Refresh with Ctrl+R to see different pods
```

![Figure 16.51 – Load balancing requests across pods](images/figure-16-51-load-balance.png)

```bash
# Scale back to 3 replicas
kubectl scale deployment packt --replicas=3
kubectl get pods -l app=packt
```

![Figure 16.52 – Scaling back to three pods](images/figure-16-52-scale-back.png)

**Clean up resources:**
```bash
kubectl delete service packt
kubectl delete deployment packt
kubectl delete pod packt-web
kubectl get all
```

![Figure 16.53 – Cluster in default state](images/figure-16-53-clean-state.png)

### Declarative Deployments

#### Creating a Manifest

```bash
# Generate manifest without applying
kubectl create deployment packt --image=nginxdemos/hello \
    --dry-run=client --output=yaml
```

![Figure 16.54 – Simulating manifest creation](images/figure-16-54-manifest-simulation.png)

```bash
# Save to file
kubectl create deployment packt --image=nginxdemos/hello \
    --dry-run=client --output=yaml > packt.yaml
```

#### Validating a Manifest

```bash
# Validate manifest
kubectl apply -f packt.yaml --dry-run=client
```

#### Deploying a Manifest

```bash
# Deploy manifest
kubectl apply -f packt.yaml

# Check resources
kubectl get all -l app=packt
```

![Figure 16.55 – Deployment resources created declaratively](images/figure-16-55-declarative-deploy.png)

#### Exposing with Service Manifest

```bash
# Create service manifest
kubectl expose deployment packt \
    --port=80 \
    --target-port=80 \
    --type=NodePort \
    --dry-run=client --output=yaml > packt-svc.yaml

# Validate and deploy
kubectl apply -f packt-svc.yaml --dry-run=client
kubectl apply -f packt-svc.yaml

# Check resources
kubectl get all -l app=packt
```

![Figure 16.56 – Packt application resources deployed](images/figure-16-56-app-resources.png)

**Access application:**
URL: `http://192.168.122.104:31380`

![Figure 16.57 – Accessing packt application endpoint](images/figure-16-57-app-endpoint.png)

#### Updating a Manifest

**Edit packt.yaml:**
```yaml
spec:
  replicas: 10  # Change from 1 to 10
```

```bash
# Redeploy updated manifest
kubectl apply -f packt.yaml

# View updated resources
kubectl get all -l app=packt
```

![Figure 16.58 – Additional pods added for scale-out](images/figure-16-58-scale-out.png)

**Edit deployment on the fly:**
```bash
kubectl edit deployment packt
```

![Figure 16.59 – Making deployment changes on the fly](images/figure-16-59-edit-deployment.png)

```bash
# Verify changes
kubectl get deployment packt
```

![Figure 16.60 – Showing number of deployments](images/figure-16-60-deployment-count.png)

## Summary

This chapter covered:

1. **Kubernetes Architecture**: Understanding pods, controllers, services, and storage
2. **Cluster Installation**: Building on-premises cluster with kubeadm
3. **kubectl Usage**: Managing resources with command-line interface
4. **Application Deployment**: Both imperative and declarative approaches
5. **Scaling and Management**: Handling application lifecycle

### Key Takeaways

- **Declarative vs Imperative**: Choose appropriate deployment model
- **Pod Management**: Understanding ephemeral nature and lifecycle
- **Service Exposure**: Making applications accessible
- **Scaling Strategies**: Horizontal scaling with ReplicaSets
- **Cluster Administration**: Using kubectl effectively

### Next Steps

- Explore advanced networking and security
- Learn about persistent storage
- Investigate monitoring and logging
- Study CI/CD integration
- Consider managed Kubernetes services

## Questions for Review

1. What are the essential services of a Kubernetes CP node?
2. What command bootstraps a Kubernetes cluster?
3. What's the difference between imperative and declarative deployments?
4. How do you access a shell within a pod container?
5. What command queries all resources related to a deployment?
6. How do you scale out a deployment in different ways?
7. How do you delete all resources related to a deployment?

## Further Reading

- [Kubernetes Documentation](https://kubernetes.io/docs/home/)
- [kubectl Cheat Sheet](https://kubernetes.io/docs/reference/kubectl/cheatsheet/)
- Cloud Provider Kubernetes Services:
  - [Amazon EKS](https://docs.aws.amazon.com/eks/index.html)
  - [Azure AKS](https://azure.microsoft.com/en-us/services/kubernetes-service/)
  - [Google GKE](https://cloud.google.com/kubernetes-engine)