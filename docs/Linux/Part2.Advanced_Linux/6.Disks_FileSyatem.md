# Chapter 6: Working with Disks and Filesystems

## Table of Contents
- [Understanding Devices in Linux](#understanding-devices-in-linux)
- [Understanding Filesystem Types](#understanding-filesystem-types-in-linux)  
- [Understanding Disks and Partitions](#understanding-disks-and-partitions)
- [Introducing LVM in Linux](#introducing-lvm-in-linux)

---

## Understanding Devices in Linux

### Key Concept: Everything in Linux is a File
Device files are special files in Unix and Linux operating systems that serve as interfaces to device drivers, appearing in the filesystem as regular files.

### Linux Abstraction Layers

Linux systems are organized into two main layers:

#### Hardware Level
- **Memory (RAM)**: System memory for temporary storage
- **CPU**: Central processing unit
- **Devices**: Disks, network interfaces, ports, controllers

#### Software Level
Contains two regions in memory:

1. **Kernel Space**
   - The kernel is the beating heart of Linux OS
   - Manages all hardware components
   - Interface between software and hardware
   - Manages processes, system calls, memory, and devices

2. **User Space**
   - Where user processes are executed
   - Managed by the kernel to prevent process interference
   - Accessed through system calls when kernel services are needed

![Linux abstraction layers diagram would be here - Figure showing hardware level, kernel space, and user space]

### Device Files and Naming Conventions

#### Device Management with udev
- **udev**: Device manager for the kernel running as a daemon (`udevd`)
- **Configuration**: `/etc/udev/udev.conf`
- **Rules location**: `/etc/udev/rules.d/`
- Works with device nodes (special files) as interfaces to drivers

#### Device Types in `/dev` Directory

```bash
ls -la /dev
```

Device files start with different letters indicating their type:
- **b**: Block devices (fixed size, can be indexed)
- **c**: Character devices (accessed via data streams, no fixed size)
- **p**: Named pipes
- **s**: Sockets

![Screenshot showing device files in /dev directory - Figure 6.2]

### Device Naming Conventions

#### Hard Drives and External Drives

1. **Classic IDE (ATA) drives**:
   - `hda`: Master device on first channel
   - `hdb`: Slave device on first channel  
   - `hdc`: Master device on second channel
   - `hdd`: Slave device on second channel

2. **NVMe drivers**:
   - `nvme0`: First device controller (character device)
   - `nvme0n1`: First namespace (block device)
   - `nvme0n1p1`: First namespace, first partition

3. **MMC drivers**:
   - `mmcblk0`: First SD card device
   - `mmcblk0p1`: First device, first partition

4. **SCSI drivers (modern SATA/USB)**:
   - `sda`, `sdb`, `sdc`: First, second, third registered devices
   - `sg`: Generic SCSI layers (character device)

![Screenshot showing disk drives in /dev directory - Figure 6.3]

---

## Understanding Filesystem Types in Linux

### Major Linux Filesystems

#### Extended Filesystems (Ext2, Ext3, Ext4)
- **Ext4**: Latest iteration, most widely used
- **Features**:
  - 48-bit addressing (vs 32-bit in Ext3)
  - Supports files up to 16 TB
  - Unlimited subdirectories (vs 32k in Ext3)
  - Extended timestamps (up to year 2446 AD)
  - Online defragmentation at kernel level
  - Maximum filesystem size: 1 exabyte (EB)

#### XFS Filesystem
- Created by Silicon Graphics for IRIX
- **Key features**:
  - High performance with large datasets
  - Parallel I/O capability
  - Supports up to 16 EB filesystems
  - Individual files up to 8 EB
  - Journaled quota information
  - Online maintenance (defrag, enlarge, restore)
  - Specific tools: `xfsdump`, `xfsrestore`

#### ZFS Filesystem
- Created by Sun Microsystems
- **Features**:
  - 128-bit system
  - Combines filesystem and logical volume manager
  - Copy-on-write mechanism
  - Data integrity and scalability focus
  - Simple administration

#### Btrfs (B-tree filesystem)
- **Modern features**:
  - Snapshots capability
  - Pooling support
  - Built-in checksums
  - Multi-device spanning
- **Status**: Still under development, used in SUSE/openSUSE

### Virtual File System (VFS)

The VFS acts as an abstraction layer between the kernel and different filesystem types:

![Linux Virtual File System abstraction layer diagram - Figure 6.5]

**Functions provided by VFS**:
- Namespace provisioning
- Metadata structures for hierarchical directories
- Disk block usage management
- File size and access information
- API for filesystem object manipulation

### Check Supported Filesystems
```bash
cat /proc/filesystems
```

---

## Understanding Disks and Partitions

### Common Disk Types

#### Disk Types by Technology
1. **HDD (Hard Disk Drive)**: Traditional spinning disks
2. **SSD (Solid State Drive)**: Flash memory-based
3. **NVMe**: Non-volatile memory express, fastest performance

#### Interface Types
- **IDE**: Old standard, now deprecated
- **SATA**: Serial ATA, up to 16 GB/s transfer rates
- **SCSI**: Used in enterprise servers with RAID
- **SAS**: Serial Attached SCSI, enterprise reliability
- **USB**: External drives and memory devices

### Disk Information Commands

#### View Disk Information
```bash
sudo fdisk -l
```

![Output of fdisk -l command showing disk information - Figure 6.6]

The output shows:
- **Disk model**: Drive name and specifications
- **Units**: Sector size (typically 512 bytes)  
- **Disklabel type**: GPT or MBR
- **Disk identifier**: Unique identifier
- **Partition table**: Device, start/end sectors, size, type

#### List Block Devices
```bash
lsblk
```

![Output of lsblk command - Figure 6.7]

Shows: device name, major/minor numbers, removable status, size, read-only status, device type, mount point

### Partition Types

#### Master Boot Record (MBR)
- **Limitations**:
  - Maximum 4 primary partitions
  - Maximum partition size: 2 TB
  - Uses hexadecimal codes for partition types
- **Structure**: First 512 bytes of drive
  - First 446 bytes: Bootloader code
  - Next 64 bytes: Partition table
  - Last 2 bytes: End of sector marker

#### GPT (GUID Partition Table)
- **Advantages**:
  - Up to 128 partitions
  - Disk sizes up to 75.6 Zettabytes
  - Part of UEFI standard
  - Multiple copies of partition table

### Partition Management

#### Partition Naming Convention
- First hard drive: `/dev/sda`
- Second hard drive: `/dev/sdb`
- First partition of first disk: `/dev/sda1`
- Second partition of first disk: `/dev/sda2`

#### Check Current Partitions
```bash
cat /proc/partitions
```

![Listing /proc/partitions file - Figure 6.8]

### Partition Table Editors

#### fdisk - Command Line Editor
```bash
sudo fdisk /dev/sda
```

![Using fdisk for the first time - Figure 6.9]

**Important fdisk commands**:
- `m`: Help menu
- `p`: Print partition table  
- `n`: New partition
- `d`: Delete partition
- `w`: Write changes to disk
- `q`: Quit without saving

### Creating and Formatting Partitions

#### Step-by-Step Partition Creation

1. **Create new MBR partition table**:
   ```bash
   sudo fdisk /dev/sda
   ```
   - Use `o` to create empty MBR table
   - Use `w` to write changes

![Creating new MBR partition table - Figure 6.10]

2. **Create new partition**:
   - `n`: New partition
   - `p`: Primary partition
   - Accept defaults or specify size
   - `w`: Write changes

![Creating new partition with fdisk - Figure 6.11]

#### Backup Partition Table
```bash
sudo dd if=/dev/sda of=mbr-backup bs=512 count=1
```

![Backing up MBR with dd command - Figure 6.12]

#### Restore Partition Table
```bash
sudo dd if=~/mbr-backup of=/dev/sda bs=512 count=1
```

### Formatting Partitions

#### Using mkfs (Make Filesystem)
```bash
sudo mkfs.ext4 /dev/sda1
```

![Formatting Ext4 partition using mkfs - Figure 6.14]

**mkfs options**:
- `-t`: Specify filesystem type
- `-v`: Verbose output
- `-c`: Bad sector scanning
- `-L`: Add partition label

#### Available Filesystems
```bash
ls /sbin/mkfs*
```

![Details regarding mkfs utility - Figure 6.13]

### Checking Filesystems

#### Using fsck (File System Check)
```bash
sudo fsck /dev/sda1
```

![Using fsck to check partition - Figure 6.15]

**fsck features**:
- Runs automatically after abnormal shutdown
- Checks for filesystem errors
- Can repair minor issues
- Available for different filesystem types

### Mounting and Unmounting Partitions

#### Mounting Process

1. **Create mount point**:
   ```bash
   mkdir /mnt/usb
   ```

2. **Mount partition**:
   ```bash
   sudo mount /dev/sda1 /mnt/usb
   ```

3. **Verify mount**:
   ```bash
   mount | grep /dev/sda1
   ```

![Mounting external memory stick - Figure 6.16]

#### Common Mount Error
![Error for not using sudo with mount - Figure 6.17]

#### Unmounting
```bash
sudo umount /dev/sda1
```

**Troubleshooting busy filesystem**:
```bash
sudo lsof | grep /dev/sda1
```

### Persistent Mounting with /etc/fstab

#### Edit fstab file
```bash
sudo nano /etc/fstab
```

#### Add entry
```
/dev/sda1 /mnt/usb ext4 defaults 0 0
```

**fstab columns**:
1. **Device name**: UUID or device path
2. **Mount point**: Directory location
3. **Filesystem type**: ext4, xfs, etc.
4. **Options**: mount options (defaults)
5. **Backup operation**: 0=no backup, 1=dump backup
6. **Check order**: 0=no check, 1=root, 2=others

### Swap Partition

#### Check Current Swap
```bash
cat /proc/swaps
free -h
```

![Checking currently used swap - Figure 6.18]

#### Create and Enable Swap
```bash
sudo mkswap /dev/sda1
sudo swapon /dev/sda1
```

**Swap recommendations**:
- Size: At least equal to total RAM
- Multiple swap areas supported
- Only user space memory is swapped (not kernel)

---

## Introducing LVM in Linux

### What is LVM?
**Logical Volume Manager** provides flexibility for disk management:
- Add physical disks to volume groups while in use
- No downtime for disk operations
- Move data between drives online
- Dynamic resizing of logical volumes

### LVM Components
1. **Physical Volume (PV)**: Physical disk or partition
2. **Volume Group (VG)**: Collection of physical volumes  
3. **Logical Volume (LV)**: Virtual partition in volume group

### LVM Commands Overview
- `pvcreate`: Create physical volume
- `vgcreate`: Create volume group
- `vgdisplay`: Display volume group info
- `lvcreate`: Create logical volume
- `lvextend`: Extend logical volume
- `lvdisplay`: Display logical volume info

### Creating LVM Volumes

#### Step 1: Create Physical Volume
```bash
sudo fdisk -l  # Check available disks
sudo pvcreate /dev/sda
```

![Using pvcreate to create LVM physical volume - Figure 6.19]

#### Step 2: Create Volume Group
```bash
sudo vgcreate newvolume /dev/sda
sudo vgdisplay newvolume
```

![Creating and viewing details of new volume - Figure 6.20]

#### Step 3: Create Logical Volume
```bash
sudo lvcreate -n projects -L 5G newvolume
```

![Creating logical volume using lvcreate - Figure 6.21]

#### Step 4: Format Logical Volume
```bash
sudo mkfs.ext4 /dev/mapper/newvolume-projects
```

![Formatting new logical volume as Ext4 - Figure 6.22]

#### Step 5: Mount Logical Volume
```bash
mkdir ~/LVM
sudo mount /dev/mapper/newvolume-projects ~/LVM
df -h ~/LVM
```

![Mounting the logical volume - Figure 6.23]

### Extending Logical Volumes

#### Check Available Space
```bash
sudo vgdisplay newvolume
```

#### Extend Logical Volume
```bash
sudo lvextend -L +5G /dev/mapper/newvolume-projects
```

![Extending logical volume using lvextend - Figure 6.24]

#### Resize Filesystem
```bash
sudo resize2fs /dev/mapper/newvolume-projects
df -h ~/LVM
```

![Resizing logical volume with resize2fs - Figure 6.25]

### Persistent LVM Mounting
Add to `/etc/fstab`:
```
/dev/mapper/newvolume-projects /home/user/LVM ext4 defaults 1 2
```

---

## LVM Snapshots

### What are LVM Snapshots?
- **Frozen instance** of LVM logical volume
- **Copy-on-write technology**: Only changed blocks copied to snapshot
- **Instant creation**: Available immediately
- **Size consideration**: Plan for amount of data that will change

### Creating Snapshots

```bash
sudo lvcreate -s -n linux-snapshot-01 -L 5G /dev/newvolume/projects
```

![Creating LVM snapshot with lvcreate - Figure 6.26]

**Command breakdown**:
- `-s`: Create snapshot
- `-n`: Name for snapshot  
- `-L`: Size of snapshot
- Last argument: Source volume

#### List Snapshots
```bash
sudo lvs
```

![Listing available volume and newly created snapshot - Figure 6.27]

### Extending Snapshots
```bash
sudo lvextend -L 10G /dev/newvolume/linux--snapshot--01
```

![Extending snapshot from 5 to 10 GB - Figure 6.28]

**Note**: Snapshot naming convention uses double dashes in `/dev/mapper/` paths

### Restoring Snapshots

#### Unmount Filesystem
```bash
sudo umount /home/user/LVM
```

#### Restore Snapshot
```bash
sudo lvconvert --merge /dev/newvolume/linux-snapshot-01
sudo lvs  # Verify merge completion
```

![Restoring and checking snapshot - Figure 6.29]

**Important**: Snapshot is automatically removed after merge

---

## Key Commands Summary

### Device Management
```bash
ls -la /dev                    # List device files
cat /etc/udev/udev.conf       # View udev configuration
lsblk                         # List block devices
```

### Disk Information
```bash
sudo fdisk -l                 # List all disks and partitions
cat /proc/partitions          # Show known partitions
cat /proc/filesystems         # Show supported filesystems
```

### Partitioning
```bash
sudo fdisk /dev/sda           # Interactive partition editor
sudo dd if=/dev/sda of=backup bs=512 count=1  # Backup MBR
```

### Formatting and Mounting
```bash
sudo mkfs.ext4 /dev/sda1      # Format as ext4
sudo fsck /dev/sda1           # Check filesystem
sudo mount /dev/sda1 /mnt     # Mount partition
sudo umount /dev/sda1         # Unmount partition
```

### LVM Operations
```bash
sudo pvcreate /dev/sda        # Create physical volume
sudo vgcreate vgname /dev/sda # Create volume group
sudo lvcreate -n name -L size vgname  # Create logical volume
sudo lvextend -L +size /dev/mapper/vg-lv  # Extend volume
sudo resize2fs /dev/mapper/vg-lv      # Resize filesystem
```

### Swap Management
```bash
sudo mkswap /dev/sda1         # Create swap partition
sudo swapon /dev/sda1         # Enable swap
cat /proc/swaps               # Show active swap
free -h                       # Show memory and swap usage
```

---

## Best Practices

### Safety Guidelines
1. **Always backup** partition tables before making changes
2. **Use `sudo`** for all disk operations
3. **Verify device names** carefully before operations
4. **Test filesystems** with `fsck` after creation
5. **Plan swap size** as at least equal to RAM

### LVM Advantages
- **Flexibility**: Add/remove disks without downtime
- **Snapshots**: Point-in-time backups
- **Online resizing**: Grow filesystems while mounted
- **Better utilization**: Pool storage across multiple devices

### LVM Considerations
- **Added complexity**: More components can fail
- **Recovery challenges**: More complex disaster recovery
- **Performance**: Small overhead compared to direct partitions
- **Learning curve**: Requires understanding of PV/VG/LV concepts

---

## Troubleshooting Common Issues

### Mount Problems
- **Permission denied**: Use `sudo` with mount command
- **Device busy**: Check with `lsof` for open files
- **Invalid filesystem**: Verify with `fsck`

### LVM Issues
- **Physical volume exists**: Use `wipefs` to clean signatures
- **Snapshot full**: Monitor snapshot usage and extend if needed
- **Cannot extend**: Check volume group free space with `vgdisplay`

### Partition Table Problems
- **Corrupted MBR**: Restore from backup with `dd`
- **Partition not recognized**: Re-read partition table with `partprobe`
- **Size mismatch**: Use `resize2fs` after extending partitions