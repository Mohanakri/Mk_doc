# Linux Shell Scripting

## Introduction

Linux shell programming and command-line interface (CLI) knowledge is essential for modern Linux professionals. This chapter covers shell programming capabilities for automating tasks, script structure, and specialized tools like `sed` and `gawk`.

## Topics Covered

- Shell features and programming structures
- Script creation and execution
- Variables, arrays, and functions
- Decision making and loops
- Advanced tools: sed and (g)awk
- Interprocess communication
- Administrative task automation

---

## Exploring the Linux Shell

### POSIX Standards

The shell is based on **POSIX (Portable Operating System Interface)** standards created by IEEE to ensure compatibility between operating systems. POSIX-compliant systems include:

- UNIX and Linux
- macOS (Darwin-based)
- AIX, HP-UX, Oracle Solaris

---

## Bash Shell Features

### Wildcards and Metacharacters

#### Wildcards
- **Asterisk (`*`)**: Matches any string of none or more characters
- **Question mark (`?`)**: Matches a single character  
- **Brackets (`[ ]`)**: Matches any character inside brackets

#### Metacharacters

![Metacharacter list](images/figure-8-1-metacharacter-list.png)

*Figure 8.1 – Metacharacter list*

#### Command Substitution Examples

![Example of command execution and substitution](images/figure-8-2-command-substitution.png)

*Figure 8.2 – Example of command execution and substitution*

**Command Substitution Methods:**
```bash
# Method 1: Using backticks
echo "Today is `date`"

# Method 2: Using $() syntax  
echo "Today is $(date)"
```

#### Command Piping
```bash
# Pipe ls output to less for pagination
ls -l /etc | less
```

#### Command Sequencing and Grouping

![Example of command sequence execution](images/figure-8-3-command-sequence.png)

*Figure 8.3 – Example of command sequence execution*

```bash
# Sequential execution
who; pwd

# Grouped execution with output redirection
(who; pwd) > user_info.txt
```

### Brace Expansion

![Examples of using brace expansion](images/figure-8-4-brace-expansion.png)

*Figure 8.4 – Examples of using brace expansion*

**Common Brace Expansion Uses:**
```bash
# Delete multiple files
rm {report,new-report}

# Create multiple files
touch file{1..5}

# Delete range of files
rm file{1..5}
```

### Shell Aliases

![Changing the alias of a command](images/figure-8-5-alias-change.png)

*Figure 8.5 – Changing the alias of a command*

**Creating Aliases:**
```bash
# Temporary alias
alias ll='ls -la'

# Permanent aliases - add to ~/.bashrc or ~/.bash_aliases
echo "alias ll='ls -la'" >> ~/.bashrc
source ~/.bashrc
```

!!! note "Important"
    The `.bashrc` file contains Terminal session configurations and is executed when users log in. Use `source .bashrc` to manually execute it.

---

## Bash Shell Variables

### Types of Variables
- **Global variables**: Available system-wide
- **Local variables**: Available only in current shell/function

### Built-in Shell Variables

![Variable calling from the shell](images/figure-8-6-variable-calling.png)

*Figure 8.6 – Variable calling from the shell*

**Common Built-in Variables:**
- `HOME`: User's home directory
- `LOGNAME`: User's login name
- `PWD`: Current working directory
- `OLDPWD`: Previous working directory
- `PATH`: Shell's search path
- `SHELL`: Path to the shell
- `USER`: User's login name
- `TERM`: Terminal type

**Using Variables:**
```bash
# Create user-defined variable
MYVAR=sysadmin
echo $MYVAR

# View all environment variables
printenv > ~/shell_variables
```

### The Shell's Search Path

![Adding a new location to PATH](images/figure-8-7-path-addition.png)

*Figure 8.7 – Adding a new location to PATH*

**Modifying PATH:**
```bash
# Temporary addition
export PATH=$PATH:/home/packt

# Permanent addition - edit ~/.bash_profile or ~/.bashrc
echo 'export PATH=$PATH:/home/packt' >> ~/.bashrc
```

---

## Basics of Shell Scripting

### What is a Script?
A script is a series of instructions executed by a computer to automate specific tasks. In shell scripting, these are sequences of commands executed together.

### Creating a Shell Script File

#### Script Structure
```bash
#!/bin/bash
# This is the shebang line
whoami
who  
date
uptime
```

The **shebang (`#!`)** tells the interpreter which shell to use.

### Running Scripts

![Error upon running the new script](images/figure-8-8-script-error.png)

*Figure 8.8 – Error upon running the new script*

**Making Scripts Executable:**
```bash
# Add execute permission
chmod u+x basic-script.sh

# Run the script
./basic-script.sh
```

![Running an executable script file](images/figure-8-9-executable-script.png)

*Figure 8.9 – Running an executable script file*

!!! tip "Best Practice"
    Use extensive comments in your scripts to document variables and parameters. This makes code more readable and maintainable.

---

## Variables in Shell Scripts

### Naming Conventions
- System environment variables use UPPERCASE letters
- User-defined variables should follow consistent naming:
  - Use lowercase letters, underscores, and numbers
  - Or capitalize first letter of each word
- Variable names are case-sensitive
- Keep names under 20 characters

### Using Environment Variables

![Using environment variables in a script](images/figure-8-10-environment-variables.png)

*Figure 8.10 – Using environment variables in a script*

### User-Defined Variables

![A basic script using user-defined variables](images/figure-8-11-user-variables.png)

*Figure 8.11 – A basic script using user-defined variables*

```bash
#!/bin/bash
value=25
product="Shirt"
echo "The value is $value"
echo "The product is $product"
```

---

## Mathematical Expressions in Shell Scripts

### Using the `expr` Command

![Using the expr command inside scripts](images/figure-8-12-expr-command.png)

*Figure 8.12 – Using the expr command inside scripts*

### Using Square Brackets

![Using square brackets for math operations](images/figure-8-13-square-brackets.png)

*Figure 8.13 – Using square brackets for math operations*

```bash
#!/bin/bash
price=100
vat=20
total=$((price + vat))
echo "Total: $total"
```

### Floating-Point Operations with `bc`

![Using the bc command for floating-point operations](images/figure-8-14-bc-command.png)

*Figure 8.14 – Using the bc command for floating-point operations*

```bash
#!/bin/bash
price=100
vat=20.5
decs=2
total=$(echo "scale=$decs; $price + $vat" | bc)
echo "Total: $total"
```

!!! note
    Bash only supports integer arithmetic by default. Use `bc` command for floating-point operations.

---

## Programming Structures

### Arrays in Bash

**Indexed Arrays:**
```bash
# Create indexed array
usernames=("paul" "janet" "mike" "john" "anna" "martha")

# Access elements (zero-indexed)
echo ${usernames[2]}  # Output: mike

# Print entire array
echo ${usernames[*]}
echo ${usernames[@]}

# Array size
echo ${#usernames[@]}

# Add elements
usernames+=("alex")
usernames[1]="zack"
```

**Associative Arrays:**
```bash
# Declare associative array
declare -A linux_distros=( [KDE]="openSUSE" [GNOME]="Fedora" [Xfce]="Debian" )

# Print values
echo ${linux_distros[@]}

# Print keys
echo ${!linux_distros[@]}
```

### Reading Input Data

![Using the read command for standard input](images/figure-8-15-read-command.png)

*Figure 8.15 – Using the read command for standard input*

![Using read with file redirection](images/figure-8-16-read-redirection.png)

*Figure 8.16 – Using read with file redirection*

```bash
# Read multiple variables
read a b c d
echo "First: $a, Second: $b"

# Read from file
read variable < filename
```

### Formatting Output Data

#### Using `printf` Command

![Basic usage of the printf command](images/figure-8-17-printf-basic.png)

*Figure 8.17 – Basic usage of the printf command*

**Escape Sequences:**
- `\b`: Backspace
- `\n`: New line
- `\r`: Carriage return
- `\t`: Horizontal tab

**Format Specifiers:**
- `%s`: String specifier
- `%d`: Integer specifier  
- `%f`: Floating-point specifier
- `%x`: Hexadecimal specifier

![Using printf inside a script](images/figure-8-18-printf-script.png)

*Figure 8.18 – Using printf inside a script*

![Using tab and newline escape sequences](images/figure-8-19-printf-formatting.png)

*Figure 8.19 – Using tab and newline escape sequences*

![Using complex specifiers and escape sequences for table formatting](images/figure-8-20-table-formatting.png)

*Figure 8.20 – Using complex specifiers and escape sequences for table formatting*

---

## Testing Structures and Exit Status

### Understanding Exit Status
- **Exit status** stored in `$?` parameter
- `0`: Successful execution
- `1-255`: Error codes (usually `1` for general errors)

### Testing Operators

**Integer Comparison:**
- `-eq`: Equal
- `-ne`: Not equal
- `-lt`: Less than
- `-le`: Less than or equal
- `-gt`: Greater than
- `-ge`: Greater than or equal

**String Comparison:**
- `=` or `==`: Equal
- `!=`: Not equal
- `\<` and `\>`: Less/greater (must be escaped)

**File Testing:**
- `-f`: Regular file
- `-d`: Directory
- `-h` or `-L`: Symbolic link
- `-e`: File exists

**Logical Operators:**
- `-a`: AND
- `-o`: OR
- `-z`: Check if string is empty

---

## Conditional Statements

### if-then-fi Structure

![Script to determine an even or odd number](images/figure-8-21-even-odd.png)

*Figure 8.21 – Script to determine an even or odd number*

```bash
if [ condition ]
then
    commands
fi
```

### if-then-else-fi Structure

![Checking if a filename that's been introduced is a file](images/figure-8-22-file-check.png)

*Figure 8.22 – Checking if a filename that's been introduced is a file*

![Running the file-checking script](images/figure-8-23-file-check-output.png)

*Figure 8.23 – Running the file-checking script*

```bash
if [ condition ]
then
    commands
else
    commands  
fi
```

---

## Looping Statements

### for Loop

![Iterating through an array using the for statement](images/figure-8-24-for-loop.png)

*Figure 8.24 – Iterating through an array using the for statement*

```bash
for var in list
do
    commands
done
```

#### Bubble Sort Example

![Using the bubble sort algorithm to sort an array](images/figure-8-25-bubble-sort.png)

*Figure 8.25 – Using the bubble sort algorithm to sort an array*

![Showing the input and output for our sorting script](images/figure-8-26-sort-output.png)

*Figure 8.26 – Showing the input and output for our sorting script*

### while Loop

![Using a while statement](images/figure-8-27-while-loop.png)

*Figure 8.27 – Using a while statement*

```bash
while [ condition ]
do
    commands
done
```

### until Loop

![An example of an until statement](images/figure-8-28-until-loop.png)

*Figure 8.28 – An example of an until statement*

```bash
until [ condition ]
do
    commands
done
```

### Loop Control

#### break Command

![Exiting a loop using the break command](images/figure-8-29-break-command.png)

*Figure 8.29 – Exiting a loop using the break command*

![Output of using the break script example](images/figure-8-30-break-output.png)

*Figure 8.30 – Output of using the break script example*

![Breaking loop optimized](images/figure-8-31-break-optimized.png)

*Figure 8.31 – Breaking loop optimized*

#### continue Command

![Using the continue command inside a loop](images/figure-8-32-continue-command.png)

*Figure 8.32 – Using the continue command inside a loop*

![The output when using the continue command](images/figure-8-33-continue-output.png)

*Figure 8.33 – The output when using the continue command*

---

## Working with Functions

### Function Syntax

```bash
# Method 1: Using function keyword
function name {
    commands
}

# Method 2: Using parentheses
name() {
    commands
}
```

### Basic Function Example

![Running our first function](images/figure-8-34-first-function.png)

*Figure 8.34 – Running our first function*

!!! warning "Important"
    Functions must be defined before they are called. Bash is a single-pass interpreter.

### Advanced Function Capabilities

#### Variables in Functions

![Showing how local and global variables work in functions](images/figure-8-35-function-variables.png)

*Figure 8.35 – Showing how local and global variables work in functions*

```bash
#!/bin/bash
var1='1'  # Global variable
var2='2'  # Global variable

var_function() {
    local var1='inside function'  # Local variable
    var2='modified global'        # Modifies global variable
    echo "Inside function: var1=$var1, var2=$var2"
}

var_function
echo "Outside function: var1=$var1, var2=$var2"
```

#### Arrays in Functions

![Using arrays inside functions](images/figure-8-36-function-arrays.png)

*Figure 8.36 – Using arrays inside functions*

![Output of using arrays in functions](images/figure-8-37-function-arrays-output.png)

*Figure 8.37 – Output of using arrays in functions*

---

## Using sed and (g)awk Commands

### sed (Stream Editor)

#### Basic sed Syntax
```bash
sed 's/regex/replacement/flag'
```

#### sed Examples

![Using the sed command to replace a string in a text file](images/figure-8-38-sed-replace.png)

*Figure 8.38 – Using the sed command to replace a string in a text file*

![Using sed to add spaces](images/figure-8-39-sed-spaces.png)

*Figure 8.39 – Using sed to add spaces*

![Using sed to show specific lines in a file](images/figure-8-40-sed-lines.png)

*Figure 8.40 – Using sed to show specific lines in a file*

![Using sed to show a specific number of lines in a text file](images/figure-8-41-sed-range.png)

*Figure 8.41 – Using sed to show a specific number of lines in a text file*

![Use of sed to show only lines with no comments](images/figure-8-42-sed-comments.png)

*Figure 8.42 – Use of sed to show only lines with no comments*

**Common sed Operations:**
```bash
# Replace text globally
sed 's/old/new/g' file

# Show specific line
sed -n '2p' file

# Show range of lines
sed -n '4,6p' file

# Delete comment lines
sed '/^#/d' file

# Add spaces at beginning of lines
sed 's/^/    /' file
```

### awk Command

#### Basic awk Syntax
```bash
awk '/search pattern/ {actions}' file
```

#### awk Example

![Using awk to generate a list of package names](images/figure-8-43-awk-packages.png)

*Figure 8.43 – Using awk to generate a list of package names*

```bash
# Extract package names (second column)
sudo dpkg -l | awk '{print $2}' > package-list
```

---

## Interprocess Communication (IPC)

### Shared Storage

#### Producer Script

![The producer script (using shared storage)](images/figure-8-44-producer-storage.png)

*Figure 8.44 – The producer script (using shared storage)*

#### Consumer Script

![The consumer script (using shared storage)](images/figure-8-45-consumer-storage.png)

*Figure 8.45 – The consumer script (using shared storage)*

#### Communication Example

![The producer (left) and consumer (right) communicating through shared storage](images/figure-8-46-storage-communication.png)

*Figure 8.46 – The producer (left) and consumer (right) communicating through shared storage*

### Unnamed Pipes

#### Scripts for Unnamed Pipes

![The producer2 (left) and consumer2 (right) scripts (using an unnamed pipe)](images/figure-8-47-unnamed-pipe-scripts.png)

*Figure 8.47 – The producer2 (left) and consumer2 (right) scripts (using an unnamed pipe)*

#### Pipe Communication

![The producer feeding data into a consumer through an unnamed pipe](images/figure-8-48-unnamed-pipe-communication.png)

*Figure 8.48 – The producer feeding data into a consumer through an unnamed pipe*

```bash
# Using unnamed pipe
producer.sh | consumer.sh
```

### Named Pipes (FIFOs)

#### Named Pipe Scripts

![The producer3 (left) and consumer3 (right) scripts (using named pipe)](images/figure-8-49-named-pipe-scripts.png)

*Figure 8.49 – The producer3 (left) and consumer3 (right) scripts (using named pipe)*

#### Named Pipe Communication

![producer3 (left) and consumer3 (right) communicating through a named pipe](images/figure-8-50-named-pipe-communication.png)

*Figure 8.50 – producer3 (left) and consumer3 (right) communicating through a named pipe*

```bash
# Create named pipe
mkfifo pipe.fifo

# Write to named pipe
echo "data" > pipe.fifo

# Read from named pipe  
cat < pipe.fifo
```

### Sockets

#### IPC Socket Scripts

![The producer4 (left) and consumer4 (right) scripts (using IPC sockets)](images/figure-8-51-socket-scripts.png)

*Figure 8.51 – The producer4 (left) and consumer4 (right) scripts (using IPC sockets)*

#### Socket Communication

![producer4 (left) and consumer4 (right) communicating through an IPC socket](images/figure-8-52-socket-communication.png)

*Figure 8.52 – producer4 (left) and consumer4 (right) communicating through an IPC socket*

**Socket Types:**
- **IPC sockets**: Unix domain sockets (local file-based)
- **Network sockets**: TCP/UDP sockets (network-based)

```bash
# Install netcat
sudo apt install netcat      # Ubuntu/Debian
sudo dnf install nmap        # Fedora/RHEL

# Server (listener)
nc -lU /var/tmp/ipc.sock

# Client (connector)  
nc -U /var/tmp/ipc.sock
```

---

## Administrative Task Scripting

### System Update Script

![A simple update script](images/figure-8-53-update-script.png)

*Figure 8.53 – A simple update script*

```bash
#!/bin/bash
echo "Starting system update..."
sudo dnf update -y
echo "System update completed!"
```

### Scheduling with cron

![Example of a cron job definition in /etc/crontab](images/figure-8-54-cron-example.png)

*Figure 8.54 – Example of a cron job definition in /etc/crontab*

**Cron Job Format:**
```
# ┌───────────── minute (0 - 59)
# │ ┌───────────── hour (0 - 23)
# │ │ ┌───────────── day of the month (1 - 31)
# │ │ │ ┌───────────── month (1 - 12)
# │ │ │ │ ┌───────────── day of the week (0 - 6) (Sunday to Saturday)
# │ │ │ │ │
# │ │ │ │ │
# * * * * * user-name command to be executed
```

**Schedule Script:**
```bash
# Edit crontab
crontab -e

# Run update script every Sunday at 23:00
00 23 * * 0 packt /home/packt/update_script.sh

# List cron jobs
crontab -l

# Redirect output to /dev/null
00 23 * * 0 packt /home/packt/update_script.sh > /dev/null 2>&1
```

### Backup Script

![A short backup script](images/figure-8-55-backup-script.png)

*Figure 8.55 – A short backup script*

```bash
#!/bin/bash
BACKUP_DIR="/mnt/backup"
SOURCE_DIR="/home/packt"
DATE=$(date +%Y%m%d_%H%M%S)
HOSTNAME=$(hostname)

# Create backup
tar -czf "${BACKUP_DIR}/backup_${HOSTNAME}_${DATE}.tgz" "$SOURCE_DIR"
echo "Backup completed: backup_${HOSTNAME}_${DATE}.tgz"
```

### Password Generator Script

![Password-generating script](images/figure-8-56-password-script.png)

*Figure 8.56 – Password-generating script*

![The output of running the password-generating script](images/figure-8-57-password-output.png)

*Figure 8.57 – The output of running the password-generating script*

```bash
#!/bin/bash
read -p "Enter password length: " length
read -p "Enter number of passwords: " count

for ((i=1; i<=count; i++)); do
    openssl rand -base64 32 | cut -c1-$length
done
```

---

## Packaging Scripts

### Creating RPM Packages

#### Directory Structure

![The rpmbuild's directory structure](images/figure-8-58-rpmbuild-structure.png)

*Figure 8.58 – The rpmbuild's directory structure*

#### SPEC File Configuration

![The SPEC file's entries](images/figure-8-59-spec-file.png)

*Figure 8.59 – The SPEC file's entries*

#### Building RPM Package

![The new RPM binary package](images/figure-8-60-rpm-package.png)

*Figure 8.60 – The new RPM binary package*

**RPM Build Process:**
```bash
# Install RPM development tools
sudo dnf install rpmdevtools

# Setup build environment
rpmdev-setuptree

# Create source tarball
tar -cvzf passgen-0.1.tar.gz passgen-0.1.sh LICENSE.txt

# Copy to SOURCES directory
cp passgen-0.1.tar.gz ~/rpmbuild/SOURCES/

# Create SPEC file
cd ~/rpmbuild/SPECS
rpmdev-newspec passgen

# Build binary RPM
rpmbuild -bb ~/rpmbuild/SPECS/passgen.spec

# Build source RPM  
rpmbuild -bs ~/rpmbuild/SPECS/passgen.spec

# Rebuild from source RPM
rpmbuild --rebuild package.src.rpm
```

---

## Summary

This chapter covered comprehensive Linux shell scripting concepts:

- **Shell Features**: Wildcards, metacharacters, brace expansion, aliases, and variables
- **Script Basics**: Creation, execution, and structure
- **Programming Constructs**: Variables, arrays, functions, conditionals, and loops
- **Advanced Tools**: sed and awk for text processing
- **IPC Mechanisms**: Shared storage, pipes, and sockets
- **Administrative Tasks**: System updates, backups, and password generation
- **Package Creation**: Building RPM packages from shell scripts

### Key Takeaways

1. **Always use comments** in scripts for documentation
2. **Test scripts thoroughly** before deployment
3. **Use appropriate variable naming** conventions
4. **Handle errors gracefully** with proper exit codes
5. **Schedule scripts** using cron for automation
6. **Package scripts** for easy distribution and installation

### Best Practices

- Make scripts executable with `chmod +x`
- Use full paths for commands in scheduled scripts
- Validate input and handle edge cases
- Use version control for script management
- Test scripts in development environments first
- Document script dependencies and requirements

---

## Questions for Practice

1. **Arrays in Bash**: What are arrays and how are they used? Can there be hybrid types?
2. **Infinite Loops**: What is an infinite loop and how do you escape from one?
3. **Loop Types**: How many types of loops can be used in Bash scripts?
4. **DEB Packages**: Research how to build DEB binary packages for Debian-based systems.

## Further Reading

- Linux Administration Best Practices by Scott Alan Miller
- Linux Command Line and Shell Scripting Techniques by Vedran Dakic
- Official Red Hat documentation on packaging and distributing software
- Fedora packaging guidelines for RPM macros
- Advanced Bash scripting guides and POSIX shell standards