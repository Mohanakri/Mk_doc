# Chapter 9: Securing Linux - Study Notes

## Overview

This chapter covers the essential aspects of securing a Linux system, focusing on **Access Control Mechanisms (ACMs)** and **firewall solutions**. The goal is to protect data from unwanted access while maintaining efficient system administration.

## Part 1: Access Control Mechanisms (ACMs)

### Types of Access Control Mechanisms

Linux kernel provides several ACMs for controlling how users and processes access system resources:

#### 1. Discretionary Access Control (DAC)
- **Definition**: Traditional filesystem access control
- **Scope**: Files, directories, and devices
- **Control**: At the discretion of the object's owner
- **Basis**: Identity of users and groups (subjects)

#### 2. Access Control Lists (ACLs)
- **Purpose**: Fine-grained control over filesystem objects
- **Function**: Specify which subjects can access specific objects

#### 3. Mandatory Access Control (MAC)
- **Enhancement**: Adds additional labels/categories to filesystem objects
- **Requirement**: Subjects must have appropriate access to categories
- **Implementation**: 
  - SELinux on RHEL/Fedora
  - AppArmor on Ubuntu/Debian/openSUSE

#### 4. Role-Based Access Control (RBAC)
- **Alternative**: To permission-based access control
- **Method**: System administrator assigns roles
- **Logic**: Subjects must be members of specific groups/roles

#### 5. Multi-Level Security (MLS)
- **Type**: Specific MAC scheme
- **Subjects**: Processes
- **Objects**: Files, sockets, system resources

#### 6. Multi-Category Security (MCS)
- **Evolution**: Improved version of SELinux
- **Feature**: Allows users to label files with categories
- **Base**: Reuses MLS framework

## Part 2: SELinux (Security-Enhanced Linux)

### Introduction to SELinux

![SELinux Status](Figure 9.1 – Getting the current status of SELinux)

**SELinux** is a security framework in the Linux kernel for managing access control policies, supporting MAC, RBAC, and MLS models.

#### Key Features:
- Introduced by NSA
- Released to open source in 2000
- Part of Linux kernel since 2.6 series (2003)
- Protects against misconfigurations and compromised processes

### SELinux Modes

SELinux operates in different modes:

#### 1. Enforcing Mode
- **Function**: Actively monitors and controls security policies
- **Default**: Enabled by default in RHEL/Fedora
- **Command**: `sudo setenforce 1`

#### 2. Permissive Mode
- **Function**: Monitors policies without enforcing
- **Logging**: Violations logged in `/var/log/messages`
- **Command**: `sudo setenforce 0`

#### 3. Disabled Mode
- **Function**: Neither monitors nor enforces policies
- **Configuration**: Edit `/etc/selinux/config`

```bash
# Check current status
sestatus

# Check current mode
getenforce

# Switch modes
sudo setenforce 0  # permissive
sudo setenforce 1  # enforcing
```

![SELinux Configuration](Figure 9.2 – Disabling SELinux)

### SELinux Contexts

SELinux contexts contain additional information for access control decisions.

#### Context Format
```
USER:ROLE:TYPE:LEVEL
```

![SELinux Context Example](Figure 9.3 – Displaying the SELinux context of a file)

#### Context Fields:

1. **SELinux User**: Identity authorized for specific roles and levels
2. **SELinux Role**: RBAC attributes acting as intermediary access layer
3. **SELinux Type**: Attribute of type enforcement (domains for processes, types for files)
4. **SELinux Level**: MLS/MCS attribute representing security clearance

### Working with SELinux Contexts

#### User Contexts
```bash
# Display current user's SELinux context
id -Z
```

![User Context](Figure 9.5 – Displaying the current user's SELinux context)

#### Process Contexts
```bash
# Display SELinux context for processes
ps -eZ | grep sshd
```

![Process Context](Figure 9.6 – Displaying the SELinux context for SSH-related processes)

### SELinux Domain Transitions

Domain transitions occur when a process in one domain accesses an object in a different domain.

![Domain Transition Example](Figure 9.7 – Comparing the domain affinity context)

#### Querying Policies
```bash
# Install setools-console
sudo dnf install setools-console -y

# Query security policies
sudo sesearch -s passwd_t -t shadow_t -p write --allow
```

![Policy Query](Figure 9.8 – Querying SELinux policies)

### Creating SELinux Security Policies

#### Example: Creating a Custom Daemon (packtd)

**Step 1**: Create the daemon code
![Daemon Code](Figure 9.9 – A simple daemon periodically checking logs)

```bash
# Compile the daemon
gcc -o packtd packtd.c
```

![Compilation](Figure 9.10 – Compiling the C source code)

**Step 2**: Create systemd unit file
![Systemd Unit](Figure 9.11 – The packtd daemon file)

**Step 3**: Install the daemon
```bash
sudo cp packtd /usr/local/bin/
sudo cp packtd.service /usr/lib/systemd/system/
sudo systemctl start packtd
```

![Daemon Status](Figure 9.12 – Running status and confinement status of the packtd daemon)

**Step 4**: Generate policy files
```bash
# Install required packages
sudo dnf install -y policycoreutils-devel rpm-build

# Generate policy files
sepolicy generate --init /usr/local/bin/packtd
```

![Policy Generation](Figure 9.13 – Generating policy files with sepolicy)

**Step 5**: Build the security policy
```bash
sudo ./packtd.sh
```

![Policy Build](Figure 9.14 – Building the security policy for packtd)

**Step 6**: Verify the security policy
```bash
sudo systemctl restart packtd
ps -efZ | grep packtd | grep -v grep
```

![Policy Verification](Figure 9.15 – The new security policy for packtd)

### Troubleshooting SELinux

#### Checking for Permission Issues
```bash
# Check audit logs
sudo ausearch -m AVC -ts recent

# Generate policy suggestions
sudo ausearch -m AVC -ts recent | audit2allow -R
```

![Permission Issues](Figure 9.16 – No read/write access for packtd)
![Missing Permissions](Figure 9.17 – Querying the missing permissions for packtd)

#### Updating Policy Files
![Policy Update](Figure 9.18 – Editing the packtd.te file)

After updating, rebuild and verify:
![Clean Audit](Figure 9.19 – No more permission issues for packtd)

### Managing SELinux Policies with semanage

#### Port Management
```bash
# View SSH port labels
sudo semanage port -l | grep ssh

# Add custom port
sudo semanage port -a -t ssh_port_t -p tcp 2222
```

![Port Management](Figure 9.20 – Querying and changing the SELinux security label for the SSH port)

#### Boolean Management
```bash
# Query httpd policies
sudo semanage boolean -l | grep httpd | grep ftp

# Enable FTP over HTTP
sudo semanage boolean -m --on httpd_enable_ftp_server
```

![Boolean Management](Figure 9.21 – Querying httpd policies related to FTP)
![Boolean Enable](Figure 9.22 – Enabling the security policy for FTP over HTTP)

#### File Context Management
```bash
# Query file contexts
sudo semanage fcontext -l | grep sshd

# Add custom path
sudo semanage fcontext -a -t sshd_key_t '/etc/ssh/keys(/.*)?'

# Restore context
sudo restorecon -r /etc/ssh/keys
```

![File Context](Figure 9.23 – The security context of SSH keys)
![Custom Context](Figure 9.24 – The modified security context of our SSH keys)

#### Permissive Mode Management
```bash
# List permissive types
sudo semanage permissive -l

# Make domain permissive
sudo semanage permissive -a httpd_t

# Remove from permissive
sudo semanage permissive -d httpd_t
```

![Permissive Types](Figure 9.26 – Displaying permissive types)
![Custom Permissive](Figure 9.27 – Customized permissive types)
![Revert Permissive](Figure 9.28 – Reverting permissive types)

### SELinux Troubleshooting Tools

| Tool | Purpose |
|------|---------|
| `/var/log/messages` | SELinux access control traces |
| `audit2allow` | Generate policy rules from logs |
| `audit2why` | User-friendly translations of violations |
| `ausearch` | Query policy violations |
| `ls -Z` | List filesystem objects with context |
| `ps -Z` | List processes with context |
| `restorecon` | Restore default SELinux context |
| `seinfo` | General SELinux policy information |
| `semanage` | Manage SELinux policies |
| `semodule` | Manage policy modules |
| `sepolicy` | Inspect SELinux policies |
| `sesearch` | Query policy database |

## Part 3: AppArmor

### Introduction to AppArmor

**AppArmor** is a Linux security module based on MAC that confines applications to limited resources using security profiles.

![AppArmor Status](Figure 9.29 – Getting the status of AppArmor)

#### Key Features:
- Built into mainline kernel since 2.6.36
- Ships with Ubuntu, Debian, openSUSE
- Path-based security (vs. SELinux's label-based)
- Simpler administration than SELinux

### AppArmor Modes

#### 1. Enforce Mode
- **Function**: Prevents restricted actions
- **Logging**: Violations logged in syslog
- **Default**: Ubuntu loads profiles in enforce mode

#### 2. Complain Mode
- **Function**: Allows restricted actions but logs violations
- **Use**: Ideal for testing profiles

### Creating AppArmor Profiles

#### Example: Creating appackt Application

**Step 1**: Create the application script
![AppArmor Script](Figure 9.30 – The appackt script)

```bash
# Make executable and test
chmod a+x appackt
./appackt
```

![Script Output](Figure 9.31 – The output of the appackt script)

**Step 2**: Install AppArmor utilities
```bash
sudo apt install -y apparmor-utils
```

**Step 3**: Generate profile using aa-genprof
```bash
sudo aa-genprof ./appackt
```

![Profile Generation](Figure 9.32 – Running aa-genprof and setting the profile)
![Profile Completion](Figure 9.33 – Finishing the scanning)

**Step 4**: Fine-tune with aa-logprof
```bash
sudo aa-logprof
```

**Step 5**: Clean up remnants
```bash
sudo aa-remove-unknown
```

![Profile Remnants](Figure 9.34 – Remnants of the iterative process)

**Step 6**: Verify enforcement
```bash
sudo aa-status
```

![AppArmor Enforce](Figure 9.35 – appackt in complain mode)

### Testing AppArmor Protection

![Security Violation](Figure 9.36 – appackt acting outside security boundaries)

### Managing AppArmor Profiles

#### Profile Location
Profiles are stored in `/etc/apparmor.d/` directory.

![Profile Location](Figure 9.37 – Location of the AppArmor profile for appackt)

#### Switching Modes
```bash
# Set to enforce mode
sudo aa-enforce /home/packt/appackt

# Set to complain mode
sudo aa-complain /home/packt/appackt
```

#### Disabling/Enabling Profiles
```bash
# Disable profile
sudo ln -s /etc/apparmor.d/home.packt.appackt /etc/apparmor.d/disable/
sudo apparmor_parser -R /etc/apparmor.d/home.packt.appackt

# Enable profile
sudo rm /etc/apparmor.d/disable/home.packt.appackt
sudo apparmor_parser -r /etc/apparmor.d/home.packt.appackt
```

![Profile Management](Figure 9.38 – Disabling and enabling an AppArmor profile)

## Part 4: Firewalls

### Understanding the Firewall Chain

Firewalls protect networks by monitoring and controlling traffic based on security rules.

![Firewall Diagram](Figure 9.39 – A simple firewall diagram)

### Linux Firewall Chain

![Firewall Chain](Figure 9.40 – The Linux firewall chain)

#### Chain Types:
- **INPUT**: For localhost-destined packets
- **FORWARD**: For remote host-destined packets  
- **OUTPUT**: For outgoing packets

#### Predefined Targets:
- **ACCEPT**: Accept packet for processing
- **REJECT**: Reject packet with reply
- **DROP**: Ignore packet silently
- **QUEUE**: Pass to user-space process
- **RETURN**: Return to previous chain

### Netfilter Framework

**Netfilter** provides packet filtering hooks in the Linux kernel.

#### Netfilter Hooks:
- **NF_IP_PRE_ROUTING**: Before routing decisions
- **NF_IP_LOCAL_IN**: After routing to localhost
- **NF_IP_FORWARD**: After routing to remote host
- **NF_IP_LOCAL_OUT**: Locally initiated outbound
- **NF_IP_POST_ROUTING**: Just before network exit

### Working with iptables

#### Prerequisites
```bash
# Disable firewalld (if using Fedora)
sudo systemctl stop firewalld
sudo systemctl disable firewalld
sudo systemctl mask firewalld

# Install iptables services
sudo dnf install iptables-services
```

![iptables Setup](Figure 9.42 – Disabling firewalld and installing iptables on Fedora)

#### iptables Tables and Chains

![iptables Tables](Figure 9.41 – Tables and chains in iptables)

#### Basic Configuration
```bash
# List current rules
sudo iptables -L
```

![iptables List](Figure 9.43 – Listing the current configuration in iptables)

#### Configuring iptables

**Step 1**: Flush existing rules
```bash
sudo iptables -F INPUT
sudo iptables -F FORWARD  
sudo iptables -F OUTPUT
```

![iptables Flush](Figure 9.44 – Flushing existing configuration in iptables)

**Step 2**: Set default policies
```bash
sudo iptables -P INPUT DROP
sudo iptables -P FORWARD DROP
sudo iptables -P OUTPUT DROP
```

**Step 3**: Create specific rules
```bash
# Enable SSH from local network
sudo iptables -A INPUT -p tcp --dport 22 -m state \
 --state NEW,ESTABLISHED -s 192.168.0.0/24 -j ACCEPT
sudo iptables -A OUTPUT -p tcp --sport 22 -m state \
 --state ESTABLISHED -s 192.168.0.0/24 -j ACCEPT

# Enable HTTPS
sudo iptables -A INPUT -p tcp --dport 443 -m state \
 --state NEW,ESTABLISHED -j ACCEPT
sudo iptables -A OUTPUT -p tcp --sport 443 -m state \
 --state ESTABLISHED,RELATED -j ACCEPT

# Enable DNS
sudo iptables -A INPUT -p udp --dport 53 -j ACCEPT
sudo iptables -A OUTPUT -p udp --sport 53 -j ACCEPT
```

**Step 4**: Save configuration
```bash
sudo service iptables save
```

![iptables Save](Figure 9.45 – Saving the iptables configuration)

### Working with nftables

#### Prerequisites
```bash
# Install nftables (RHEL 7)
sudo yum install -y nftables

# Disable conflicting services
sudo systemctl stop iptables
sudo systemctl disable iptables

# Enable nftables
sudo systemctl enable nftables
sudo systemctl start nftables
```

![nftables Status](Figure 9.46 – Checking the status of nftables)

#### Configuration File
```bash
sudo cat /etc/sysconfig/nftables.conf
```

![nftables Config](Figure 9.47 – The default nftables configuration file)

#### Basic nftables Configuration

**Step 1**: Create table and chain
```bash
# Create table
sudo nft add table inet packt_table

# Create chain
sudo nft add chain inet packt_table packt_chain { type filter hook input priority 0 \; }
```

**Step 2**: Add rules
```bash
# Allow SSH, HTTP, HTTPS
sudo nft add rule inet packt_table packt_chain tcp dport {ssh, http, https} accept

# Allow ICMP
sudo nft add rule inet packt_table packt_chain ip protocol icmp accept

# Reject everything else
sudo nft add rule inet packt_table packt_chain reject with icmp type port-unreachable
```

**Step 3**: View configuration
```bash
sudo nft list ruleset
```

![nftables Config](Figure 9.48 – A simple firewall configuration with nftables)

**Step 4**: Save configuration
```bash
# Save to file
sudo nft list ruleset | sudo tee /etc/nftables/packt.nft

# Update main config
sudo vim /etc/sysconfig/nftables.conf
# Add: include "/etc/nftables/packt.nft"
```

![nftables Include](Figure 9.49 – Including the new configuration in nftables.conf)

### Firewall Managers

#### Using firewalld (RHEL/Fedora)

**Installation and Setup**
```bash
# Install firewalld
sudo yum install -y firewalld

# Enable service
sudo systemctl enable firewalld
```

![firewalld Enable](Figure 9.50 – Re-enabling firewalld)

**Basic Commands**
```bash
# List zones
sudo firewall-cmd --get-zones

# List all zones with details
sudo firewall-cmd --list-all-zones
```

![firewalld Zones](Figure 9.51 – Listing firewalld zones)

```bash
# Get active zones
sudo firewall-cmd --get-active-zones

# Get default zone
sudo firewall-cmd --get-default-zone
```

![Active Zones](Figure 9.52 – The firewalld active zones)
![Default Zone](Figure 9.53 – Displaying the default zone in firewalld)

**Managing Rules**
```bash
# Block ICMP
sudo firewall-cmd --zone=FedoraServer --add-rich-rule='rule protocol value="icmp" reject'

# Check zone info
sudo firewall-cmd --info-zone=public
```

![firewalld Rules](Figure 9.54 – Getting the FedoraServer zone configuration with firewalld)

```bash
# Enable HTTPS
sudo firewall-cmd --zone=FedoraServer --add-service=https

# Add custom port
sudo firewall-cmd --zone=FedoraServer --add-port=8443/tcp

# List services and ports
sudo firewall-cmd --list-services
sudo firewall-cmd --list-ports

# Reload configuration
sudo firewall-cmd --reload
```

#### Using ufw (Ubuntu)

**Basic Commands**
```bash
# Check status
sudo ufw status

# Enable ufw
sudo ufw enable

# Allow SSH
sudo ufw allow ssh
```

![ufw Basic](Figure 9.55 – Enabling ufw, allowing ssh, and detailed status of ufw)

**Managing Applications**
```bash
# List applications
sudo ufw app list

# Allow/deny services
sudo ufw allow https
sudo ufw deny http
```

![ufw Rules](Figure 9.56 – Adding and denying rules in ufw)

**Advanced Management**
```bash
# Numbered list
sudo ufw status numbered

# Insert rule at position
sudo ufw insert 2 deny http

# Allow from specific network
sudo ufw allow from 192.168.0.0/24 to any port 22

# Enable logging
sudo ufw logging on

# Reset to defaults
sudo ufw reset
```

![ufw Numbered](Figure 9.57 – Numbered list of rules in ufw)

## Summary

### Key Takeaways

1. **Access Control Mechanisms**: Choose between SELinux (RHEL/Fedora) and AppArmor (Ubuntu/Debian)
2. **SELinux**: More complex but highly customizable, label-based security
3. **AppArmor**: Simpler administration, path-based security
4. **Firewalls**: Multiple options from low-level (iptables/nftables) to user-friendly (firewalld/ufw)
5. **Security Balance**: Find the right balance between security and usability

### Distribution-Specific Choices

| Distribution | Security Module | Firewall Manager |
|--------------|-----------------|------------------|
| RHEL/Fedora | SELinux | firewalld |
| Ubuntu/Debian | AppArmor | ufw |
| openSUSE | AppArmor/SELinux | firewalld |

### Best Practices

1. **Start with permissive mode** when creating policies
2. **Use audit logs** to troubleshoot issues
3. **Test thoroughly** before enforcing policies
4. **Keep specific rules first** in firewall configurations
5. **Document changes** for future reference
6. **Regular security audits** to maintain system integrity