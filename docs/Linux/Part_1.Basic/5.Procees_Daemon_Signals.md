# Chapter 5: Working with Processes, Daemons, and Signals

## Overview

Linux is a multitasking operating system where multiple programs can run in parallel, each with its own identity, scheduling, memory space, permissions, and system resources. Processes encapsulate the execution context of any such program.

## 1. Introduction to Processes

### What is a Process?
A **process** represents the running instance of a program. When a program runs, a process is created - essentially a program in action. Processes execute specific tasks and are sometimes referred to as jobs or tasks.

### Ways to Create Processes
- User-initiated commands in Terminal sessions
- Scripts execution
- Programs invoked manually or automatically
- Every Linux command starts a process

## 2. Process Types

### High-Level Classification

#### Foreground Processes (Interactive)
- **Definition**: Started and controlled through Terminal sessions
- **Characteristics**:
  - User-initiated via command-line interface
  - May output to console (stdout/stderr)
  - Accept user input
  - Lifetime coupled to Terminal session
  - Terminated if parent Terminal exits (via SIGHUP signal)

**Example:**
```bash
man ps
```

**Long-lived foreground process:**
```bash
while true; do echo "Wait..."; sleep 5; done
```

- Use `Ctrl + C` to interrupt (sends SIGINT signal)

![Figure 5.1 – A long-lived foreground process](paste.txt#figure-5-1)

#### Background Processes (Non-interactive)
- **Definition**: Run independently of Terminal session
- **Characteristics**:
  - No user interaction expected
  - Multiple can run simultaneously
  - Usually long-lived tasks
  - Often write output to log files

**Creating background process:**
```bash
while true; do echo "Wait..."; sleep 10; done &
```

- Append `&` to run in background
- Returns Process ID (PID)
- Terminal remains interactive

![Figure 5.2 – Running a background process](paste.txt#figure-5-2)

**Terminating background process:**
```bash
kill -9 983  # Where 983 is the PID
```

### Special Process Types

#### Daemons
- **Definition**: Background processes started at system boot
- **Characteristics**:
  - Run indefinitely until shutdown
  - No user-controlled Terminal
  - Associated with system accounts (root or other)
  - Serve client requests or communicate with other processes

**Common daemon examples:**
- `systemd`: Parent of all processes (formerly init)
- `crond`: Job scheduler
- `ftpd`: FTP server
- `httpd`: Web server (Apache)
- `sshd`: Secure Shell server

**Naming convention**: System daemons typically end with 'd'

#### The init Process
- First process to start when Linux boots
- Parent of all other processes
- Continues running until system shutdown
- Modern systems use `systemd` as init system

**View process tree:**
```bash
pstree
```

![Figure 5.3 – init (systemd), the parent of all processes](paste.txt#figure-5-3)

#### Parent and Child Processes
- **Parent process**: Creates subordinate child processes
- **Child process**: Belongs to parent that spawned it
- **Behavior**: Children usually terminate when parent exits
- **Exception**: Can ignore SIGHUP signal using `nohup` command

#### Batch Processes
- Scripts/commands scheduled to run at specific times
- Usually resource-intensive tasks
- Scheduled during less busy hours
- **Tools**: `at` (one-off jobs), `cron` (recurring jobs)

#### Orphan and Zombie Processes
- **Orphan process**: Child process whose parent terminated first
  - `init` process becomes new parent
  - Process still running
- **Zombie process**: Process that completed execution but still in process table
  - Process is dead/terminated
  - Reference lingers in system

## 3. Process Anatomy

### Using ps Command

**Basic syntax:**
```bash
ps [OPTIONS]
```

**Display current session processes:**
```bash
ps
```

![Figure 5.4 – Displaying processes owned by the current shell](paste.txt#figure-5-4)

**Key fields explained:**
- **PID**: Process ID (unique positive integer)
- **TTY**: Terminal type (pts/0 = pseudo terminal slave)
- **TIME**: Cumulative CPU utilization
- **CMD**: Command name/path that created process

**Detailed view:**
```bash
ps -l
```

![Figure 5.5 – A more detailed view of processes](paste.txt#figure-5-5)

**Additional fields:**
- **F**: Process flags (0=none, 1=forked, 4=superuser)
- **S**: Process status code
- **UID**: User ID (owner)
- **PPID**: Parent Process ID
- **PRI**: Priority (higher number = lower priority)
- **SZ**: Virtual memory usage

### Using top Command

**Real-time process monitoring:**
```bash
top [OPTIONS]
```

![Figure 5.6 – A real-time view of the current processes](paste.txt#figure-5-6)

**Key fields:**
- **USER**: Process owner
- **PR**: Priority (lower number = higher priority)
- **NI**: Nice value (dynamic priority)
- **VIRT**: Virtual memory size (KB)
- **RES**: Physical memory used (KB)
- **SHR**: Shared memory size (KB)
- **S**: Process status
- **%CPU**: CPU usage percentage
- **%MEM**: Memory usage percentage
- **COMMAND**: Command name/line

## 4. Process States

### State Types
- **D**: Uninterruptible sleep
- **I**: Idle
- **R**: Running
- **S**: Sleeping (interruptible sleep)
- **T**: Stopped by job control signal
- **t**: Stopped by debugger
- **Z**: Zombie

### High-Level Categories

1. **Running**: Currently executing (R) or idle (I)
2. **Waiting**: 
   - Interruptible sleep (S) - can be disturbed by signals
   - Uninterruptible sleep (D) - blocked in system call
3. **Stopped**: Execution halted by signal (T or t)
4. **Zombie**: Terminated but not reaped by parent (Z)

### Process Lifetime

![Figure 5.7 – The lifetime of a Linux process](paste.txt#figure-5-7)

Process typically starts in Running state (R) and terminates after being reaped from Zombie state (Z).

## 5. Working with Processes

### ps Command Examples

**Display all processes:**
```bash
ps -e | head
```

![Figure 5.8 – Displaying the first few processes](paste.txt#figure-5-8)

**Detailed view of user processes:**
```bash
ps -fU $(whoami)
```

![Figure 5.9 – Displaying the processes owned by the current user](paste.txt#figure-5-9)

**Find process by name:**
```bash
ps -ef | grep test.sh | grep -v grep
```

![Figure 5.13 – Finding a process by name using the ps command (refined)](paste.txt#figure-5-13)

**Find process by PID:**
```bash
ps -fp 1094
```

![Figure 5.14 – Finding a process by PID using the ps command](paste.txt#figure-5-14)

### pstree Command

**Show process hierarchy:**
```bash
pstree [OPTIONS] [PID] [USER]
```

**Current Terminal session tree:**
```bash
pstree $(echo $$)
```

![Figure 5.15 – The process tree of the current Terminal session](paste.txt#figure-5-15)

**With PIDs:**
```bash
pstree -p $(echo $$)
```

![Figure 5.16 – The process tree (along with its PIDs) of the current Terminal session](paste.txt#figure-5-16)

### top Command Advanced Usage

**Sort by CPU usage (top 10):**
```bash
top -b -o %CPU | head -n 17
```

**Sort by CPU and memory:**
```bash
top -b -o +%MEM | head -n 17
```

![Figure 5.18 – The top 10 processes sorted by CPU and memory usage](paste.txt#figure-5-18)

**Monitor specific PID:**
```bash
top -p 1094
```

![Figure 5.19 – Monitoring a specific PID with the top command](paste.txt#figure-5-19)

### kill and killall Commands

**kill syntax:**
```bash
kill [OPTIONS] [-s SIGNAL | -SIGNAL] PID [...]
```

**Available signals:**
```bash
kill -l
```

![Figure 5.21 – The Linux signals](paste.txt#figure-5-21)

**Kill process examples:**
```bash
kill -9 1094        # Using signal number
kill -KILL 1094     # Using signal name
```

**killall syntax:**
```bash
killall [OPTIONS] [-s SIGNAL | -SIGNAL] NAME...
```

**Kill all processes by name:**
```bash
killall -e -TERM test.sh
```

![Figure 5.22 – Terminating multiple processes with killall](paste.txt#figure-5-22)

### pgrep and pkill Commands

**Find PID by pattern:**
```bash
pgrep -f test.sh
```

![Figure 5.23 – Looking for a PID based on name using pgrep](paste.txt#figure-5-23)

**Combine with ps for details:**
```bash
pgrep -f test.sh | xargs ps -fp
```

![Figure 5.24 – Chaining pgrep and ps for more information](paste.txt#figure-5-24)

**Kill by pattern:**
```bash
pkill -ef test.sh
```

![Figure 5.25 – Killing a process by name using pkill](paste.txt#figure-5-25)

## 6. Working with Daemons

### systemd Management

**systemctl syntax:**
```bash
systemctl [OPTIONS] [COMMAND] [UNITS...]
```

**Common daemon operations:**
```bash
# Enable daemon to start at boot
sudo systemctl enable httpd

# Disable daemon from starting at boot
sudo systemctl disable httpd

# Check daemon status
sudo systemctl status httpd
sudo systemctl is-active httpd

# Start/stop daemon
sudo systemctl start httpd
sudo systemctl stop httpd
```

**Note**: systemctl commands typically require superuser privileges

## 7. Inter-Process Communication (IPC)

### IPC Mechanisms

#### 1. Shared Storage (Files)
- Simple file-based communication
- Producer writes, consumer reads
- **Challenge**: Race conditions and file locking

#### 2. Shared Memory
- Processes share common memory segment
- APIs: System V API, POSIX API
- **Implementation**: `/dev/shm` (RAM disk)

#### 3. Named and Unnamed Pipes
**Unnamed pipes:**
```bash
producer.sh | consumer.sh
```

**Named pipes (FIFOs):**
- Persistent unlike unnamed pipes
- Act as files in filesystem
- Can be deleted when not needed

#### 4. Message Queues
- Asynchronous communication
- Messages stored until processed
- Common implementations: RabbitMQ, ActiveMQ, ZeroMQ

![Figure 5.26 – Message queue (simplified view)](paste.txt#figure-5-26)

#### 5. Sockets
**Two types:**
- **IPC sockets**: Unix domain sockets (local communication)
- **Network sockets**: TCP/UDP sockets (network communication)

**Characteristics:**
- Bidirectional communication
- Client/server pattern
- Stream-based

#### 6. Signals
- One-way asynchronous notifications
- No data payload
- Used for process coordination

## 8. Working with Signals

### Signal Basics
- Alert processes about specific events
- Each signal has unique positive integer value
- Processes controlled via signals

**List all signals:**
```bash
kill -l
```

### Signal Handling Methods
1. **Default action**: Stop, terminate, core-dump, or do nothing
2. **Custom action**: Process catches and handles signal (except SIGKILL and SIGSTOP)

### Signal Terminology
- **Raised**: Signal is generated
- **Caught**: Signal is handled by process
- **Ignored**: Process has no-op handler
- **Handled**: Process implements specific action

### Important Signals
- **SIGHUP (1)**: Terminal hangup
- **SIGINT (2)**: Interrupt (Ctrl+C)
- **SIGKILL (9)**: Kill process (cannot be caught/ignored)
- **SIGTERM (15)**: Terminate process
- **SIGSTOP (19)**: Stop process (cannot be caught/ignored)

### Signal Examples

**Send signal to process:**
```bash
kill -HUP 3741      # Send SIGHUP to PID 3741
kill -1 3741        # Same as above using signal number
```

**Kill multiple processes:**
```bash
killall -e -TERM test.sh
```

### Signal Handler Process
1. Signal received → execution interrupted
2. Jump to signal-handler function
3. Handler function runs
4. Resume normal execution

## 9. Key Commands Summary

| Command | Purpose | Example |
|---------|---------|---------|
| `ps` | Display process snapshot | `ps -ef` |
| `pstree` | Show process hierarchy | `pstree -p` |
| `top` | Real-time process monitor | `top -u username` |
| `kill` | Send signal to process | `kill -9 PID` |
| `killall` | Kill processes by name | `killall -TERM name` |
| `pgrep` | Find PID by pattern | `pgrep -f script.sh` |
| `pkill` | Kill by pattern | `pkill -f script.sh` |
| `systemctl` | Control systemd daemons | `systemctl status httpd` |
| `nohup` | Run command immune to hangups | `nohup command &` |

## 10. Best Practices

### Process Management
- Use appropriate signal for termination (SIGTERM before SIGKILL)
- Monitor resource usage with `top` or `htop`
- Use `nohup` for long-running background processes
- Implement proper signal handlers in scripts

### Daemon Management
- Use systemctl for systemd-managed services
- Check daemon logs for troubleshooting
- Enable/disable services as needed for security
- Monitor daemon resource consumption

### Signal Handling
- Understand signal meanings before using
- SIGKILL and SIGSTOP cannot be caught or ignored
- Use SIGTERM for graceful shutdowns
- Implement signal handlers for critical applications

## 11. Troubleshooting Common Issues

### Zombie Processes
- Check for parent process issues
- Restart parent process if necessary
- Monitor for accumulating zombies

### High CPU/Memory Usage
- Use `top` to identify resource-heavy processes
- Check for runaway processes
- Consider process priorities and nice values

### Daemon Issues
- Check systemctl status
- Review system logs (`journalctl`)
- Verify configuration files
- Check port conflicts

## Questions for Review

1. **Process Types**: Compare foreground, background, and daemon processes
2. **Process Attributes**: Essential fields in ps output for process inspection
3. **Process States**: Different states and transitions between them
4. **Performance**: How to find CPU-intensive processes
5. **Scripting**: Creating long-lived background processes
6. **Signals**: Common process signals and their invocation
7. **IPC**: Different IPC mechanisms with pros and cons

---

*This chapter provides foundational knowledge for Linux system administration, focusing on practical process management skills essential for everyday tasks.*