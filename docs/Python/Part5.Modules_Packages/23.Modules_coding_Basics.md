# Module Coding Basics - Chapter 23 Notes

## Creating Modules

### Basic Module Creation
- **Simple Definition**: A module is just a text file with Python code and a `.py` extension
- **Automatic Recognition**: Any `.py` file is automatically considered a Python module
- **Top-level Names**: All names assigned at the top level become module attributes

```python
# Example: module1.py
def printer(x):           # Module attribute
    print(x)
```

### Module Filename Rules
- Must end with `.py` suffix for import capability
- Follow Python variable naming rules (letters, digits, underscores only)
- Cannot use reserved words (e.g., `if.py` cannot be imported)
- No platform-specific syntax like spaces in names

### Module Types
- **Python Source Files**: Standard `.py` files
- **Extension Modules**: Written in C, C++, Java (Jython)
- **Bytecode Files**: `.pyc` files created automatically

## Using Modules

### The `import` Statement
```python
import module1                         # Get module as a whole
module1.printer('Hello world!')       # Qualify to get names
```
- Loads entire module
- Must qualify names with module name
- Creates module object reference

### The `from` Statement
```python
from module1 import printer            # Copy specific names
printer('Hello world!')               # Direct access, no qualification
```
- Copies specific names to current namespace
- Allows direct access without module qualification
- Still loads entire module file

### The `from *` Statement
```python
from module1 import *                  # Copy all public names
printer('Hello world!')               # Use directly
```
- Copies all top-level names
- Can cause namespace pollution
- Limited to module top-level only (not in functions)

## Import Behavior Characteristics

### Imports Happen Only Once
```python
# init.py
print('hello')
flag = 1                   # Initialize variable â€“ just once!
```

```python
>>> import init            # First import: loads and runs code
hello
>>> init.flag = 2          # Change attribute
>>> import init            # Just fetches already loaded module
>>> init.flag              # Code wasn't rerun: attribute unchanged
2
```

### Imports Are Runtime Assignments
- Executed when Python reaches them
- Can be nested in `if` statements, functions, `try` blocks
- Not compile-time declarations

```python
if sometest:
    from moduleA import name
else: 
    from moduleB import name
```

### Shared Mutable Objects
```python
# share.py
x = 1
y = [1, 2]
```

```python
>>> from share import x, y
>>> x = 'hack'                     # Changes local x only
>>> y[0] = 'hack'                  # Changes shared mutable in place
>>> import share
>>> share.x                        # Original x unchanged
1
>>> share.y                        # Shared mutable changed
['hack', 2]
```

## Import vs From Equivalence

Conceptually, this:
```python
from module import name1, name2
```

Is equivalent to:
```python
import module
name1 = module.name1
name2 = module.name2
del module
```

## Potential Pitfalls of `from`

### Issues to Consider
1. **Variable Obscurity**: Less clear which module a name comes from
2. **Namespace Corruption**: Can overwrite existing names silently
3. **Reload Problems**: Names may reference old object versions
4. **`from *` Issues**: Can make code difficult to understand

### When `import` is Required
```python
# M.py
def func():
    # do something

# N.py  
def func():
    # do something else

# O.py - Using import to avoid collision
import M, N
M.func()                       # Calls M's version
N.func()                       # Calls N's version
```

### Using `as` for Renaming
```python
from M import func as mfunc    # Rename to avoid collision
from N import func as nfunc
mfunc(); nfunc()              # Call either version
```

## Module Namespaces

### How Files Generate Namespaces
- **Module statements run on first import**
- **Top-level assignments create module attributes**
- **Module namespaces are dictionaries** (accessible via `__dict__`)
- **Modules are single scope** (local is global)
- **Module scopes outlive imports**

```python
# spaces.py
print('starting to load...')
import sys
var = 23
def func(): pass
class klass: pass
print('done loading.')
```

### Namespace Dictionaries: `__dict__`
```python
>>> import spaces
>>> spaces.__dict__.keys()
dict_keys(['__name__', '__doc__', '__package__', '__loader__', 
          '__spec__', '__file__', '__cached__', '__builtins__', 
          'sys', 'var', 'func', 'klass'])

>>> spaces.var, spaces.__dict__['var']
(23, 23)

>>> spaces.__name__, spaces.__file__
('spaces', '/path/to/spaces.py')
```

### Useful Built-ins
```python
>>> dir(spaces) == sorted(spaces.__dict__)  # dir() returns sorted keys
True
>>> vars(spaces) == spaces.__dict__         # vars() returns __dict__
True
```

## Name Qualification Rules

### Resolution Rules
- **Simple variables** (`X`): Search current scopes using LEGB rule
- **Qualification** (`X.Y`): Find X in scopes, then search Y in object X
- **Qualification paths** (`X.Y.Z`): Chain attribute lookups
- **Generality**: Works on all objects with attributes

### Imports vs Scopes
```python
# lex1.py
X = 88
def f():
    global X
    X = 99

# lex2.py  
X = 11
import lex1
lex1.f()                      # Changes lex1.X, not local X
print(X, lex1.X)             # Output: 11 99
```

**Key Point**: Functions can never see names in other functions unless physically enclosing; modules can never see names in other modules unless explicitly imported.

### Namespace Nesting
```python
# nest3.py
X = 3

# nest2.py
X = 2
import nest3
print(X, nest3.X)           # 2 3

# nest1.py
X = 1
import nest2
print(X, nest2.X, nest2.nest3.X)  # 1 2 3
```

## Reloading Modules

### Why Reload?
- **Interactive Testing**: Test changes without restarting interpreter
- **Dynamic Customization**: Change program parts without stopping
- **Development Efficiency**: Shorter development cycles

### Reload Basics
```python
import module                     # Initial import
# ...change module file...
from importlib import reload      # Get reload function
reload(module)                    # Reload updated module
```

### Reload Characteristics
- **Function, not statement**: Requires parentheses
- **Expects module object**: Must import successfully first
- **In-place changes**: Modifies existing module object
- **Affects import clients**: All `import` references updated
- **Doesn't affect from clients**: Old `from` references unchanged

### Reload Example
```python
# changer.py (version 1)
message = 'First version'
def printer():
    print(message)
```

```python
>>> import changer
>>> changer.printer()
First version

# Edit file to:
# message = 'After editing' 
# def printer():
#     print('reloaded:', message)

>>> import changer              # No effect
>>> changer.printer()
First version

>>> from importlib import reload
>>> reload(changer)
>>> changer.printer()
reloaded: After editing
```

## Best Practices Summary

### Import Recommendations
1. **Prefer `import` over `from`** for simple modules
2. **Explicitly list variables** in `from` statements when used
3. **Limit `from *`** to one per file or REPL use
4. **Use `as` for renaming** when name conflicts occur

### Reload Considerations
- Pair with `import` rather than `from`
- Manual reload updates single module only
- Some tools offer auto-reload features
- Consider transitivity for related modules

### Common Pitfalls to Avoid
- Namespace pollution with `from *`
- Confusion about variable origins
- Reload issues with `from` imports
- Name collision problems
- Scope misunderstanding between modules

---

## Quick Reference

| Statement | Purpose | Access Method | Namespace Impact |
|-----------|---------|---------------|------------------|
| `import module` | Load entire module | `module.name` | Clean separation |
| `from module import name` | Copy specific names | `name` | Selective copying |
| `from module import *` | Copy all names | `name` | Potential pollution |
| `reload(module)` | Force re-import | Same as original import | Updates existing |

## Key Takeaways

1. **Modules are namespaces** - places where names are created and stored
2. **Import happens once** - subsequent imports fetch cached module object
3. **from is import + copy** - still loads entire module, just copies names
4. **Qualification prevents conflicts** - `module.name` vs direct `name` access
5. **Reload enables dynamic updates** - essential for interactive development
6. **Scopes are lexical** - determined by code position, not runtime calls