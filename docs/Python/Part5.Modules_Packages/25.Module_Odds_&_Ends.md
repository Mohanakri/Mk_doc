# Chapter 25: Module Odds and Ends - Study Notes

## Overview
This chapter covers advanced module topics including data hiding, dual-usage modes, dynamic imports, and common gotchas. These concepts are essential for writing robust Python applications and understanding how modules work internally.

## Module Design Concepts

### Key Principles

1. **You're always in a module** - Even interactive code runs in the `__main__` module
2. **Minimize module coupling** - Avoid dependencies on global variables from other modules
3. **Maximize module cohesion** - Components should share a unified purpose
4. **Modules should rarely change other modules' variables** - Use function arguments and return values instead

### Module Environment Structure
```
Module (Top Level)
├── Variables
├── Functions (with local variables)
├── Classes (with their own scope)
└── Imported modules
```

## Data Hiding in Modules

### The `_X` Convention
Python uses conventions, not syntax, for data hiding. Variables prefixed with a single underscore are excluded from `from *` imports.

**Example: unders.py**
```python
a, b, _c, _d = 1, 2, 3, 4  # Control from * exports
```

**Usage:**
```python
from unders import *   # Only gets a, b (not _c, _d)
print(a, b)           # Works: (1, 2)
print(_c)             # NameError: not imported

from unders import _c  # Direct import still works
print(_c)             # Works: 3
```

### The `__all__` List
Alternative to `_X` convention - explicitly lists names to export with `from *`.

**Example: alls.py**
```python
__all__ = ['a', '_c']          # Control exports explicitly
a, b, _c, _d = 1, 2, 3, 4      # __all__ has precedence over _X
```

**Key Points:**
- `__all__` takes precedence over `_X` convention
- Only affects `from *` imports
- Other import forms still access all names

## Module Attribute Management

### `__getattr__` and `__dir__` (Python 3.7+)
Special functions for managing module attribute access.

**Example: gamod.py**
```python
var = 2  # Real attribute

def __getattr__(name):  # Handle undefined attributes
    print(f'(virtual {name})', end=' ')
    match name:
        case 'test':
            return name * var
        case 'hack' | 'code':
            return name.upper()
        case _:
            raise AttributeError(f'{name} is undefined')

def __dir__():
    return ['var', 'test', 'hack', 'code']
```

**Usage:**
```python
import gamod
print(gamod.var)    # Real attribute: 2
print(gamod.test)   # Virtual: 'testtest'
print(gamod.hack)   # Virtual: 'HACK'
```

## Language Evolution: `__future__`

### Enabling New Features
Import future language features before they become default.

```python
from __future__ import featurename
```

**Requirements:**
- Must be first executable statement (after docstring/comments)
- Enables special compilation on per-module basis
- Safe to leave in code even after feature becomes default

## Dual-Usage Modes: `__name__` and `__main__`

### The `__name__` Variable
- When file is run as script: `__name__ = '__main__'`
- When file is imported: `__name__ = module_name`

### Basic Pattern
**Example: dualmode.py**
```python
def title():
    print('Learning Python, 6E')

if __name__ == '__main__':  # Only when run as script
    title()                 # Not when imported
```

### Common Use Cases

#### 1. Self-Testing
```python
def minmax(test, *args):
    res = args[0]
    for arg in args[1:]:
        if test(arg, res):
            res = arg
    return res

def lessthan(x, y): return x < y
def grtrthan(x, y): return x > y

if __name__ == '__main__':
    # Self-test code
    print(minmax(lessthan, 4, 2, 1, 5, 6, 3))  # Output: 1
    print(minmax(grtrthan, 4, 2, 1, 5, 6, 3))  # Output: 6
```

#### 2. Command-Line Utilities
```python
def main():
    # Main program logic
    pass

if __name__ == '__main__':
    main()
```

## Import Extensions: `as` Clause

### Module Renaming
```python
import reallylongmodulename as name  # Shorter nickname
name.func()

import modulename as name            # Equivalent to:
# import modulename
# name = modulename
# del modulename
```

### Avoiding Name Collisions
```python
from module1 import utility as util1
from module2 import utility as util2
util1(); util2()
```

### Package Path Simplification
```python
import dir1.dir2.mod as mod
mod.func()  # Only list full path once
```

## Module Introspection

### Accessing Module Attributes
Multiple ways to access the same attribute:
```python
# All equivalent after importing M and sys
M.name                              # Direct qualification
M.__dict__['name']                  # Manual dictionary access
vars(M)['name']                     # vars() alternative
sys.modules['M'].name               # Via loaded modules table
getattr(M, 'name')                  # Built-in function
sys.modules['M'].__dict__['name']   # Combined approach
```

### Module Listing Tool
**Example: mydir.py**
```python
def listing(module, verbose=True, unders=True):
    """List module attributes with formatting"""
    sepline = '-' * 60
    if verbose:
        print(sepline)
        print(f'name: {module.__name__}\nfile: {module.__file__}')
        print(sepline)

    for (count, attr) in enumerate(sorted(module.__dict__)):
        prefix = f'{count + 1:02d}) {attr}'
        if attr.startswith('__'):
            if unders:
               print(prefix, '<built-in name>')
        else:
           print(prefix, getattr(module, attr))

    if verbose:
        print(sepline)
        print(f'{module.__name__} has {count + 1} names')
        print(sepline)

if __name__ == '__main__':
    import mydir
    listing(mydir)  # Self-test
```

## Dynamic Imports by Name String

### Problem
Cannot use string variables directly in import statements:
```python
import 'string'  # SyntaxError
x = 'string'
import x         # Tries to import file 'x.py'
```

### Solutions

#### 1. Using `exec()`
```python
modname = 'string'
exec('import ' + modname)  # Compiles and runs string
```

#### 2. Using `__import__()`
```python
modname = 'string'
string = __import__(modname)  # Direct call, returns module
```

#### 3. Using `importlib.import_module()`
```python
import importlib
modname = 'string'
string = importlib.import_module(modname)  # Preferred modern approach
```

### Package Import Differences
```python
import importlib
__import__('email.message')           # Returns leftmost: email
importlib.import_module('email.message')  # Returns rightmost: email.message
```

## Transitive Module Reloads

### The Problem
Standard `reload()` only reloads the specified module, not its imported dependencies.

### Solution: Recursive Reloader
**Example: reloadall.py**
```python
import types
from importlib import reload

def status(module):
    print('reloading', module.__name__)

def tryreload(module):
    try:
        reload(module)
    except:
        print('FAILED:', module)

def transitive_reload(module, visited):
    if not module in visited:
        status(module)
        tryreload(module)
        visited[module] = True
        for attrobj in module.__dict__.values():
            if type(attrobj) == types.ModuleType:
                transitive_reload(attrobj, visited)  # Recursion

def reload_all(*args):
    visited = {}
    for arg in args:
        if type(arg) == types.ModuleType:
            transitive_reload(arg, visited)

if __name__ == '__main__':
    import sys, importlib
    if len(sys.argv) > 1:
        modname = sys.argv[1]
    else:
        modname = 'reloadall'
    module = importlib.import_module(modname)
    reload_all(module)
```

### Usage Examples
```python
# Interactive usage
from reloadall import reload_all
import os, tkinter
reload_all(os)      # Reloads os and all its dependencies

# Command line usage
python3 reloadall.py tkinter  # Reloads tkinter and dependencies
```

## Common Module Gotchas

### 1. Module Name Clashes
**Problem:** Two modules with same name - only leftmost in `sys.path` is found.

**Solutions:**
- Use different names
- Use package structure with unique directory names
- Use package-relative imports

### 2. Statement Order in Top-Level Code
**Problem:** Forward references fail in top-level code.

```python
func1()        # Error: func1 not yet defined

def func1():
    print(func2())  # OK: resolved when called

func1()        # Error: func2 not yet defined

def func2():
    return "Hello"

func1()        # OK: both functions defined
```

**Solution:** Put function definitions at top, execution code at bottom.

### 3. `from` Copies Names, Doesn't Link
**Problem:** Changes to imported names don't affect original module.

```python
# nested.py
X = 99
def printer(): print(X)

# Client code
from nested import X, printer
X = 88           # Changes local X only
printer()        # Still prints 99

# Better approach
import nested
nested.X = 88    # Changes module's X
nested.printer() # Prints 88
```

### 4. `from *` Obscures Variable Origins
**Problem:** Can't tell where variables come from.

```python
from module1 import *  # May overwrite names
from module2 import *  # No way to see origins
from module3 import *

func()  # Which module defined this?
```

**Solution:** Use explicit imports or limit to one `from *` per file.

### 5. `reload` Doesn't Impact `from` Imports
**Problem:** Reloaded modules don't update names copied with `from`.

```python
from module import X  # Copy name
reload(module)       # Module updated
X                   # Still references old object

# Better approach
import module
reload(module)
module.X           # Gets updated value
```

### 6. Recursive `from` Imports
**Problem:** Circular imports with `from` can fail if names aren't assigned yet.

```python
# recur1.py
X = 1
import recur2  # Runs recur2 now
Y = 2

# recur2.py
from recur1 import X  # OK: X already assigned
from recur1 import Y  # Error: Y not yet assigned
```

**Solutions:**
- Redesign to eliminate cycles
- Use `import` instead of `from` for circular imports
- Move `from` statements inside functions or to end of file

## Testing and Interactive Development

### Best Practices
1. Use `__name__ == '__main__'` for self-test code
2. Prefer `import` over `from` when using `reload()`
3. Structure modules as both libraries and command-line tools
4. Use introspection tools for debugging and analysis

### Interactive Testing Pattern
```python
# Initial development
import module
module.function()

# After making changes
from importlib import reload
reload(module)
module.function()  # Gets updated version
```

## Summary

This chapter covered advanced module concepts that make Python modules more flexible and powerful:

- **Data hiding** through `_X` and `__all__` conventions
- **Dual-mode execution** with `__name__` checking
- **Dynamic imports** using string names
- **Module introspection** for building metaprograms
- **Transitive reloading** for development workflows
- **Common pitfalls** and how to avoid them

These techniques enable you to write more maintainable, testable, and flexible Python code while understanding the underlying mechanics of Python's module system.

---

*Note: This chapter concludes Part V (Modules and Packages). The next part covers Classes and Object-Oriented Programming.*