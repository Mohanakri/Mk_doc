# Chapter 23: Module Coding Basics - Study Notes

## Creating Modules

### Basic Module Creation
- **Simple creation**: Write Python code in a text file and save with `.py` extension
- **No special syntax required**: Every Python source file is automatically a module
- **Top-level assignments**: All names assigned at the top level become module attributes

```python
# module1.py
def printer(x):           # Module attribute
    print(x)
```

### Module Filename Rules
- **Required extension**: `.py` suffix for imported modules (optional for scripts)
- **Variable name rules**: Module names must follow Python variable naming conventions
- **Reserved words**: Cannot use reserved words as module names (e.g., `if.py` cannot be imported)
- **Package directories**: Must also follow variable naming rules, no platform-specific syntax like spaces

## Using Modules

### The `import` Statement
```python
import module1                         # Get module as a whole
module1.printer('Hello world!')        # Qualify to get names
```
- **Module object**: Import creates a variable referencing the entire module object
- **Qualification required**: Must use `module.attribute` syntax to access names

### The `from` Statement
```python
from module1 import printer            # Copy out specific variables
printer('Hello world!')                # Direct access, no qualification
```
- **Name copying**: Copies specific names from module to current scope
- **Direct access**: Can use imported names directly without module qualification
- **Module not assigned**: The module name itself is not available

### The `from *` Statement
```python
from module1 import *                   # Copy out ALL variables
printer('Hello world!')                # Use names unqualified
```
- **Copies all names**: Imports all top-level names from the module
- **Namespace merging**: Essentially merges one module's namespace into another
- **Restrictions**: Can only be used at top level of module file, not within functions

## Import Behavior

### Imports Happen Only Once
- **First import only**: Module code runs only on the first import per process
- **Subsequent imports**: Simply fetch the already loaded module object
- **Initialization code**: Top-level code runs once and can initialize persistent state

```python
# init.py
print('hello')
flag = 1                   # Initialize variable â€“ just once!
```

### Imports Are Runtime Assignments
- **Executable statements**: `import` and `from` are executable, not compile-time declarations
- **Can be conditional**: May appear in `if` tests, function definitions, `try` statements
- **Assignment semantics**: Follow the same rules as regular Python assignments

### Changing Mutables in Modules
```python
# share.py
x = 1
y = [1, 2]

# In REPL:
from share import x, y
x = 'hack'                     # Changes local x only
y[0] = 'hack'                  # Changes shared mutable in place
```

### Cross-file Name Changes
- **`from` limitation**: Cannot change global names in the original module
- **`import` solution**: Must use `import` to modify names in other modules

```python
import share
share.x = 23                   # Changes x in other module
```

## Import vs From Equivalence

The `from` statement is conceptually equivalent to:
```python
# from module import name1, name2
# is equivalent to:
import module
name1 = module.name1
name2 = module.name2
del module
```

## Potential Pitfalls of `from`

### Issues with `from`
1. **Obscured meaning**: Less clear which module a name comes from
2. **Namespace corruption**: Can silently overwrite existing variables
3. **Reload problems**: May reference outdated objects after reload
4. **`from *` issues**: Can trash namespaces and make code hard to understand

### When `import` is Required
- **Name conflicts**: When two modules define the same name differently
- **Solution with `import`**: Module names make the references unique

```python
# M.py and N.py both define func()
import M, N
M.func()                       # Call M's version
N.func()                       # Call N's version
```

### Alternative: Using `as` for Renaming
```python
from M import func as mfunc    # Rename uniquely
from N import func as nfunc
mfunc(); nfunc()               # Call either version
```

## Module Namespaces

### How Files Generate Namespaces
1. **Module execution**: Statements run from top to bottom on first import
2. **Attribute creation**: Top-level assignments create module attributes
3. **Dictionary storage**: Module namespaces are stored as dictionaries
4. **Single scope**: Local and global scopes are the same in modules
5. **Persistent scope**: Module scope survives after import

### Namespace Dictionaries: `__dict__`
```python
import spaces
spaces.__dict__.keys()         # View all module attributes
spaces.var                     # Normal attribute access
spaces.__dict__['var']         # Dictionary access
```

### Special Module Attributes
- `__file__`: Path to the module file
- `__name__`: Module name as known to importers
- `__dict__`: Module's namespace dictionary

### Useful Functions
```python
dir(spaces)                    # Sorted list of module attributes
vars(spaces)                   # Returns module's __dict__
list(name for name in spaces.__dict__ if not name.startswith('__'))  # Filter user-defined names
```

## Attribute Name Qualification

### Qualification Rules
- **Simple variables** (`X`): Search current scopes using LEGB rule
- **Qualification** (`X.Y`): Find X in scopes, then search for Y in object X
- **Qualification paths** (`X.Y.Z`): Chain attribute lookups
- **General rule**: Works on all objects with attributes

### Imports vs Scopes
- **No automatic visibility**: Cannot access names in other modules without importing
- **Lexical scoping**: Scopes determined by code's physical position
- **Import isolation**: Imported files cannot see names in importing files

## Namespace Nesting

### Downward Nesting
```python
# nest1.py
X = 1
import nest2
print(nest2.nest3.X)          # Access nested module attributes
```
- **Qualification paths**: Can descend into arbitrarily nested modules
- **No upward visibility**: Nested modules cannot see importing module's names

## Reloading Modules

### Why Reload?
- **REPL testing**: Easier than restarting Python session
- **Dynamic customization**: Change parts of running programs
- **Development efficiency**: Shorter development cycles

### Reload Basics
```python
import module                  # Initial import
# ...change module file...
from importlib import reload   # Get reload function
reload(module)                 # Force reload
```

### Reload Characteristics
- **Function, not statement**: Requires parentheses and import
- **Expects object**: Must pass existing module object
- **In-place changes**: Modifies existing module object
- **Affects import clients**: All `import` references see changes
- **Doesn't affect from clients**: Old `from` references unchanged
- **Single module only**: Must reload each changed module separately

### Reload Example
```python
# changer.py (initial)
message = 'First version'
def printer():
    print(message)

# In REPL:
import changer
changer.printer()              # First version

# Edit file, then:
from importlib import reload
reload(changer)
changer.printer()              # Shows updated version
```

## Best Practices

### Import Recommendations
1. **Prefer `import`** for simple modules
2. **Explicit `from` lists** when using `from`
3. **Limit `from *`** to one per file or REPL use
4. **Use `as` for renaming** when needed

### Development Tips
- **List imports at top**: Makes them easier to spot
- **Avoid imports in functions**: Prevents re-import overhead
- **Use reload carefully**: Pair with `import`, not `from`

## Key Takeaways

1. **Modules are namespaces**: Files become packages of names
2. **Import runs code once**: Subsequent imports fetch existing objects
3. **Qualification vs scopes**: Different mechanisms for name resolution
4. **from copies names**: Creates references to shared objects
5. **Reload enables dynamics**: Allows runtime program modification
6. **Namespace isolation**: Modules cannot see each other's names without importing