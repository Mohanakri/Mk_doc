# Python Module Packages - Study Notes

## Overview

Module packages are collections of module files that correspond to folders on your device. They provide a way to organize Python code into hierarchical structures and avoid naming conflicts.

### Key Concepts

- **Package imports**: Give part of a folder path leading to a file
- **Packages**: Organize modules into folder bundles  
- **Package-relative imports**: Use dots within a package to limit search
- **Namespace packages**: Build packages that may span multiple folders

## Package Imports

### Basic Syntax

Package imports use dotted paths that reflect nested folder structures:

```python
import dir1.dir2.mod                    # Import statement
from dir1.dir2.mod import var          # From statement  
from importlib import reload
reload(dir1.dir2.mod)                  # Reload statement
```

### Directory Structure

The dotted path corresponds to actual folder hierarchy:

```
dir0/dir1/dir2/mod.py            # Unix
dir0\dir1\dir2\mod.py            # Windows
```

Where `dir0` must be on the module search path (`sys.path`).

### Search Path Requirements

- The leftmost component must be in a directory on `sys.path`
- Use platform-specific paths in search path settings, not in import statements
- Cannot use platform-specific syntax like `C:\dir1` or `/Users/me/dir1` in imports

**Valid approach:**
```python
# Add to PYTHONPATH: C:\Users\me\mycode or /Users/me/mycode
import dir1.dir2.mod             # OK: variables and periods only
```

## Creating Packages

### Basic Package Structure

```
dir0/                           # Container on module search path
    dir1/                       # Package root folder
        mod.py                  # Module file dir1.mod
        dir2/                   # Nested package folder
            mod.py              # Module dir1.dir2.mod
```

### Example Module Files

**dir1/mod.py:**
```python
var = 'hack'
print('Loading dir1.mod')
```

**dir1/dir2/mod.py:**
```python
var = 'code'
print('Loading dir1.dir2.mod')
```

### Using Basic Packages

```python
>>> import dir1.mod
Loading dir1.mod
>>> dir1.mod.var
'hack'

>>> import dir1.dir2.mod
Loading dir1.dir2.mod
>>> dir1.dir2.mod.var
'code'
```

**Important:** You must import nested modules explicitly:

```python
>>> import dir1                 # Gets dir1, nothing below it
>>> dir1.dir2.mod.var          # AttributeError!

>>> import dir1.dir2.mod        # Must list full path
>>> dir1.dir2.mod.var          # Now works
'code'
```

## Special Package Files

### `__init__.py` Files

Optional files that run automatically when a package is first imported.

**Updated structure:**
```
dir0/
    dir1/
        __init__.py             # Run on first import of dir1
        mod.py
        dir2/
            __init__.py         # Run on first import of dir1.dir2
            mod.py
```

**dir1/__init__.py:**
```python
var = 'Python'
print('Running dir1.__init__.py')
```

**dir1/dir2/__init__.py:**
```python
var = 3.12
print('Running dir1.dir2.__init__.py')
```

**Usage:**
```python
>>> import dir1.dir2.mod
Running dir1.__init__.py        # Runs all __init__.py files
Running dir1.dir2.__init__.py
Loading dir1.dir2.mod
>>> dir1.var                    # Access __init__.py namespace
'Python'
>>> dir1.dir2.var
3.12
```

### `__main__.py` Files

Files that run when a package is executed as a program.

**dir1/__main__.py:**
```python
print('Executing dir1.__main__.py')
```

**Usage:**
```bash
# Direct command line (runs __main__.py only)
$ python3 dir1
Executing dir1.__main__.py

# Python -m mode (runs __init__.py then __main__.py)
$ python3 -m dir1
Running dir1.__init__.py
Executing dir1.__main__.py
```

## Why Use Packages?

### Problem: Name Conflicts

Consider two systems with same-named files:

```
system1/
    utilities.py
    main.py
    
system2/
    utilities.py
    main.py
```

**Issue:** `import utilities` can only load one version.

### Solution: Package Organization

```
root/
    system1/
        utilities.py
        main.py
    system2/
        utilities.py
        main.py
    mycode/
        myfile.py
```

**Usage:**
```python
import system1.utilities        # Import from one package
import system2.utilities        # Import from another

system1.utilities.function('hack')  # Use names from either
system2.utilities.function('code')  # Or both!
```

## `__init__.py` File Roles

### 1. Package Initialization
Run setup code when package is first imported:
```python
# __init__.py
# Create data files, open database connections, etc.
```

### 2. Module Namespace Initialization
Provide attributes for the package module object:
```python
# __init__.py
version = "1.0"
author = "Developer Name"
```

### 3. Package Declaration
Declare directory as a Python package (gives precedence in search).

### 4. Control `from *` Behavior
```python
# __init__.py
__all__ = ['module1', 'module2']  # What to import with from package import *
```

## Package-Relative Imports

### Syntax (only works in `from` statements)

```python
from . import module           # Import module in this package
from .module import name       # Import name from module in this package
from .. import module          # Import from parent package
from ..module import name      # Import name from parent's sibling
```

### Relative vs Absolute Imports

**Relative imports (with dots):**
- Search only within the package
- Only work when file is used as part of a package
- Ensure imports load package's own modules

**Absolute imports (without dots):**
- Search in `sys.path` directories
- Skip the enclosing package
- Work in both package and non-package modes

### Trade-offs and Solutions

**Problem:** Relative imports limit code flexibility (package-only vs program-only).

**Solution:** Use full package paths everywhere:
```python
import package.module               # Instead of: from . import module
from package import module          # Instead of: from . import module  
from package.module import name     # Instead of: from .module import name
```

This allows code to work in both package and program modes.

### Example: Dual-Mode Code

**dir1/__main__.py (flexible version):**
```python
import dir1.mod  # Full package path
print('Executing dir1.__main__.py:', dir1.mod.var.upper())
```

**Usage (both work):**
```bash
$ export PYTHONPATH=.
$ python3 dir1                      # Direct command
$ python3 -m dir1                   # Module mode
```

## Namespace Packages

### Definition
Packages that may span multiple directories and don't require `__init__.py` files.

### Python Import Models Evolution

1. **Basic modules**: `import module`
2. **Basic packages**: `import folder.module` (with `__init__.py`)
3. **Package-relative imports**: `from . import module`
4. **Namespace packages**: `import anyfolder.module` (no `__init__.py` required)

### Package Types

- **Regular packages**: Have `__init__.py`, reside in single directory
- **Namespace packages**: No `__init__.py`, may span multiple directories

### Import Search Algorithm

For each directory in search candidates, Python tests:

1. **`directory/name/__init__.py`** → Regular package (returned)
2. **`directory/name.{py,pyc,etc}`** → Simple module (returned)  
3. **`directory/name` (directory)** → Record and continue scanning
4. **Not found** → Continue to next directory

If scan completes with recorded directories from step 3, create namespace package.

### Namespace Package Example

**Structure:**
```
ns/
    part1/
        sub/
            mod1.py
    part2/
        sub/
            mod2.py
```

**Setup:**
```bash
$ export PYTHONPATH=ns/part1:ns/part2
```

**Usage:**
```python
>>> import sub                      # Virtual concatenation of directories
>>> from sub import mod1
Loading ns/part1/sub/mod1
>>> import sub.mod2                 # From different directory
Loading ns/part2/sub/mod2
```

The `sub` namespace package spans both `part1/sub/` and `part2/sub/` directories.

## Best Practices

### When to Use Packages

- **Large programs** with many modules
- **Libraries** for others to use  
- **Avoiding name conflicts**
- **Organizing related code**

### Package Design Tips

1. **Use meaningful names** that follow variable naming rules
2. **Keep `__init__.py` simple** or empty for precedence
3. **Consider namespace packages** for flexible installations
4. **Use full paths** for dual-mode compatibility
5. **Document package structure** clearly

### Import Strategy

```python
# Recommended: Full package paths for flexibility
import mypackage.utils
from mypackage import config
from mypackage.data import models

# Alternative: Shorter paths with from/as
from mypackage.utils import helper as h
import mypackage.data.models as models
```

## Common Patterns

### Package with Command-Line Interface

```
mypackage/
    __init__.py          # Package initialization
    __main__.py          # CLI entry point
    core.py             # Core functionality  
    utils/
        __init__.py
        helpers.py
```

### Library Package Structure

```
mylib/
    __init__.py         # Public API exports
    core/
        __init__.py
        engine.py
        parser.py
    utils/
        __init__.py  
        validation.py
    tests/
        __init__.py
        test_core.py
```

## Summary

- **Packages** organize modules into folder hierarchies
- **`__init__.py`** provides initialization and namespace control
- **`__main__.py`** enables package execution as programs
- **Package-relative imports** ensure internal consistency but limit flexibility
- **Namespace packages** allow splitting across directories and optional `__init__.py`
- **Full package paths** provide the most flexible import strategy

Packages are optional but valuable for organizing larger codebases and avoiding naming conflicts.