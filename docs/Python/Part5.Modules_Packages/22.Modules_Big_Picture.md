# Python Modules: The Big Picture - Chapter 22 Notes

## Module Essentials

### What are Modules?
- **Definition**: Modules typically correspond to Python source code files
- Each file of code is automatically a module
- Modules can also be:
  - Extensions coded in external languages (C, Java, C#)
  - Entire directories in package imports

### Core Module Tools
1. **`import`** - Lets a client fetch a module as a whole
2. **`from`** - Allows clients to fetch particular names from a module
3. **`importlib.reload`** - Provides a way to reload a module's code without stopping Python

## Why Use Modules?

### 1. Code Reuse
- Modules make code permanent (saved in files)
- Can be run multiple times and used in multiple programs
- Tools defined in modules can be reused by any number of external clients

### 2. Minimizing Redundancy
- Enables shared copies of common code
- Write once, import many times
- Helps avoid copy-and-paste programming
- Minimizes work when common code must be changed

### 3. Namespace Partitioning
- Highest-level namespace structure in Python programs
- Self-contained packages of names
- Can't see names in another file unless explicitly imported
- Helps avoid name clashes across programs

## Python Program Architecture

### Program Structure
- **Top-level (script) file**: Contains main flow of control
- **Module files**: Libraries of tools used by top-level file
- Files import modules to gain access to their **attributes**

### Example Structure
```
a.py (top-level script)
├── imports b.py (module)
└── imports c.py (module)
```

### Import and Attribute Access
```python
# b.py (module)
def job(tool):
    print(tool, 'coder')

# a.py (script)
import b
b.job('Python')  # Prints "Python coder"
```

### Standard Library Modules
- Large collection of utility modules (300+ modules)
- Platform-independent support for common tasks:
  - Operating system interfaces
  - Object persistence
  - Text pattern matching
  - Network and internet scripting
  - GUI construction
  - Multithreading

## How Imports Work

### Three-Step Import Process
Performed **only the first time** a module is imported:

#### Step 1: Find It
- Python locates the module file using the module search path
- Import statements omit `.py` extension and directory path
- Uses standard search path and known file types

#### Step 2: Compile It (Maybe)
- Compiles source code to bytecode if necessary
- Saves bytecode in `.pyc` file in `__pycache__` subdirectory
- Two flavors of bytecode files:
  - **Timestamp-based** (default): Created by importing modules
  - **Hash-based**: Created using `compileall` or `py_compile` modules

**Bytecode File Checks:**
- Compatible format (magic number)
- Up to date with source (timestamp/size or hash)
- Created by running Python (implementation and version tags)

#### Step 3: Run It
- Executes the bytecode
- Runs all statements in module file from top to bottom
- Assignments create attributes of the resulting module object

### Module Caching
- Loaded modules stored in `sys.modules` dictionary
- Later imports bypass all three steps and fetch already loaded module
- `sys.modules['name']` equals `name` after `import name`

## The Module Search Path

### Search Path Components (in order)
1. **Home directory** (automatic)
   - Directory containing top-level script file
   - Current working directory for interactive sessions

2. **PYTHONPATH directories** (configurable)
   - User-defined environment variable
   - List of directories containing Python code

3. **Standard library directories** (automatic)
   - Where standard library modules are installed

4. **site-packages directory** (automatic)
   - Where third-party extensions are installed
   - Used by `pip install`

5. **.pth path files** (configurable)
   - Text files listing directories (one per line)
   - Alternative to PYTHONPATH settings

### Configuring the Search Path

#### PYTHONPATH Examples
```bash
# Unix/macOS
export PYTHONPATH=/Users/me/pycode/utilities:/Volumes/ssd/pycode/package1

# Windows
set PYTHONPATH=C:\Users\me\pycode\utilities;d:\pycode\package1
```

#### .pth File Example
```
# mypath.pth in site-packages directory
/Users/me/pycode/utilities
/Volumes/ssd/pycode/package1
```

### The sys.path List
- Built-in list of directory-name strings
- Actual module search path within Python
- Searched from left to right
- Can be modified at runtime:

```python
import sys
sys.path.append('/Users/me/pycode4')  # Extend search path
import module  # Searches new directory
```

## Module File Selection

### Module Sources
An `import b` statement might load:
- Source code file (`b.py`)
- Bytecode file (`b.cpython-312.pyc` in `__pycache__`)
- Bytecode file (`b.pyc`)
- Directory (`b/` for package imports)
- Compiled built-in module (coded in C)
- Compiled extension module (`b.so` or `b.pyd`)
- File embedded in ZIP file
- In-memory module image
- Java class (Jython)
- .NET component (IronPython)

### Selection Priorities
- Python loads first matching item found in leftmost directory of search path
- Within same directory, follows standard picking order
- **Best practice**: Make module names distinct

## Key Concepts Summary

### Module Namespace
- Self-contained package of variables (module attributes)
- Contains all names assigned at top level of module file
- Module's global scope becomes module object's attribute namespace

### Import Behavior
- Cross-file linking resolved at runtime
- Import statements assign module names to loaded module objects
- Objects defined by module code created during import execution

### File Extensions
- Omitted from import statements by design
- Python automatically selects appropriate file type
- Differences in file type irrelevant to importers

## Best Practices

1. **Avoid name conflicts**: Don't accidentally hide standard library modules
2. **Use distinct names**: Make module names unique
3. **Configure search path properly**: Use PYTHONPATH or .pth files for cross-directory imports
4. **Understand caching**: Remember modules are imported only once per process
5. **Keep imports simple**: Let Python handle file type selection automatically

## Common Patterns

### Basic Import Pattern
```python
# module.py
def utility_function():
    return "Hello from module"

# main.py
import module
result = module.utility_function()
```

### Checking Loaded Modules
```python
import sys
print(sorted(sys.modules))  # List all loaded modules
print(sys.modules['os'] is os)  # True after importing os
```

### Path Inspection
```python
import sys
print(sys.path)  # View current module search path
```