# Chapter 30: Operator Overloading - Study Notes

## Overview
Operator overloading allows classes to intercept and customize built-in Python operations through specially named methods. These methods start and end with double underscores (`__method__`).

## Key Concepts

### What is Operator Overloading?
- **Definition**: Intercepting built-in operations in class methods
- Python automatically calls your methods when instances appear in built-in operations
- Method return values become the result of the operation

### Core Principles
- Operator overloading methods are **optional** (except basic ones like `__init__`)
- No defaults for most methods (except inherited from `object`)
- If not defined, the operation is simply unsupported
- Makes classes consistent with built-in types

## Common Operator Overloading Methods

| Method | Implements | Called for |
|--------|------------|------------|
| `__init__` | Constructor | Object creation: `X = Class(args)` |
| `__del__` | Destructor | Object reclamation |
| `__add__` | Operator + | `X + Y`, `X += Y` if no `__iadd__` |
| `__radd__` | Right-side + | `other + X` |
| `__iadd__` | In-place += | `X += Y` |
| `__repr__`, `__str__` | String representation | `print(X)`, `str(X)`, `repr(X)` |
| `__call__` | Function calls | `X(*args, **kwargs)` |
| `__getitem__` | Indexing/slicing | `X[i]`, `X[i:j]` |
| `__setitem__` | Index assignment | `X[i] = value` |
| `__getattr__` | Attribute access | `X.undefined` |
| `__setattr__` | Attribute assignment | `X.any = value` |
| `__len__` | Length | `len(X)` |
| `__bool__` | Boolean tests | `bool(X)`, truth tests |
| `__lt__`, `__gt__`, etc. | Comparisons | `X < Y`, `X > Y`, etc. |
| `__iter__`, `__next__` | Iteration | `for`, `in`, comprehensions |
| `__contains__` | Membership | `item in X` |

## Indexing and Slicing: `__getitem__` and `__setitem__`

### Basic Indexing
```python
class Indexer:
    def __getitem__(self, index):
        return index ** 2

X = Indexer()
print(X[2])  # 4
```

### Handling Both Index and Slice
```python
class Indexer:
    def __init__(self, data):
        self.data = data
    
    def __getitem__(self, index):
        if isinstance(index, int):
            print('indexing', index)
        else:  # slice object
            print('slicing', index.start, index.stop, index.step)
        return self.data[index]
```

### Index Assignment
```python
class IndexSetter:
    def __init__(self, data):
        self.data = data
    
    def __setitem__(self, index, value):
        self.data[index] = value
```

## Iteration Support

### Method 1: `__getitem__` (Legacy Fallback)
```python
class StepperIndex:
    def __getitem__(self, i):
        return self.data[i]

# Automatically supports: for loops, in, comprehensions, etc.
```

### Method 2: `__iter__` and `__next__` (Preferred)
```python
class Squares:
    def __init__(self, start, stop):
        self.value = start - 1
        self.stop = stop
    
    def __iter__(self):
        return self
    
    def __next__(self):
        if self.value == self.stop:
            raise StopIteration
        self.value += 1
        return self.value ** 2
```

### Method 3: `__iter__` with `yield` (Most Concise)
```python
class Squares:
    def __init__(self, start, stop):
        self.start = start
        self.stop = stop
    
    def __iter__(self):
        for value in range(self.start, self.stop + 1):
            yield value ** 2
```

### Multiple Iterator Support
```python
class SkipObject:
    def __init__(self, wrapped):
        self.wrapped = wrapped
    
    def __iter__(self):
        return SkipIterator(self.wrapped)  # New iterator each time

class SkipIterator:
    def __init__(self, wrapped):
        self.wrapped = wrapped
        self.offset = 0
    
    def __next__(self):
        if self.offset >= len(self.wrapped):
            raise StopIteration
        item = self.wrapped[self.offset]
        self.offset += 2
        return item
```

## Membership Testing: `__contains__`, `__iter__`, `__getitem__`

**Priority Order:**
1. `__contains__` (most specific)
2. `__iter__` (general iteration)
3. `__getitem__` (fallback indexing)

```python
class Iters:
    def __init__(self, data):
        self.data = data
    
    def __contains__(self, x):  # Preferred for 'in'
        return x in self.data
    
    def __iter__(self):         # Fallback for 'in'
        return iter(self.data)
    
    def __getitem__(self, i):   # Last resort
        return self.data[i]
```

## Attribute Access

### `__getattr__` - Undefined Attributes Only
```python
class Empty:
    def __getattr__(self, attrname):
        if attrname == 'age':
            return 40
        else:
            raise AttributeError(attrname)
```

### `__setattr__` - All Attribute Assignments
```python
class AccessControl:
    def __setattr__(self, attr, value):
        if attr == 'age':
            self.__dict__[attr] = value + 10  # Avoid recursion!
        else:
            raise AttributeError(attr + ' not allowed')
```

**⚠️ Warning**: `__setattr__` catches ALL attribute assignments, even within the class. Use `self.__dict__[attr] = value` to avoid infinite recursion.

## String Representation

### `__str__` vs `__repr__`
- **`__str__`**: User-friendly display (used by `print()` and `str()`)
- **`__repr__`**: Developer/debug display (used everywhere else)

```python
class Adder:
    def __init__(self, value=0):
        self.data = value
    
    def __str__(self):
        return f'[Value: {self.data}]'    # User-friendly
    
    def __repr__(self):
        return f'Adder({self.data})'      # As-code representation
```

**Usage Priority:**
- `print(x)` and `str(x)` → `__str__` then `__repr__`
- `repr(x)`, interactive echo, nested in containers → `__repr__` only

## Right-Side and In-Place Operations

### Right-Side Operations (`__radd__`)
```python
class Commuter:
    def __init__(self, val):
        self.val = val
    
    def __add__(self, other):      # x + other
        return self.val + other
    
    def __radd__(self, other):     # other + x
        return other + self.val
    
    # Or simply: __radd__ = __add__  # For commutative operations
```

### In-Place Operations (`__iadd__`)
```python
class Number:
    def __init__(self, val):
        self.val = val
    
    def __iadd__(self, other):     # x += other
        self.val += other
        return self                # Must return self!
```

**Fallback**: If `__iadd__` not defined, Python uses `__add__` + assignment.

## Function Calls: `__call__`

Makes instances callable like functions:

```python
class Multiplier:
    def __init__(self, factor):
        self.factor = factor
    
    def __call__(self, value):
        return self.factor * value

double = Multiplier(2)
print(double(5))  # 10
```

**Use Cases:**
- Callback functions with state
- Function-like objects that remember configuration
- Decorators and closures

## Comparison Operations

```python
class Comparable:
    def __init__(self, data):
        self.data = data
    
    def __lt__(self, other):       # 
        return self.data < other.data
    
    def __gt__(self, other):       # >
        return self.data > other.data
    
    def __eq__(self, other):       # ==
        return self.data == other.data
    
    # Note: No automatic relationships between operators!
```

**Important**: Define both `__eq__` and `__ne__` explicitly if needed.

## Boolean Testing: `__bool__` and `__len__`

**Priority Order:**
1. `__bool__()` → direct Boolean value
2. `__len__()` → False if 0, True otherwise
3. Default: True

```python
class Truth:
    def __init__(self, data):
        self.data = data
    
    def __bool__(self):            # Preferred
        return bool(self.data)
    
    def __len__(self):             # Fallback
        return len(self.data)
```

## Object Destruction: `__del__`

```python
class Resource:
    def __init__(self, name):
        self.name = name
        print(f'Creating {name}')
    
    def __del__(self):
        print(f'Destroying {self.name}')
```

**⚠️ Caveats:**
- **Unpredictable timing** - may not run when expected
- **Not always called** - especially at program exit
- **Exception handling** - exceptions just print warnings
- **Circular references** - may prevent garbage collection
- **Generally avoid** - use explicit cleanup methods instead

## Best Practices

### When to Use Operator Overloading
✅ **Use when:**
- Your class naturally represents a mathematical concept
- You want to emulate built-in types (sequences, mappings)
- Operations have clear, intuitive meanings

❌ **Avoid when:**
- Operations don't have natural meanings for your objects
- It would confuse users of your class

### Design Guidelines
1. **Make it intuitive** - operators should do what users expect
2. **Be consistent** - follow patterns of built-in types
3. **Handle edge cases** - consider type checking and error handling
4. **Return appropriate types** - often new instances of your class
5. **Document behavior** - especially for complex operations

### Common Patterns
```python
class Vector:
    def __init__(self, *components):
        self.components = list(components)
    
    def __add__(self, other):
        # Type checking
        if isinstance(other, Vector):
            return Vector(*[a + b for a, b in zip(self.components, other.components)])
        return NotImplemented  # Let Python try other.__radd__
    
    def __repr__(self):
        return f'Vector{tuple(self.components)}'
    
    def __len__(self):
        return len(self.components)
    
    def __getitem__(self, index):
        return self.components[index]
```

## Summary

Operator overloading is a powerful feature that allows your classes to integrate seamlessly with Python's built-in operations. The key is to use it judiciously - implement operators that make intuitive sense for your objects, and always prioritize clarity and consistency over cleverness.

Remember the method naming pattern: `__operation__` for most cases, with special variants like `__roperation__` for right-side operations and `__ioperation__` for in-place operations.