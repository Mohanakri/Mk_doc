# Python OOP: Class Coding Basics - Chapter 27 Notes

## Overview
Classes in Python have three primary distinctions from modules:
1. **Multiple Instance Objects** - Generate multiple objects from one class
2. **Namespace Inheritance** - Support for inheritance hierarchies
3. **Operator Overloading** - Intercept and respond to built-in operations

## Two Types of Objects in Python OOP

### Class Objects
- Provide default behavior
- Created by running `class` statements
- Act as factories for generating instances
- Store shared data and behavior

### Instance Objects
- Concrete items your programs process
- Created by calling a class like a function
- Each has its own namespace but inherits from class
- Store per-instance data that varies per object

## Class Objects Provide Default Behavior

### Key Properties of Python Classes:

**Class Statement Creates Class Object**
```python
class FirstClass:               # Define a class object
    def setdata(self, value):   # Define class's methods
        self.data = value       # self is the instance
    def display(self):
        print(self.data)        # self.data: per instance
```

**Assignments Inside Classes Make Attributes**
- Top-level assignments within class statement generate class attributes
- Class statement defines local scope that becomes attribute namespace
- Access via qualification: `class.name`

**Class Attributes Provide State and Behavior**
- Record state information and behavior shared by all instances
- Function `def` statements nested inside class generate methods

## Instance Objects Are Concrete Items

### Key Points About Instances:

**Calling Class Creates Instance**
```python
x = FirstClass()    # Make two instances
y = FirstClass()    # Each is a new namespace
```

**Instances Inherit Class Attributes**
- Start empty but have links back to class
- Inherit attributes via inheritance search
- Each instance gets its own namespace

**Assignments to `self` Make Per-Instance Attributes**
```python
def setdata(self, value):
    self.data = value    # Creates instance attribute
```

## First Example Walkthrough

```python
>>> class FirstClass:
        def setdata(self, value):
            self.data = value
        def display(self):
            print(self.data)

>>> x = FirstClass()
>>> y = FirstClass()

>>> x.setdata('coding')     # Call methods: self is x
>>> y.setdata(3.14159)      # Runs: FirstClass.setdata(y, 3.14159)

>>> x.display()             # Runs: FirstClass.display(x)
coding
>>> y.display()             # self.data differs in each instance
3.14159
```

### Key Observations:
- Methods called through instances automatically pass instance as first argument
- `self` refers to the instance being processed
- Each instance maintains separate data
- Attributes can be accessed/modified outside class methods

## Classes Are Customized by Inheritance

### Inheritance Concepts:

**Superclasses Listed in Parentheses**
```python
class SecondClass(FirstClass):    # Inherits setdata
    def display(self):            # Changes display
        print(f'Current value = "{self.data}"')
```

**Classes Inherit from Superclasses**
- Subclass inherits all attributes from superclass
- Python finds names automatically if not in subclass

**Instances Inherit from All Accessible Classes**
- Instance → Class → Superclasses (inheritance chain)
- Each attribute reference triggers independent search

**Override vs Inherit**
- Redefining attribute in subclass overrides superclass version
- Unchanged attributes inherited verbatim
- Specialization is external to original class

## Second Example - Inheritance

```python
>>> class SecondClass(FirstClass):
        def display(self):
            print(f'Current value = "{self.data}"')

>>> z = SecondClass()
>>> z.setdata('LP6e')       # Finds setdata in FirstClass
>>> z.display()             # Finds overridden method in SecondClass
Current value = "LP6e"

>>> x.display()             # Original FirstClass instance unchanged
hacking
```

## Classes Are Attributes in Modules

Classes follow normal Python scoping rules:

```python
# Method 1: Import and use directly
from modulename import FirstClass
class SecondClass(FirstClass):
    def display(self): ...

# Method 2: Qualify through module
import modulename
class SecondClass(modulename.FirstClass):
    def display(self): ...
```

### Naming Conventions:
- **Modules**: lowercase (`person.py`)
- **Classes**: uppercase (`Person`)

```python
import person
x = person.Person()    # Module.Class()
```

## Operator Overloading

### Key Concepts:

**Special Methods with Double Underscores**
- Methods named `__X__` are special hooks
- Called automatically when instances appear in built-in operations
- Fixed mapping from operations to method names

**Common Operator Overloading Methods**
- `__init__`: Constructor (object creation)
- `__add__`: Addition operator (`+`)
- `__str__`: String representation (printing)
- `__mul__`: Multiplication operator (`*`)

**Optional Feature**
- No methods required, most have no defaults
- Missing methods mean operation not supported
- Use judiciously - should make sense for your object type

## Third Example - Operator Overloading

```python
>>> class ThirdClass(SecondClass):
        def __init__(self, value):          # On "ThirdClass(value)"
            self.data = value

        def __add__(self, other):           # On "self + other"
            return ThirdClass(self.data + other)

        def __str__(self):                  # On "print(self)", "str()"
            return f'[ThirdClass: {self.data}]'

        def mul(self, other):               # Named method (not operator)
            self.data *= other

>>> a = ThirdClass(3)       # __init__ called
>>> a.display()             # Inherited method
Current value = "3"

>>> b = a + 3               # __add__: makes new instance
>>> b.display()
Current value = "6"

>>> print(b)                # __str__: returns display string
[ThirdClass: 6]

>>> a.mul(3)                # mul: changes instance in place
>>> print(a)
[ThirdClass: 9]
```

### Design Guidelines:
- **Returning Results**: `__add__` creates new instance, maintains object type
- **In-Place Changes**: Named methods like `mul()` modify existing instance
- **Consistency**: Overloaded operators should behave like built-in types

## The World's Simplest Python Class

```python
>>> class rec: pass              # Empty namespace object

>>> rec.name = 'Pat'             # Add attributes after creation
>>> rec.age  = 40

>>> print(rec.name)              # Access like C struct
Pat

>>> x = rec()                    # Create instances
>>> y = rec()

>>> x.name, y.name               # Instances inherit class attributes
('Pat', 'Pat')

>>> x.name = 'Sue'               # Instance assignment affects only that instance
>>> rec.name, x.name, y.name
('Pat', 'Sue', 'Pat')
```

## Classes Under the Hood

### Internal Implementation:
- Attributes stored in `__dict__` dictionaries
- Inheritance trees are linked dictionaries
- Each object has its own namespace dictionary

```python
>>> list(key for key in rec.__dict__ if not key.startswith('__'))
['name', 'age']

>>> list(x.__dict__)
['name']
>>> list(y.__dict__)
[]

>>> x.__class__                   # Instance-to-class link
<class '__main__.rec'>

>>> rec.__bases__                 # Class-to-superclasses link
(<class 'object',)
```

### Attribute Access:
- **Attribute notation**: Triggers inheritance search (`x.name`)
- **Dictionary indexing**: Looks in single object only (`x.__dict__['name']`)
- **`dir()` function**: Collects all inherited names

### Dynamic Nature:
- Classes and instances are just linked namespace objects
- Attributes created on the fly by assignment
- Methods can be added dynamically:

```python
>>> def uppername(obj):
        return obj.name.upper()

>>> rec.method = uppername        # Now it's a class method!
>>> x.method()                    # Call through instance
'SUE'
```

## Records: Classes vs Dictionaries

### Dictionary-Based Records:
```python
>>> rec = {}
>>> rec['name'] = 'Pat'
>>> rec['age'] = 40.5
>>> rec['jobs'] = ['dev', 'mgr']
>>> print(rec['name'])
Pat
```

### Class-Based Records:
```python
# Simple class record
>>> class rec: pass
>>> rec.name = 'Pat'
>>> rec.age = 40.5
>>> rec.jobs = ['dev', 'mgr']
>>> print(rec.name)
Pat

# Instance-based records
>>> class rec: pass
>>> pers1 = rec()
>>> pers1.name = 'Bob'
>>> pers1.jobs = ['dev', 'mgr']
>>> pers1.age = 40.5

# Full-featured class with methods
>>> class Person:
        def __init__(self, name, jobs, age=None):
            self.name = name
            self.jobs = jobs
            self.age = age
        def info(self):
            return (self.name, self.jobs)

>>> rec1 = Person('Bob', ['dev', 'mgr'], 40.5)
>>> rec2 = Person('Sue', ['dev', 'cto'])
>>> rec1.jobs, rec2.info()
(['dev', 'mgr'], ('Sue', ['dev', 'cto']))
```

### Advantages of Classes:
- Less syntax than dictionaries
- Can combine data and logic (methods)
- Support inheritance for customization
- More structured than simple functions in dictionaries

## Key Takeaways

### Three Essential OOP Concepts:
1. **`self` argument**: Automatic instance argument in methods
2. **Inheritance search**: Automatic attribute lookup in class tree
3. **`__init__` constructor**: Common method for instance initialization

### Class vs Module Comparison:
- **Classes**: Statements within files, support multiple instances and inheritance
- **Modules**: Entire files, single instance per import, flat namespace

### When to Use Classes:
- Need multiple similar objects with different data
- Want to package data with related processing logic
- Benefit from inheritance and customization
- Need to mimic built-in type interfaces

### Best Practices:
- Use `__init__` to initialize instance attributes consistently
- Follow naming conventions (uppercase class names)
- Use operator overloading judiciously
- Prefer explicit named methods over operators when clarity is important