# Chapter 28: A More Realistic Example - Class Notes

## Overview
This chapter builds a realistic class-based system for recording and processing information about people, demonstrating all major OOP concepts in Python through incremental development.

## Classes Built
- **Person**: Creates and processes information about people
- **Manager**: A customization of Person that modifies inherited behavior

## Step-by-Step Development

### Step 1: Making Instances

#### Basic Class Structure
```python
class Person:                             # Start a class
```

#### Adding Constructor
```python
class Person:
    def __init__(self, name, job, pay):      # Constructor takes three arguments
        self.name = name                     # Fill out fields when created
        self.job  = job                      # self is the new instance object
        self.pay  = pay
```

#### Adding Default Arguments
```python
class Person:
    def __init__(self, name, job=None, pay=0):         # Normal function args
        self.name = name
        self.job  = job
        self.pay  = pay
```

#### Key Concepts
- **Instance attributes**: Created by assignment to `self` in `__init__`
- **State information**: Descriptive data saved on an object for later use
- **Default arguments**: Make parameters optional with fallback values
- **Independent namespaces**: Each instance has its own copy of attributes

#### Testing Strategy
- Use `if __name__ == '__main__':` to separate test code from importable code
- Prevents test output when module is imported
- Allows same file to work as both script and library

### Step 2: Adding Behavior Methods

#### Encapsulation Principle
- **Problem**: Hardcoding operations outside the class leads to maintenance issues
- **Solution**: Wrap operations in methods for single-point-of-change

#### Method Implementation
```python
def lastName(self):                               # Behavior methods
    return self.name.split()[-1]                  # self is implied subject

def giveRaise(self, percent):
    self.pay = int(self.pay * (1 + percent))      # Must change here only
```

#### Benefits of Methods
- **Code reuse**: Methods work on any instance of the class
- **Maintenance**: Logic exists in only one place
- **Encapsulation**: Implementation details hidden behind interface

### Step 3: Operator Overloading

#### Display Problem
- Default object display shows class name and memory address (not useful)
- Need custom display format

#### Solution: `__repr__` Method
```python
def __repr__(self):                                      
    return f'[Person: {self.name} ${self.pay:,}]'        # String to print
```

#### Key Points
- `__repr__` runs automatically when object is printed
- `__str__` vs `__repr__`: `__repr__` used as fallback and in all contexts
- Uses f-string formatting for readable output

### Step 4: Customizing Behavior by Subclassing

#### Inheritance Basics
```python
class Manager(Person):                          # Define a subclass of Person
```

#### Method Customization - Two Approaches

**Bad Way: Copy and Paste**
```python
class Manager(Person):
    def giveRaise(self, percent, bonus=.10):
        self.pay = int(self.pay * (1 + percent + bonus))   # Bad: cut and paste
```

**Good Way: Augment Original**
```python
class Manager(Person):
    def giveRaise(self, percent, bonus=.10):
        Person.giveRaise(self, percent + bonus)            # Good: augment original
```

#### Why Good Way is Better
- **Single point of change**: Logic exists in one place only
- **Maintenance**: Changes to base class automatically inherited
- **Intent**: Code clearly shows augmentation rather than replacement

#### Method Call Mechanics
- `instance.method(args)` â†’ `class.method(instance, args)`
- Calling through class bypasses inheritance search
- Must pass `self` explicitly when calling through class

#### Alternative: `super()` Built-in
```python
super().giveRaise(percent + bonus)          # Alternative to explicit class call
```
- More generic but has complexity issues
- Book recommends explicit class names for clarity

### Step 5: Customizing Constructors

#### Problem
- Having to specify 'mgr' job for Manager objects is redundant
- Job type is implied by class itself

#### Solution: Custom `__init__`
```python
class Manager(Person):
    def __init__(self, name, pay):                     # Redefine constructor
        Person.__init__(self, name, 'mgr', pay)        # Run original with 'mgr'
```

#### Constructor Inheritance Rules
- Python calls only the lowest `__init__` in the class tree
- Must manually call superclass constructors if needed
- Very common pattern in Python OOP

### Step 6: Using Introspection Tools

#### Problems with Current Display
1. Objects show as base class name (Person) instead of actual class (Manager)
2. Display format hardcoded - doesn't adapt to new attributes

#### Introspection Solutions

**Class Name Access**
```python
instance.__class__.__name__  # Gets actual class name
```

**Attribute Dictionary**
```python
instance.__dict__  # Dictionary of all instance attributes
```

#### Generic Display Tool
```python
class AttrDisplay:
    def gatherAttrs(self):
        attrs = []
        for key in sorted(self.__dict__):
            attrs.append(f'{key}={getattr(self, key)}')
        return ', '.join(attrs)

    def __repr__(self):
        return f'[{self.__class__.__name__}: {self.gatherAttrs()}]'
```

#### Benefits
- **Generic**: Works with any class
- **Adaptive**: Automatically includes new attributes
- **Reusable**: Mix into any class via inheritance
- **Future-proof**: Changes in one place affect all users

#### Design Considerations
- **Name collisions**: Tool class methods might conflict with client class methods
- **Solutions**: 
  - Single underscore prefix (`_gatherAttrs`) for internal methods
  - Double underscore prefix (`__gatherAttrs`) for pseudo-private methods

### Step 7: Storing Objects in a Database

#### Object Persistence Modules
- **pickle**: Serializes Python objects to/from byte strings
- **dbm**: Provides access-by-key filesystem for strings
- **shelve**: Combines pickle and dbm to store Python objects by key

#### Creating Database
```python
import shelve
db = shelve.open('persondb')                     # Filename where objects are stored
for obj in (bob, sue, pat):                      # Use object's name attr as key
    db[obj.name] = obj                           # Store object in shelf by key
db.close()                                       # Close after making changes
```

#### Loading from Database
```python
db = shelve.open('persondb')
pat = db['Pat Jones']                        # Fetch object by key
pat.lastName()                               # Methods work automatically
```

#### How Persistence Works
- **Storing**: pickle records instance attributes + class/module names
- **Loading**: Python automatically reimports class and recreates instance
- **Behavior**: Methods work automatically when objects are loaded
- **Requirements**: Class files must be importable when loading

#### Updating Objects
```python
sue = db['Sue Jones']                      # Fetch object
sue.giveRaise(.10)                         # Modify in memory
db['Sue Jones'] = sue                      # Store back to shelf
```

## Key OOP Concepts Demonstrated

### Encapsulation
- Wrapping data and behavior together in classes
- Hiding implementation details behind methods
- Single point of change for maintenance

### Inheritance
- Code reuse through class hierarchies
- Method customization in subclasses
- Constructor chaining

### Polymorphism
- Same method name behaves differently on different objects
- Dynamic method dispatch based on object type

### Composition vs Inheritance
- **Inheritance**: "is-a" relationship, customization
- **Composition**: "has-a" relationship, aggregation
- Example: Department class aggregating Person objects

## Design Patterns Introduced

### Template Method Pattern
- Superclass defines algorithm structure
- Subclasses customize specific steps
- Example: `giveRaise` customization in Manager

### Factory Pattern
- Classes serve as object factories
- Create multiple instances with shared behavior
- Each instance maintains independent state

### Delegation Pattern
- Object forwards method calls to embedded objects
- Alternative to inheritance for some scenarios
- More complex but provides different relationship model

## Best Practices Learned

### Code Organization
- Use `if __name__ == '__main__':` for test code
- Separate reusable classes into importable modules
- Add docstrings for documentation

### Method Design
- Encapsulate operations in methods rather than external code
- Call superclass methods rather than copying code
- Use introspection for generic, adaptive code

### Class Design
- Inherit from general-purpose tools when appropriate
- Use composition for aggregation scenarios
- Consider name collision issues in mix-in classes

### Testing Strategy
- Test incrementally as you build
- Use interactive prompt for exploration
- Write persistent test scripts for repeated use

## Future Directions
- GUI interfaces for user-friendly access
- More sophisticated database backends (sqlite3)
- Web interfaces and REST APIs
- Enhanced validation and error handling
- Additional business logic and methods

## Summary
This chapter demonstrates that Python's OOP system, while having detailed syntax, is fundamentally based on simple concepts:
1. Attribute search in object trees
2. Special `self` argument in methods  
3. Operator overloading for built-in operations

The example shows how classes provide structure for building maintainable, extensible software through inheritance, encapsulation, and polymorphism.