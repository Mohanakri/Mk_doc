# Python OOP Class Coding Details - Chapter 29 Notes

## The `class` Statement

### Key Characteristics
- **Not a declaration** - Unlike C++, Python's `class` is an object builder and implicit assignment
- **Executable code** - Class doesn't exist until Python reaches and runs the class statement
- **Object builder** - Generates a class object and stores reference in the header name

### General Syntax
```python
class name(superclass,...):     # Assign to name
    attr = value                # Shared class data
    def method(self,...):       # Methods
        self.attr = value       # Per-instance data

x = name(...)                   # Make an instance
x.method(...)                   # Call a method
```

## Class Attributes

### Shared Data Attributes
- Assignments at top level of class statement create **class attributes**
- Class attributes are **shared by all instances** via inheritance
- Can be accessed through class name or instances

```python
class SharedData:
    attr = 16          # Class data attribute

x = SharedData()
y = SharedData()
x.attr, y.attr         # Both return (16, 16)
```

### Instance vs Class Attributes
- **Assignment to instance** (`x.attr = 64`) creates/changes instance attribute
- **Assignment to class** (`SharedData.attr = 32`) changes class attribute
- Instance attributes **hide** class attributes of same name
- Inheritance searches occur only on **attribute references**, not assignments

## Methods

### Method Mechanics
- Methods are **function objects** created by `def` statements in class body
- **Automatic instance passing**: `instance.method(args)` → `class.method(instance, args)`
- **`self` parameter** - First argument receives the instance object
- `self` is **always explicit** in Python code

### Method Call Forms
```python
# Through instance (automatic self)
x.method('arg')

# Through class (manual self)
Class.method(x, 'arg')
```

## Inheritance

### Attribute Tree Construction
- **Instance attributes**: Created by assignments to `self` in methods
- **Class attributes**: Created by statements in class body
- **Superclass links**: Made by listing classes in parentheses in class header

### Inheritance Search Process
1. Start with instance object
2. Search up to class
3. Search superclasses (left to right)
4. Continue up inheritance tree

### Specializing Inherited Methods

#### Complete Replacement
```python
class Replacer(Super):
    def method(self):
        print('in Replacer.method')
```

#### Extension (calling superclass)
```python
class Extender(Super):
    def method(self):
        print('starting Extender.method')
        Super.method(self)           # Call superclass method
        print('ending Extender.method')
```

#### Constructor Chaining
```python
class Sub(Super):
    def __init__(self, x, y):
        Super.__init__(self, x)      # Call superclass constructor
        print('custom code')         # Additional initialization
```

## Class Interface Techniques

### Common Patterns
- **Inheritor**: Gets everything from superclass unchanged
- **Replacer**: Overrides superclass methods completely
- **Extender**: Customizes by calling back to superclass
- **Provider**: Implements expected methods for abstract superclass

### Abstract Superclasses
- Classes that expect subclasses to provide certain methods
- Can use `assert` or `NotImplementedError` to enforce requirements

```python
class Super:
    def delegate(self):
        self.action()
    def action(self):
        raise NotImplementedError('action must be defined!')
```

## Namespaces and Scopes

### Name Resolution Rules

#### Unqualified Names (X)
- Follow **LEGB rule**: Local → Enclosing → Global → Built-in
- **Assignment** makes names local by default
- **Reference** searches LEGB scope chain

#### Qualified Names (object.X)
- Use **object namespaces**
- **Assignment** (`object.X = value`) - creates/changes attribute in that object only
- **Reference** (`object.X`) - searches inheritance tree for class-based objects

### The "Zen" of Namespaces
> **The place where you assign a name determines its scope/object**

### Nested Classes and LEGB
- Classes are local scopes with access to enclosing function scopes
- Classes do **not** serve as enclosing scopes to nested code
- Method functions skip enclosing class in name lookup
- Must use `self.X` to access class attributes from methods

## Namespace Dictionaries

### Implementation Details
- Instances and classes are mostly dictionaries with links
- **`__dict__`** attribute exposes namespace dictionary
- **`__class__`** (instance) links to class
- **`__bases__`** (class) tuple of superclasses

### Dictionary Equivalence
```python
X.data1                    # Attribute access
X.__dict__['data1']        # Dictionary access (instance attrs only)
```

## Documentation Strings

### Locations for Docstrings
- **Module level**: First string in file
- **Function level**: First string in `def`
- **Class level**: First string in `class`
- **Method level**: First string in method `def`

### Access at Runtime
```python
object.__doc__    # Access docstring
help(object)      # Formatted documentation
```

## Classes vs Modules

| Aspect | Modules | Classes |
|--------|---------|---------|
| **Purpose** | Data + logic packages | New full-featured objects |
| **Creation** | Python files/extensions | `class` statements |
| **Usage** | Imported | Called to create instances |
| **Structure** | Top level in programs | Always live within modules |
| **Features** | Basic namespaces | + operator overloading, inheritance, multiple instances |

## Key Takeaways

1. **Assignment location determines scope** - fundamental principle
2. **Inheritance = namespace tree search** from bottom to top
3. **Methods are functions** with automatic instance passing
4. **Class attributes are shared**, instance attributes are per-object
5. **Explicit `self`** makes instance attribute access obvious
6. **Abstract superclasses** define interfaces for subclasses
7. **Namespaces are dictionaries** with inheritance links