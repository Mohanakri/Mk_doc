# Chapter 31: Designing with Classes - Notes

## Python OOP Core Concepts

### Three Pillars of Python OOP
1. **Inheritance** - Based on attribute lookup in `X.name` expressions
2. **Polymorphism** - Meaning of `X.method` depends on the type of object X
3. **Encapsulation** - Methods implement behavior; data hiding is convention-based

### Key Points on Polymorphism
- Python polymorphism is based on **interfaces**, not call signatures
- No real type declarations means no function overloading by argument types
- Should write code expecting object interfaces, not specific types
- Use distinct method names rather than relying on call signatures

## Design Patterns

### 1. Inheritance: "Is-a" Relationships

```python
class Employee:
    def __init__(self, name, salary=0):
        self.name = name
        self.salary = salary
    
    def giveRaise(self, percent):
        self.salary += self.salary * percent

class Chef(Employee):
    def __init__(self, name):
        Employee.__init__(self, name, 50000)

class PizzaRobot(Chef):
    def __init__(self, name):
        Chef.__init__(self, name)
```

**Key Characteristics:**
- Models "is-a" relationships (PizzaRobot **is a** Chef)
- Enables code reuse and customization
- Supports polymorphic behavior

### 2. Composition: "Has-a" Relationships

```python
class PizzaShop:
    def __init__(self):
        self.server = Server('Jan')      # Has a server
        self.chef = PizzaRobot('Pat')    # Has a chef
        self.oven = Oven()               # Has an oven
```

**Key Characteristics:**
- Models "has-a" relationships (PizzaShop **has a** server)
- Embeds objects to implement container methods
- Container provides unified interface
- Complementary to inheritance

### 3. Delegation: "Like-a" Relationships

```python
class Wrapper:
    def __init__(self, object):
        self.wrapped = object
    
    def __getattr__(self, attrname):
        print('Trace: ' + attrname)
        return getattr(self.wrapped, attrname)
```

**Key Characteristics:**
- Uses `__getattr__` to route attribute access
- Proxy pattern - wrapper retains interface of wrapped object
- Allows adding behavior without modifying original object
- **Limitation**: Cannot intercept built-in operations directly

## Advanced Class Features

### Pseudoprivate Attributes

**Name Mangling Rules:**
- Names starting with `__` but not ending with `__` are mangled
- `__X` in class `Hack` becomes `_Hack__X`
- Applies to both class and instance attributes

**Use Cases:**
- Avoid namespace collisions in multiple inheritance
- Prevent accidental method override in class hierarchies
- Not true privacy - still accessible with full name

```python
class C1:
    def meth1(self): self.__X = 88    # Becomes _C1__X

class C2:
    def metha(self): self.__X = 99    # Becomes _C2__X
```

### Bound Methods

**Two Types of Method Objects:**
1. **Bound Methods** - Accessed through instance (`instance.method`)
   - Automatically packages instance with function
   - No need to pass `self` explicitly

2. **Plain Functions** - Accessed through class (`Class.method`)
   - Must pass instance explicitly when calling

```python
class Number:
    def double(self):
        return self.base * 2

x = Number()
meth = x.double      # Bound method
meth()               # No self needed

meth = Number.double # Plain function  
meth(x)              # Must pass self
```

### Generic Object Factories

```python
def factory(aClass, *pargs, **kargs):
    return aClass(*pargs, **kargs)

# Usage
obj1 = factory(Person, 'Sue', 'dev')
obj2 = factory(Person, name='Bob')
```

## Multiple Inheritance and MRO

### Multiple Inheritance Basics
```python
class A(B, C):  # Inherits from both B and C
    pass
```

### Method Resolution Order (MRO)

**DFLR vs MRO:**
- **DFLR**: Depth First, Left to Right (simple case)
- **MRO**: Method Resolution Order (handles diamonds)

**MRO Algorithm:**
1. List all classes using DFLR order
2. Remove all but rightmost occurrence of duplicates
3. Result: each class appears before its parents

**Diamond Pattern Example:**
```python
class D:       attr = 'D'
class C(D):    attr = 'C'  
class B(D):    pass
class A(B, C): pass

# MRO: [A, B, C, D, object]
# C.attr wins over D.attr due to MRO
```

### Conflict Resolution
- **Default**: First occurrence in MRO wins
- **Explicit**: Use class names to override
```python
class A(B, C): 
    attr = B.attr    # Explicit choice
    
def method(self):
    B.method(self)   # Explicit method call
```

## Mix-in Classes

### Purpose
- Provide reusable method packages
- Similar to modules but participate in inheritance
- Access to `self` for state and other methods

### Example: Attribute Listers

**1. List Instance Attributes:**
```python
class ListInstance:
    def __str__(self):
        result = f'<Instance of {self.__class__.__name__}:\n'
        for attr in sorted(self.__dict__):
            result += f'\t{attr}={self.__dict__[attr]!r}\n'
        return result + '>'
```

**2. List Inherited Attributes:**
```python
class ListInherited:
    def __str__(self):
        result = f'<Instance of {self.__class__.__name__}:\n'
        for attr in dir(self):
            if not (attr.startswith('__') and attr.endswith('__')):
                result += f'\t{attr}={getattr(self, attr)!r}\n'
        return result + '>'
```

**3. List Class Tree:**
```python
class ListTree:
    def __str__(self):
        # Recursively traverses class hierarchy
        # Shows attributes grouped by class
```

### Mix-in Usage
```python
class MyClass(ListInstance, OtherClass):
    pass

# Gets custom __str__ from ListInstance
# Plus all functionality from OtherClass
```

## Best Practices

### Design Guidelines
1. **Inheritance**: Use for "is-a" relationships and code reuse
2. **Composition**: Use for "has-a" relationships and building complex objects
3. **Delegation**: Use for wrapping and extending existing objects
4. **Multiple Inheritance**: Use for mix-ins and combining disparate functionality

### Naming Conventions
- **Public**: `name` - accessible everywhere
- **Internal**: `_name` - convention only, still accessible
- **Pseudoprivate**: `__name` - name mangled to avoid conflicts

### Method Resolution
- Understand MRO for multiple inheritance
- Use explicit class names when default resolution isn't desired
- Check `Class.__mro__` to see resolution order

### Tool Development
- Use pseudoprivate names to avoid conflicts
- Make classes generic and reusable
- Consider bound methods for callbacks
- Factory patterns for dynamic object creation

## Common Gotchas

1. **Delegation Limitation**: `__getattr__` doesn't catch built-in operations
2. **__repr__ Loops**: Use `__str__` for complex displays to avoid recursion
3. **MRO Complexity**: Diamond patterns can produce unexpected attribute resolution
4. **Method vs Function**: Bound methods remember instance, plain functions don't
5. **Pseudoprivate Scope**: Only works within class definition, not true privacy