# Chapter 26: OOP - The Big Picture - Study Notes

## Introduction to Object-Oriented Programming (OOP)

### What is OOP?
- **Object-based vs Object-oriented**: Previous code was object-based (using objects), but true OOP requires **inheritance hierarchy**
- **Classes**: Python's main OOP tool - coding structures that implement new kinds of objects supporting inheritance
- **Optional**: OOP is entirely optional in Python; can accomplish tasks with functions or simple scripts
- **Strategic vs Tactical**: More useful for strategic mode (long-term development) than tactical mode (time-constrained)

## Why Use Classes?

### Two Key OOP Concepts

#### 1. Inheritance
- Objects inherit properties from general categories
- Common properties implemented once and reused
- Example: Pizza-making robots inherit from general robot properties

#### 2. Composition
- Objects are collections of components working together
- Example: Robot contains arms, motors, etc. as separate objects

### Three Critical Distinctions of Classes

#### 1. Multiple Instances
- Classes are **factories** for generating objects
- Each object gets distinct namespace
- Similar to closure functions but more complete

#### 2. Customization via Inheritance
- Extend classes by redefining attributes in subclasses
- Build namespace hierarchies
- Support multiple customizable behaviors

#### 3. Operator Overloading
- Special protocol methods allow objects to respond to built-in operations
- Objects can be sliced, concatenated, indexed, etc.

## Core OOP Mechanism

### The Magic Formula
```python
object.attribute
```

**Key principle**: "Find the first occurrence of attribute by looking in object, then in all classes above it, from bottom to top and left to right"

### Inheritance Search Tree
- **Classes**: Serve as instance factories (ovals in diagrams)
  - Provide behavior (data and functions)
  - Inherited by all instances
- **Instances**: Represent concrete items (rectangles in diagrams)
  - Record data varying per specific object

### Tree Terminology
- **Superclasses**: Classes higher in tree (provide shared behavior)
- **Subclasses**: Classes lower in tree (can override superclass behavior)

## Method Calls and the `self` Parameter

### Method Call Translation
```python
I2.w()  # Translates to: C3.w(I2)
```

### Key Method Concepts
- Instance automatically passed as first argument (`self`)
- `self` is the implied subject of the call
- Two calling forms:
  - Through instance: `pat.giveRaise()`
  - Through class: `Employee.giveRaise(pat)`

## Coding Class Trees

### Basic Syntax
```python
class C2: ...                # Make class objects
class C3: ...
class C1(C2, C3): ...        # Multiple inheritance

I1 = C1()                    # Make instance objects
I2 = C1()                    # Each gets distinct namespace
```

### Attribute Assignment Rules
- **Class attributes**: Assigned at top level in class statement blocks
- **Instance attributes**: Assigned to `self` in methods

### Example with Methods
```python
class C1(C2, C3):
    def setname(self, who):      # Method definition
        self.name = who          # Instance attribute assignment

I1 = C1()
I1.setname('sue')               # Method call
```

## Operator Overloading

### Constructor Method (`__init__`)
```python
class C1(C2, C3):
    def __init__(self, who):     # Called automatically
        self.name = who          # Initialize instance

I1 = C1('sue')                   # Passes 'sue' to __init__
```

### Key Points
- **Double underscores**: Mark special methods (`__init__`, `__and__`, etc.)
- **Automatic execution**: Python calls them during corresponding operations
- **Optional**: If omitted, operations not supported
- **Most common**: `__init__` appears in most realistic classes

## Code Reuse and Polymorphism

### The Core Benefit
- **Customization over modification**: Extend existing code rather than changing it
- **Natural software extension**: Add new behaviors without breaking existing code

### Polymorphism Example
```python
class Employee:
    def computeSalary(self): ...    # Default behavior

class Engineer(Employee):
    def computeSalary(self): ...    # Custom behavior

# Usage
company = [Employee(), Engineer()]
for emp in company:
    emp.computeSalary()             # Calls appropriate version
```

### Programming by Customization
- **Frameworks**: Collections of superclasses for common tasks
- **Mix and match**: Combine existing classes for new applications
- **Design patterns**: Cataloged OOP structures for common problems

## Key Takeaways

### OOP Essence
1. **Special first argument** (`self`) in functions
2. **Inheritance attribute search** in object trees
3. **Code reuse** through customization rather than modification

### Benefits
- Reduces development time
- Enables software reuse
- Provides natural structure for code organization
- Supports debugging through localized logic

### Remember
- OOP in Python is simpler than in languages like C++ or Java
- Dynamic typing removes much syntactic complexity
- Core concept: looking up names in object trees with special function arguments

## Quiz Answers Summary

1. **Main point**: Code reuse through customization
2. **Inheritance search**: Instance → class → superclasses (bottom-up, left-right)
3. **Class vs Instance**: Classes are factories, instances are products
4. **First argument**: Always receives the instance (subject of method call)
5. **`__init__` purpose**: Constructor method for initialization
6. **Create instance**: Call class name like a function
7. **Create class**: Use `class` statement
8. **Specify superclasses**: List in parentheses after class name