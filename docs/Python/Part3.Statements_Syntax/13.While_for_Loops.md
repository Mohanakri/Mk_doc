# Chapter 13: while and for Loops

## Overview

Python provides two main looping constructs for repetitive tasks:

- **`while/else`**: Most general looping statement for all kinds of repetitive tasks
- **`for/else`**: Specialized loop for stepping through items in any "iterable" object

## while Loops

### General Format

```python
while test:                  # Loop test
    statements               # Repeated loop body
else:                        # Optional else
    statements               # Run if didn't exit loop body with break
```

### Key Characteristics

- Repeatedly executes associated block while test is true
- Called a "loop" because control keeps looping back to start
- If test is false initially, body never runs
- Loop continues until test becomes false

### Examples

#### Infinite Loop
```python
while True:
    print('Type Ctrl+C to stop me!')
```

#### String Processing
```python
x = 'code'
while x:                  # While x is not empty
    print(x, end=' ')     # Print current string
    x = x[1:]             # Strip first character off x
# Output: code ode de e
```

#### Counter Loop
```python
a = 0
b = 10
while a < b:              # One way to code counter loops
    print(a, end=' ')
    a += 1                # Or, a = a + 1
# Output: 0 1 2 3 4 5 6 7 8 9
```

#### Simulating "do until" Loop
```python
while True:
    # loop body               # Always run loop body at least once
    if test: break            # Test for loop exit at the bottom
```

## Loop Control Statements

### break, continue, pass, and Loop else

| Statement | Function |
|-----------|----------|
| `break` | Jumps out of the closest enclosing loop |
| `continue` | Jumps to the top of the closest enclosing loop |
| `pass` | Does nothing - empty statement placeholder |
| Loop `else` | Runs if loop exits normally (without `break`) |

### General Loop Format with Control Statements

```python
while test:
    statements
    if test: break              # Exit loop now, skip else if present
    if test: continue           # Go to test at top of loop now
else:
    statements                  # Run on exit if didn't hit 'break'
```

### pass Statement

```python
# Empty loop
while True: pass                   # Type Ctrl+C to stop me!

# Placeholder for future code
def func1():
    pass                 # Add real code here later

# Alternative using ellipsis
def func1():
    ...                   # Alternative to pass
```

### continue Statement

```python
x = 10
while x:
    x -= 1                         # Or, x = x - 1
    if x % 2 != 0: continue        # Odd? -- skip print
    print(x, end=' ')
# Output: 8 6 4 2 0
```

### break Statement

```python
num = 1
while True:
    tool = input(f'{num}) What\'s your favorite language? ')
    if tool == 'stop': break
    print('Bravo!' if tool == 'Python' else 'Try again...')
    num += 1
```

### Loop else Clause

The `else` clause runs only if the loop exits normally (not via `break`):

```python
# Prime number checker
x = num // 2                              # For some num > 1
while x > 1:
    if num % x == 0:                      # Factor found
        print(num, 'has factor', x)
        break                             # Exit and skip else
    x -= 1
else:                                     # Normal exit
    print(num, 'is prime')
```

## for Loops

### General Format

```python
for target in object:           # Assign object items to target
    statements                  # Repeated loop body: use target
else:                           # Optional else
    statements                  # Run if didn't exit loop body with break
```

### Complete Format with Control Statements

```python
for target in object:           # Assign object items to target
    statements
    if test: break              # Exit loop now, skip else
    if test: continue           # Go to top of loop now
else:
    statements                  # Run on exit if didn't hit 'break'
```

### Basic Examples

#### Iterating Over Lists
```python
for x in ['app', 'script', 'program']:
    print(x, end=' ')
# Output: app script program
```

#### Sum and Product
```python
# Sum
sum = 0
for x in [1, 2, 3, 4]:
    sum = sum + x
print(sum)  # Output: 10

# Product
prod = 1
for item in [1, 2, 3, 4]: 
    prod *= item
print(prod)  # Output: 24
```

#### Other Data Types
```python
# Strings
S = 'Python'
for x in S: 
    print(x, end=' ')
# Output: P y t h o n

# Tuples
T = ('web', 'num', 'app')
for x in T: 
    print(x, end=' ')
# Output: web num app
```

### Tuple Assignment in for Loops

```python
T = [(1, 2), (3, 4), (5, 6)]
for (a, b) in T:                   # Tuple assignment
    print(a, b)
# Output:
# 1 2
# 3 4
# 5 6

# Alternative syntax
for [a, b] in T:                   # List assignment: same effect
for a, b in T:                     # Tuple sans parentheses: same effect
```

#### Dictionary Iteration
```python
D = {'a': 1, 'b': 2}

# Method 1: Keys only
for key in D:
    print(key, '=>', D[key])

# Method 2: Keys and values
for (key, value) in D.items():
    print(key, '=>', value)
```

### Extended Unpacking in for Loops

```python
# Basic extended unpacking
for (a, *b, c) in [(1, 2, 3, 4), (5, 6, 7, 8)]:
    print(a, b, c)
# Output:
# 1 [2, 3] 4
# 5 [6, 7] 8
```

### Nested for Loops

```python
# Simple nesting
for x in 'abc':
    for y in '123':
        print(x + y, end=' ')
# Output: a1 a2 a3 b1 b2 b3 c1 c2 c3

# Search with nested loops and else
items = ['aaa', 111, (4, 5), 2.01]
tests = [(4, 5), 3.14]

for key in tests:                       # For all keys
    for item in items:                  # For all items
        if item == key:                 # Check for match
            print(key, 'was found')
            break
    else:
        print(key, 'not found!')
```

## Loop Coding Techniques

### Counter Loops: range

The `range()` function generates sequences of integers:

```python
# Basic range usage
list(range(5))              # [0, 1, 2, 3, 4]
list(range(2, 5))           # [2, 3, 4]
list(range(0, 10, 2))       # [0, 2, 4, 6, 8]

# Negative ranges
list(range(-5, 5))          # [-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]
list(range(5, -5, -1))      # [5, 4, 3, 2, 1, 0, -1, -2, -3, -4]
```

#### Using range in Loops

```python
# Repeat action specific number of times
for i in range(3):
    print(i, 'Pythons')

# Manual indexing (generally not recommended)
X = 'hack'
for i in range(len(X)): 
    print(X[i], end=' ')
# Output: h a c k
```

### Sequence Scans: Best Practices

```python
X = 'hack'

# BEST: Automatic iteration
for item in X: 
    print(item, end=' ')

# OKAY: Manual while loop
i = 0
while i < len(X):
    print(X[i], end=' ')
    i += 1

# AVOID: Manual range/len iteration (unless needed)
for i in range(len(X)): 
    print(X[i], end=' ')
```

### Changing Lists During Iteration

```python
L = [10, 20, 30, 40, 50]

# WRONG: This doesn't change the list
for x in L:
    x += 1                       # Changes x, not L!

# CORRECT: Use indexing
for i in range(len(L)):
    L[i] += 1                    # Changes L[i]

# BETTER: Use list comprehension (creates new list)
L = [x + 1 for x in L]
```

### Parallel Traversals: zip

The `zip()` function combines multiple sequences:

```python
L1 = [1, 2, 3, 4]
L2 = [5, 6, 7, 8]

# Basic zip usage
list(zip(L1, L2))                       # [(1, 5), (2, 6), (3, 7), (4, 8)]

# Parallel iteration
for (x, y) in zip(L1, L2):
    print(f'{x} + {y} => {x + y}')
```

#### zip Characteristics

- Accepts any number of arguments
- Truncates at shortest sequence length
- Returns tuples of corresponding elements

```python
# Multiple arguments
T1, T2, T3 = (1, 2, 3), (4, 5, 6), (7, 8, 9)
list(zip(T1, T2, T3))                   # [(1, 4, 7), (2, 5, 8), (3, 6, 9)]

# Truncation at shortest
S1 = 'abc'
S2 = 'xyz123'
list(zip(S1, S2))                       # [('a', 'x'), ('b', 'y'), ('c', 'z')]
```

#### Dictionary Creation with zip

```python
keys = ['app', 'script', 'program']
vals = [1, 3, 5]

# Method 1: Loop
D2 = {}
for (k, v) in zip(keys, vals): 
    D2[k] = v

# Method 2: dict constructor (preferred)
D3 = dict(zip(keys, vals))

# Method 3: Dictionary comprehension
D4 = {k: v for (k, v) in zip(keys, vals)}
```

### Offsets and Items: enumerate

The `enumerate()` function provides both index and value:

```python
S = 'hack'

# Manual counter (avoid)
offset = 0
for item in S:
    print(item, 'appears at offset', offset)
    offset += 1

# Using enumerate (preferred)
for (offset, item) in enumerate(S):
    print(item, 'appears at offset', offset)
```

#### enumerate Examples

```python
# List comprehension with enumerate
S = 'hack'
[c * i for (i, c) in enumerate(S)]      # ['', 'a', 'cc', 'kkk']

# File processing with line numbers
for (ix, line) in enumerate(open('data.txt')):
    print(f'{ix}) {line.rstrip()}')
```

## Summary

### Key Guidelines

1. **Use `for` instead of `while`** when possible for better performance and readability
2. **Don't use `range()` in `for` loops** except as a last resort
3. **Use automatic iteration** (`for item in sequence`) rather than manual indexing
4. **Leverage built-ins** like `zip()` and `enumerate()` for specialized iterations
5. **Use list comprehensions** for creating new lists from existing ones

### Common Patterns

| Task | Best Approach |
|------|---------------|
| Simple iteration | `for item in sequence` |
| Parallel iteration | `for (x, y) in zip(seq1, seq2)` |
| Index + value | `for (i, item) in enumerate(sequence)` |
| Counter loop | `for i in range(n)` |
| Dictionary from lists | `dict(zip(keys, values))` |

### Loop else Usage

The `else` clause is executed when:
- Loop completes normally (no `break`)
- Loop body never executes (empty sequence/false condition)

Common use case: Search operations where `else` handles "not found" scenario.

## File Processing Example

```python
# Read entire file
for line in open('data.txt'):
    print(line.rstrip())

# Read with line numbers
for (ix, line) in enumerate(open('data.txt')):
    print(f'{ix}) {line.rstrip()}')

# Process in blocks
file = open('data.txt')
while chunk := file.read(10):    # Read 10 characters at a time
    print(chunk, end='')
```