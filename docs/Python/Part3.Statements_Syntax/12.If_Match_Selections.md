# Chapter 12: if and match Selections

## Overview

This chapter covers Python's two main selection statements:

- **`if/elif/else`** - The primary selection tool for arbitrary logic
- **`match/case`** - A multiple-choice selection tool with pattern matching (Python 3.10+)

## if Statements

### General Format

```python
if test1:                 # Main if test
    statements1           # Associated block
elif test2:               # Optional elif test(s)
    statements2           # Associated block
else:                     # Optional else default
    statements3           # Associated block
```

### Basic Examples

**Simple if:**
```python
if 1:
    print('true')  # Always executes (1 is truthy)
```

**if-else:**
```python
if not 1:
    print('true')
else:
    print('false')  # This executes
```

**Complete if-elif-else:**
```python
os, mode = 'Windows', 'mobile'

if os in ['iOS', 'iPhoneOS']:
    print('macOS')
elif mode == 'mobile' and os != 'Windows':
    print('Linux')
else:
    print('unknown?')  # This executes
```

### Nested if Statements

```python
if mode == 'mobile':
    if os == 'Android':
        print('Linux')
    elif os != 'Windows':
        print('macOS')
```

## Multiple-Choice Selections

### Dictionary-Based Selection

```python
# Dictionary as a "switch" statement
choice = 'Windows'
result = {'macos': 2001, 'Linux': 1991, 'Windows': 1985}[choice]
print(result)  # 1985
```

**Handling defaults:**
```python
branch = dict(macos=2001, Linux=1991, Windows=1985)

# Using get() method
print(branch.get('Windows', 'Bad choice'))    # 1985
print(branch.get('Solaris', 'Bad choice'))    # Bad choice

# Using membership test
choice = 'AmigaOS'
if choice in branch:
    print(branch[choice])
else:
    print('Bad choice')

# Using try-except
try:
    print(branch[choice])
except KeyError:
    print('Bad choice')
```

**Function tables for complex actions:**
```python
def action(): ...
def default(): ...

branch = {
    'Android':    lambda: ...,    # Inline lambda
    'iOS':        action,         # Function reference
    'Symbian OS': lambda: ...
}

choice = 'Android'
branch.get(choice, default)()     # Fetch and execute function
```

## match Statements (Python 3.10+)

### Basic Usage

```python
# Basic multiple-choice matching
match state:
    case 'go':
        print('green')
    case 'stop':
        print('red')
    case _:                       # Default case
        print('yellow')
```

### Advanced Case Features

```python
match state:
    case 'go' | 'proceed' | 'start':      # Multiple values with |
        print('green')
        print('means go')
    case 'stop' | 'halt' as what:         # Capture matched value
        print('red')
        print('means', what)              # what is available after match
    case other:                           # Variable assignment (always matches)
        print('catchall', other)
```

### Pattern Matching Examples

**Literal and sequence patterns:**
```python
match state:
    case 1 | 2 | 3 as what:              # Literal patterns
        print('or', what)
    
    case [1, 2, what]:                   # Sequence pattern
        print('list', what)
    case [0, *what]:                     # Starred expression
        print('list', what)
    
    case {'a': 1, 'b': 2, 'c': what}:    # Mapping pattern
        print('dict', what)
    case {'a': 0, **what}:               # Double-starred mapping
        print('dict', what)
    
    case _ as what:                      # Wildcard with capture
        print('other', what)
```

**Guard expressions:**
```python
state = ((1, 2), 3)
guard1 = True

match state:
    case ((a, 2), b) if guard1:          # Only matches if guard1 is True
        print(f'case1 {a=} {b=}')
    case (a, 3) as what:
        print(f'case2 {a=} {what=}')
```

## Python Syntax Rules

### Block Delimiters: Indentation

- **All statements at the same indentation level belong to the same block**
- **Nested blocks are indented further to the right**
- **Top-level code starts at column 1**
- **Use consistent indentation (spaces or tabs, not mixed)**

```python
x = 1                    # Block 0 (top-level)
if x:
    y = 2                # Block 1 (4 spaces)
    if y:
        print('block2')  # Block 2 (8 spaces)
    print('block1')      # Back to block 1
print('block0')          # Back to block 0
```

### Statement Delimiters

**Multi-line statements:**
```python
# Using open pairs (preferred)
L = ['app',
     'script',
     'program']

# Using backslash (discouraged)
if a == b and c == d and \
   d == e and f == g:
    print('old school')

# Using parentheses (preferred for expressions)
if (a == b and c == d and
    d == e and e == f):
    print('new school')
```

**Multiple statements on one line:**
```python
x = 1; y = 2; print(x)   # Semicolon-separated (discouraged)
```

**Simple statement on header line:**
```python
if 1: print('hello')     # Only for simple cases
```

## Truth Values and Boolean Operations

### Truth Value Rules

- **Any nonzero number or nonempty object is True**
- **Zero numbers, empty objects, and None are False**
- **Comparisons return True or False**

### Boolean Operators

```python
# and operator - returns first false value or last value
2 and 3     # Returns 3
[] and {}   # Returns []
3 and []    # Returns []

# or operator - returns first true value or last value  
2 or 3      # Returns 2
[] or 3     # Returns 3
[] or {}    # Returns {}

# not operator - returns True or False
not []      # Returns True
not 3       # Returns False
```

### Short-Circuit Evaluation

```python
# or stops at first true value
def func1(): print('func1'); return True
def func2(): print('func2'); return False

result = func1() or func2()  # Only prints 'func1', func2() never called

# and stops at first false value
result = func2() and func1()  # Only prints 'func2', func1() never called
```

## The Ternary if/else Expression

### Basic Form

```python
A = Y if X else Z    # Equivalent to full if-else statement
```

### Examples

```python
tone = 'formal'
a = 'code' if tone == 'formal' else 'hack'  # a = 'code'

tone = 'informal'  
a = 'code' if tone == 'formal' else 'hack'  # a = 'hack'
```

### Alternative with and/or (Less Recommended)

```python
A = Y if X else Z           # Ternary (preferred)
A = ((X and Y) or Z)        # and/or equivalent (works if Y is truthy)
```

## Best Practices

### When to Use Each Approach

| Approach | Best For | Limitations |
|----------|----------|-------------|
| `if/elif/else` | General logic, complex conditions | More verbose |
| Dictionary lookup | Static mappings, known at code time | Less flexible for complex logic |
| `match/case` | Multiple-choice with pattern matching | Limited to Python 3.10+, complex syntax |
| Ternary expression | Simple conditional assignments | Single expressions only |

### Style Guidelines

1. **Use consistent indentation** (4 spaces recommended)
2. **Avoid mixing tabs and spaces**
3. **Keep one statement per line** (except simple cases)
4. **Use parentheses for multi-line expressions** instead of backslashes
5. **Choose readability over brevity**

## Common Patterns

### Default Value Selection

```python
# Select first non-empty value
X = A or B or C or None

# Simple default assignment
X = A or default
```

### Truth Testing

```python
# Test object directly (preferred)
if X:
    print("X has a value")

# Compare to empty value (less Pythonic)
if X != '':
    print("X is not empty")
```

### Safe Function Calls

```python
# Ensure both functions run
tmp1, tmp2 = f1(), f2()
if tmp1 or tmp2:
    # Both f1() and f2() were called
    pass

# vs. short-circuit behavior
if f1() or f2():
    # f2() might not be called if f1() returns True
    pass
```

## Summary

- **`if` statements** are the primary selection tool in Python
- **`match` statements** provide pattern matching for multiple-choice scenarios
- **Dictionary lookups** offer dynamic alternatives to hardcoded logic
- **Ternary expressions** provide concise conditional assignment
- **Boolean operators** return objects, not just True/False
- **Indentation defines code blocks** - no braces needed
- **Truth values** follow intuitive rules: empty/zero = False, everything else = True