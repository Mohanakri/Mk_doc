# Chapter 11: Assignments, Expressions, and Prints

## Overview

This chapter covers three fundamental Python statement types:
- Assignment statements
- Expression statements  
- Print operations

## Assignments

### Key Properties of Assignments

1. **Create object references** - Variables are pointers, not data storage areas
2. **Names created when first assigned** - No need to predeclare variables
3. **Names must be assigned before referenced** - Python raises exception for undefined names
4. **Many operations perform implicit assignments** - imports, function definitions, for loops, etc.

### Assignment Forms

| Operation | Interpretation |
|-----------|----------------|
| `target = 'Hack'` | Basic assignment |
| `code, hack = 'py', 'PY'` | Tuple assignment |
| `[code, hack] = ['py', 'PY']` | List assignment |
| `a, b, c, d = 'hack'` | Sequence assignment |
| `a, *b = 'hack'` | Extended-unpacking assignment |
| `code = hack = 'python'` | Multiple-target assignment |
| `code += 1, hack *= 2` | Augmented assignments |
| `(python := 3.12) + 0.01` | Named assignment expression |

### Basic Assignments

```python
L = [1, 2]             # Name target
L[0] = 3               # Index target
L[-1:] = [4, 5]        # Slice target
object.attr = L        # Attribute target
```

### Sequence Assignments

**Tuple and List Assignment:**
```python
# Tuple assignment
A, B = first, second

# List assignment  
[C, D] = [first, second]

# Mixed types
[a, b, c] = (1, 2, 3)          # Tuple to list
(a, b, c) = 'ABC'              # String to tuple
```

**Common Patterns:**
```python
# Swapping values
first, second = second, first

# Splitting sequences
a, b, c = string[0], string[1], string[2:]
a, b = string[:2]
c = string[2:]

# Nested sequences
(a, b), c = string[:2], string[2:]

# Integer series
red, green, blue = range(3)  # red=0, green=1, blue=2
```

### Extended-Unpacking Assignments

Uses starred target `*X` to collect unmatched items:

```python
seq = [1, 2, 3, 4]

# First and rest
a, *b = seq          # a=1, b=[2,3,4]

# Rest and last  
*a, b = seq          # a=[1,2,3], b=4

# First, middle, last
a, *b, c = seq       # a=1, b=[2,3], c=4

# With strings
a, *b = 'hack'       # a='h', b=['a','c','k']
```

**Boundary Cases:**
```python
# Single item still returns list
a, b, c, *d = seq    # d=[4]

# Empty list if nothing left
a, b, c, d, *e = seq # e=[]
```

### Multiple-Target Assignments

```python
a = b = c = 'code'   # All reference same object
```

!!! warning "Shared References"
    Be careful with mutable objects:
    ```python
    # WRONG - shared reference
    a = b = []
    b.append(42)
    # Result: a=[42], b=[42]
    
    # CORRECT - separate objects  
    a = []
    b = []
    # or
    a, b = [], []
    ```

### Augmented Assignments

| Operator | Example | Equivalent |
|----------|---------|------------|
| `+=` | `x += 1` | `x = x + 1` |
| `-=` | `x -= 1` | `x = x - 1` |
| `*=` | `x *= 2` | `x = x * 2` |
| `/=` | `x /= 2` | `x = x / 2` |
| `//=` | `x //= 2` | `x = x // 2` |
| `%=` | `x %= 3` | `x = x % 3` |
| `**=` | `x **= 2` | `x = x ** 2` |

**Advantages:**
1. Less typing
2. Left side evaluated only once
3. Automatic in-place optimization for mutables

**In-place vs Copy:**
```python
# For lists, += uses extend (in-place)
L += [9, 10]         # Equivalent to L.extend([9, 10])

# But + creates new object
L = L + [9, 10]      # Creates new list

# This matters for shared references
L = [1, 2]
M = L
L += [3, 4]          # M also sees change: [1, 2, 3, 4]

L = [1, 2] 
M = L
L = L + [3, 4]       # M unchanged: [1, 2]
```

### Named Assignment Expressions (`:=`)

Introduced in Python 3.8, allows assignment within expressions:

```python
# Basic usage
a = 'hack' * (b := 2)    # b=2, a='hackhack'

# Common use cases
if line := file.readline():
    print(line)

while line := file.readline():
    print(line)

# Requires parentheses for comparisons
if (line := file.readline()) != ignore:
    print(line)
```

**Limitations:**
- Only simple names allowed (no `x[0] := value`)
- No augmented forms (no `:+=`)
- Often requires parentheses

## Variable Name Rules

### Syntax Rules
- Start with underscore or letter
- Followed by letters, digits, or underscores
- Case sensitive (`HACK` â‰  `hack`)
- Cannot use reserved words

### Reserved Words
```
False    await    else     import   pass
None     break    except   in       raise  
True     class    finally  is       return
and      continue for      lambda   try
as       def      from     nonlocal while
assert   del      global   not      with
async    elif     if       or       yield
```

**Soft Reserved Words:** `match`, `case`, `_`, `type` (context-dependent)

### Naming Conventions

| Pattern | Meaning |
|---------|---------|
| `_X` | Not imported by `from module import *` |
| `__X__` | System-defined names with special meaning |
| `__X` | Class-private names (name mangling) |
| `_` | Last expression result in REPL; wildcard in match |

## Expression Statements

Any expression can be used as a statement:

```python
# Function calls
hack('Py', 3.12)
code.hack('Py')

# Method calls (common for in-place changes)
L.append(3)              # CORRECT
L = L.append(4)          # WRONG - returns None!

# Interactive echoing
hack                     # Prints value in REPL
```

!!! danger "Common Mistake"
    In-place methods return `None`:
    ```python
    L = [1, 2]
    L = L.append(3)      # L becomes None!
    
    # Correct usage
    L.append(3)          # L is still [1, 2, 3]
    ```

## Print Operations

### Basic Print Function

```python
print([object, ...][, sep=' '][, end='\n'][, file=sys.stdout][, flush=False])
```

**Parameters:**
- `sep`: separator between objects (default: space)
- `end`: string at end (default: newline)
- `file`: output destination (default: stdout)
- `flush`: force immediate output (default: False)

### Print Examples

```python
# Basic printing
print('hello', 'world')          # hello world

# Custom separator
print(1, 2, 3, sep=', ')         # 1, 2, 3

# Custom ending
print('no newline', end='')      # no newline>>>

# Multiple keywords
print(1, 2, 3, sep='...', end='!\n')  # 1...2...3!
```

### Stream Redirection

**To Files:**
```python
# Single print to file
print('data', file=open('log.txt', 'w'))

# Multiple prints to same file
log = open('log.txt', 'w')
print('line 1', file=log)
print('line 2', file=log)
log.close()
```

**Manual Redirection:**
```python
import sys

# Save original
temp = sys.stdout

# Redirect all prints
sys.stdout = open('log.txt', 'w')
print('goes to file')

# Restore
sys.stdout.close()
sys.stdout = temp
print('back to console')
```

**Error Output:**
```python
import sys
print('Error message', file=sys.stderr)
```

### Print vs Write Equivalence

```python
# These are equivalent:
print(X, Y)
sys.stdout.write(str(X) + ' ' + str(Y) + '\n')
```

## Common Patterns and Idioms

### Loop Variable Unpacking
```python
# Simple tuple assignment in loops
for (a, b, c) in [(1, 2, 3), (4, 5, 6)]:
    ...

# Extended unpacking in loops  
for (a, *b, c) in [(1, 2, 3, 4), (5, 6, 7, 8)]:
    ...
```

### List Processing
```python
# Traditional approach
L = [1, 2, 3, 4]
while L:
    front = L[0]
    L = L[1:]
    print(front, L)

# With extended unpacking
L = [1, 2, 3, 4] 
while L:
    front, *L = L
    print(front, L)
```

## Best Practices

1. **Use sequence unpacking for swapping:** `a, b = b, a`
2. **Be careful with mutable object assignments:** Create separate objects
3. **Don't assign in-place method results:** `L.append(x)` not `L = L.append(x)`
4. **Use extended unpacking for first/rest patterns:** `first, *rest = sequence`
5. **Prefer print() over sys.stdout.write()** for simple output
6. **Use f-strings for complex formatting, print() for simple separation**
7. **Use := sparingly and with parentheses** when needed

## Summary

This chapter covered Python's assignment mechanisms (basic, sequence, extended-unpacking, multiple-target, augmented, and named), expression statements, and print operations. Key takeaways:

- Assignments create references, not copies
- Multiple assignment forms provide flexibility
- Augmented assignments optimize in-place operations
- Print provides easy output formatting and redirection
- Understanding these fundamentals is crucial for effective Python programming