# Chapter 14: Iterations and Comprehensions

## Overview

This chapter explores Python's iteration protocol and comprehensions - tools that make iterating over collections simpler and more efficient. These concepts bridge looping statements and functions, appearing in multiple contexts throughout Python programming.

## Key Concepts

### Iterable vs Iterator
- **Iterable**: Object that supports iteration (has `__iter__` method)
- **Iterator**: Object that produces results one at a time (has `__next__` method)
- **Iteration Tool**: Language constructs that run iterations (for loops, zip, etc.)

## The Iteration Protocol

### Basic Protocol Structure

The iteration protocol consists of two main components:

1. **Iterable Object**: Has `__iter__()` method that returns an iterator
2. **Iterator Object**: Has `__next__()` method that produces results and raises `StopIteration` when done

```python
# Manual iteration example
L = [1, 2, 3]
I = iter(L)        # Get iterator from iterable
print(next(I))     # 1 - get next item
print(next(I))     # 2
print(next(I))     # 3
# next(I) would raise StopIteration
```

### File Iteration Example

Files are both iterable and iterator (they are their own iterator):

```python
# File reading with iteration protocol
f = open('data.txt')
print(f.__next__())    # First line
print(next(f))         # Second line (next() is cleaner)

# Best practice: let for loop handle iteration
for line in open('data.txt'):
    print(line.upper(), end='')
```

### Built-in Functions: `iter()` and `next()`

- `iter(object)`: Returns iterator from iterable (calls `__iter__()`)
- `next(iterator)`: Gets next item from iterator (calls `__next__()`)
- `next(iterator, default)`: Returns default instead of raising exception

```python
L = [1, 2, 3]
I = iter(L)
print(next(I, 'end'))  # 1
print(next(I, 'end'))  # 2
print(next(I, 'end'))  # 3
print(next(I, 'end'))  # 'end' (no exception)
```

## Built-in Iterables

### Common Iterables

| Type | Multiple Scans | Self Iterator | Notes |
|------|----------------|---------------|--------|
| Lists | ✓ | ✗ | Need `iter()` for manual iteration |
| Tuples | ✓ | ✗ | Need `iter()` for manual iteration |
| Strings | ✓ | ✗ | Need `iter()` for manual iteration |
| Dictionaries | ✓ | ✗ | Iterates over keys |
| Files | ✗ | ✓ | Single scan only |
| range() | ✓ | ✗ | Virtual sequence |
| enumerate() | ✗ | ✓ | Single scan only |
| zip() | ✗ | ✓ | Single scan only |
| map() | ✗ | ✓ | Single scan only |
| filter() | ✗ | ✓ | Single scan only |

### Examples

```python
# Dictionary iteration
D = {'a': 1, 'b': 2}
for key in D:
    print(key, D[key])

# Range iteration  
for x in range(5):
    print(x)

# Multiple iterators on same object
L = [1, 2, 3]
I1 = iter(L)
I2 = iter(L)  # Independent iterators
print(next(I1))  # 1
print(next(I2))  # 1 (starts fresh)

# Single iterator objects
Z = zip([1, 2], [3, 4])
I1 = iter(Z)
I2 = iter(Z)  # Same iterator!
print(next(I1))  # (1, 3)
print(next(I2))  # (2, 4) - continued from I1
```

## List Comprehensions

### Basic Syntax

```python
[expression for item in iterable]
```

### Examples

```python
# Basic comprehension
L = [1, 2, 3, 4, 5]
result = [x + 10 for x in L]
print(result)  # [11, 12, 13, 14, 15]

# Equivalent for loop
result = []
for x in L:
    result.append(x + 10)

# File processing
lines = [line.rstrip() for line in open('data.txt')]
```

### Performance Benefits

- Often **2x faster** than equivalent for loops
- Iterations run at C speed inside interpreter
- More concise and readable code

### Extended Syntax

#### Filter Clauses (`if`)

```python
# Basic filter
[x for x in range(10) if x % 2 == 0]  # [0, 2, 4, 6, 8]

# File filtering
lines = [line.rstrip() for line in open('data.txt') 
         if line[0] in 'LP']

# Complex filter
[line.rstrip() for line in open('data.txt') 
 if line.rstrip()[-1:].isdigit()]
```

#### Nested Loops

```python
# Multiple for clauses
result = [x + y for x in 'abc' for y in '123']
# ['a1', 'a2', 'a3', 'b1', 'b2', 'b3', 'c1', 'c2', 'c3']

# Equivalent nested for loops
result = []
for x in 'abc':
    for y in '123':
        result.append(x + y)
```

### File Processing Examples

```python
# Read and process file lines
lines = [line.rstrip() for line in open('data.txt')]

# Multiple operations
uppers = [line.rstrip().upper() for line in open('data.txt')]

# Split lines into words
words = [line.split() for line in open('data.txt')]

# Complex processing
results = [('Py' in line, line.split()[0]) for line in open('data.txt')]
```

## Other Comprehension Types

### Set Comprehensions
```python
{x + 10 for x in L if x > 0}
```

### Dictionary Comprehensions
```python
{x: x + 10 for x in L if x > 0}
```

### Generator Expressions (Preview)
```python
(x + 10 for x in L if x > 0)  # Returns generator object
```

## Functional Iterables

### `map()` Function

```python
# Apply function to each item
M = map(ord, 'py3')  # Convert chars to ASCII codes
print(list(M))       # [112, 121, 51]

# map is iterable and iterator
print(next(M))       # Would raise StopIteration (exhausted)
```

### `filter()` Function

```python
# Filter items based on function
result = filter(bool, ['hello', '', 2024])
print(list(result))  # ['hello', 2024]

# Using method as filter function
digits = filter(str.isdigit, ['abc', '123', 'def'])
print(list(digits))  # ['123']
```

## Iteration Tools Summary

### Tools That Use Iteration Protocol

All these tools automatically work with any iterable:

#### Sequence Operations
- `for` loops
- Sequence assignment: `a, b, c = iterable`
- Extended unpacking: `a, *b = iterable`
- `in` membership test
- Slice assignment: `L[1:3] = iterable`

#### Built-in Functions
- `list()`, `tuple()`, `set()`: Create collections
- `sorted()`: Sort any iterable
- `sum()`: Sum numeric iterable
- `min()`, `max()`: Find extremes
- `any()`, `all()`: Boolean tests
- `zip()`: Combine iterables
- `enumerate()`: Add indices
- `map()`, `filter()`: Transform/filter

#### String Methods
- `''.join(iterable)`: Join strings

#### List Methods
- `list.extend(iterable)`: Add all items

### Examples with Files

```python
# All these work with file iteration
list(open('data.txt'))              # Convert to list
tuple(open('data.txt'))             # Convert to tuple
'&&'.join(open('data.txt'))         # Join lines
sorted(open('data.txt'))            # Sort lines
max(open('data.txt'))               # Lexically largest line

# Sequence assignment
a, b, c = open('data.txt')

# Extended unpacking
first, *rest = open('data.txt')

# Membership test
'Python' in open('data.txt')

# List operations
L = [1]
L.extend(open('data.txt'))
```

## Best Practices

### File Reading
```python
# Best: Let iteration handle line-by-line reading
for line in open('data.txt'):
    process(line)

# Good: List comprehension for processing
lines = [line.rstrip() for line in open('data.txt')]

# Avoid: Reading entire file into memory
lines = open('data.txt').readlines()  # Memory intensive
```

### When to Use Comprehensions

**Use comprehensions for:**
- Simple transformations
- Filtering operations  
- Building result collections
- Better performance needs

**Use for loops for:**
- Complex logic
- Multiple statements per iteration
- Better readability for complex cases
- Side effects (printing, file writing)

### Performance Tips

- List comprehensions are typically 2x faster than for loops
- File iterators run at C speed
- Avoid `readlines()` for large files
- Use iteration protocol instead of manual indexing

## Key Takeaways

1. **Iteration Protocol**: Universal interface (`__iter__`/`__next__`) for scanning objects
2. **Automatic Usage**: Most Python tools use iteration protocol automatically
3. **Memory Efficiency**: Iterators produce results on-demand, not all at once
4. **Comprehensions**: Concise, fast way to transform iterables
5. **File Processing**: Iteration protocol makes line-by-line reading efficient
6. **Single vs Multiple Scans**: Some iterables support multiple simultaneous iterations, others don't

## Common Patterns

```python
# Transform data
results = [transform(x) for x in data]

# Filter and transform
results = [transform(x) for x in data if condition(x)]

# Process file lines
lines = [line.strip().upper() for line in open('file.txt') 
         if line.strip()]

# Manual iteration when needed
iterator = iter(data)
try:
    while True:
        item = next(iterator)
        process(item)
except StopIteration:
    pass

# Or with default
iterator = iter(data)
while (item := next(iterator, None)) is not None:
    process(item)
```

This iteration protocol and comprehension system provides a powerful, consistent way to work with sequences and collections throughout Python.