# Chapter 10: Introducing Python Statements

## Overview

Statements are the code we write to tell Python what our programs should do. Python is a procedural, statement-based language where we combine statements to specify procedures that Python performs to satisfy a program's goals.

## The Python Conceptual Hierarchy

```
Programs are composed of modules
    ↓
Modules contain statements
    ↓
Statements contain expressions
    ↓
Expressions create and process objects
```

- **Programs**: Composed of statements and expressions
- **Expressions**: Process objects and are embedded in statements
- **Statements**: Code the larger logic of a program's operation
- **Objects**: Spring into existence through expressions within assignment statements

## Python Statements Summary

| Statement | Role | Example |
|-----------|------|---------|
| **Assignment** | Creating references | `a, b = 'python', 3.12` |
| **Calls/expressions** | Running functions | `log.write('app crash')` |
| **print** | Printing objects | `print(hack, code, file=log)` |
| **if/elif/else** | Selecting actions | `if 'python' in text: read(text)` |
| **match/case** | Multiway selections | `match edition: case 6: print(2024)` |
| **for/else** | Iteration | `for x in myiterable: print(x)` |
| **while/else** | General loops | `while x := file.readline(): print(x)` |
| **pass** | Empty placeholder | `if 'python' not in text: pass` |
| **break** | Loop exit | `while True: if exittest(): break` |
| **continue** | Loop continue | `while True: if skiptest(): continue` |
| **def** | Functions and methods | `def f(a, b, c=2, *more): print(a + b + c)` |
| **return** | Function results | `def f(a, b, c=2, *more): return a + b + c` |
| **yield** | Generator functions | `def gen(n): for i in n: yield i*2` |
| **global** | Namespaces | `x = 1; def function(): global x; x = 2` |
| **nonlocal** | Namespaces | `def outer(): x = 1; def inner(): nonlocal x; x = 2` |
| **import** | Module access | `import sys` |
| **from** | Attribute access | `from sys import stdin as f` |
| **class** | Building objects | `class Subclass(Superclass): pass` |
| **try/except/finally** | Exception handling | `try: action() except: print('error')` |
| **raise** | Triggering exceptions | `raise EndSearch(location)` |
| **assert** | Debugging checks | `assert X > Y, 'X too small'` |
| **with** | Context managers | `with open('data') as file: process(file)` |
| **del** | Deleting references | `del data[k]` |

## Python vs C-like Languages

### What Python Adds

**Colon Character (:)**
- All compound statements follow the pattern:
```python
Header line:
    Nested statement block
```
- The colon is **required** - omitting it is the most common beginner mistake
- Example error: `SyntaxError: expected ':'`

### What Python Removes

#### 1. Parentheses are Optional
**C-like language:**
```c
if (x < y)
```

**Python:**
```python
if x < y:
```

!!! tip "Best Practice"
    Don't use unnecessary parentheses in Python - it marks you as a C programmer still learning Python!

#### 2. End-of-line is End of Statement
**C-like language:**
```c
x = 1;
```

**Python:**
```python
x = 1
```

- No semicolons needed
- End of line automatically terminates the statement
- Semicolons are only used as separators when combining statements

#### 3. End of Indentation is End of Block
**C-like language:**
```c
if (x > y) {
    x = 1;
    y = 2;
}
```

**Python:**
```python
if x > y:
    x = 1
    y = 2
```

## Indentation Rules

### Basic Rules
- All statements in a nested block must be indented the **same distance**
- Python doesn't care how much you indent (spaces or tabs)
- Different blocks can have different indentation amounts
- **Consistency within a block is required**

### Example of Correct Indentation
```python
if x > y:
    x = 1      # Same indentation
    y = 2      # Same indentation
    if x > 10:
        x = 0  # Further indented for nested block
```

### Common Indentation Error
```python
if True:
    a = 1      # 4 spaces
  b = 2        # 2 spaces - ERROR!
```
**Result:** `IndentationError: unindent does not match any outer indentation level`

## Why Indentation Syntax?

### Benefits
1. **Forces readable code** - Visual structure matches logical structure
2. **Consistency** - All Python code looks similar
3. **WYSIWYG** - What you see is what you get
4. **Prevents ambiguity** - No confusion about which block statements belong to

### Real-world Impact
- Makes code more maintainable
- Reduces debugging time
- Improves team collaboration
- Essential for professional development

!!! warning "Mixing Tabs and Spaces"
    Don't mix tabs and spaces in the same block - Python will raise an error for inconsistent use.

## Special Cases and Flexibility

### Statement Rule Special Cases

#### 1. Multiple Statements on One Line
```python
a = 1; b = 2; print(a + b)  # Three statements on one line
```
- Semicolons required as separators
- Only works with simple statements (not compound statements)
- Generally discouraged for readability

#### 2. Single Statement Spanning Multiple Lines
**Using brackets:**
```python
mylist = [1111,        # Continuation lines
          2222,        # Any code in (), [], {}
          3333]

X = (A + B +           # Parentheses for expressions
     C + D)
```

**Using backslash (discouraged):**
```python
X = A + B + \
    C + D              # Error-prone, avoid this
```

!!! tip "Best Practice"
    Use bracketed pairs instead of backslashes for line continuation.

### Block Rule Special Case

#### Single-line Compound Statements
```python
if x > y: print(x)     # Body on same line as header
```
- Only works if body contains simple statements
- Compound statements still need separate lines
- Use sparingly for readability

## Interactive Loop Example

### Basic Loop Structure
```python
while True:
    reply = input('Enter text:')
    if reply == 'stop': break
    print(reply.upper())
```

**Key components:**
- `while True:` - Infinite loop
- `input()` - Get user input
- Single-line `if` with `break` - Exit condition
- Consistent indentation for the block

### Enhanced Version with Math
```python
while True:
    reply = input('Enter text:')
    if reply == 'stop': break
    print(int(reply) ** 2)
print('Bye')
```

### Error Handling with Validation
```python
while True:
    reply = input('Enter text:')
    if reply == 'stop':
        break
    elif not reply.isdigit():
        print('Bad!' * 8)
    else:
        print(int(reply) ** 2)
print('Bye')
```

### Error Handling with try/except
```python
while True:
    reply = input('Enter text:')
    if reply == 'stop': break
    try:
        print(float(reply) ** 2)
    except:
        print('Bad!' * 8)
print('Bye')
```

## Key Concepts

### Statement Nesting
- Statements can be nested multiple levels deep
- Each level requires consistent indentation
- Visual structure reflects logical structure

### Error Handling Approaches
1. **Validation** - Check before processing (`isdigit()`)
2. **Exception handling** - Try and catch errors (`try/except`)

### Best Practices
- Use consistent indentation (4 spaces recommended)
- One statement per line for readability
- Use meaningful variable names
- Handle errors gracefully
- Keep nesting levels reasonable

## Common Beginner Mistakes

1. **Forgetting the colon** - Most common error
2. **Inconsistent indentation** - Mixing tabs and spaces
3. **Using unnecessary parentheses** - Over-using C-like syntax
4. **Adding semicolons** - Not needed in Python
5. **Incorrect nesting** - Misaligned indentation levels

## Summary

- Python uses **indentation** to define code blocks instead of braces
- **Colons** are required after compound statement headers
- **End of line** terminates statements (no semicolons needed)
- **Consistency** in indentation is crucial
- Python's syntax promotes **readable, maintainable code**
- **try/except** provides robust error handling
- Follow Python conventions for professional-quality code

!!! note "Remember"
    If you're coming from C-like languages, embrace Python's philosophy: explicit is better than implicit, and readability counts!