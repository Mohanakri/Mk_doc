# Chapter 3: How You Run Programs - Notes

## Overview
This chapter covers all major techniques for running Python code, from interactive sessions to file execution, IDEs, and various launching methods. Essential for understanding how to execute Python programs in different environments.

## Installing Python

### Platform-Specific Installation
- **Windows & macOS**: Download and run self-installing executable from python.org
- **Linux/WSL**: May have Python preinstalled, or install from distribution repositories
- **Android & iOS**: Install Python app from app store
- **Unix**: Often compile from source code

### Checking for Existing Installation
- **Windows**: Check Start menu
- **All Platforms**: Run Python command in terminal/console
- **Book Recommendation**: Use Python 3.12 or closest version available

## Interactive Code (REPL)

### Starting Interactive Sessions

#### Platform-Specific Commands
```bash
# Windows
$ py

# macOS
$ python3

# Linux/Android
$ python
# or
$ python3
```

#### Session Information
- Displays Python version and platform
- Shows helpful commands: "help", "copyright", "credits", "license"
- Exit with **Ctrl+Z** (Windows) or **Ctrl+D** (Unix/macOS/Linux/Android)

### Working Directory Setup

#### Recommended Structure
1. **Dedicated Code Folder**: Create main folder for all book examples
2. **Per-Chapter Subfolders**: Organize code by chapter to avoid conflicts
3. **Example**: `LP6E/Chapter03/` structure

#### Commands for Directory Management
```bash
# Create directory
mkdir folder_name

# Change directory
cd folder_name

# Python directory commands (after import os)
os.getcwd()      # Show current directory
os.chdir('path') # Change directory
```

### Input Conventions

#### What NOT to Type
- **System Prompts**: Don't type `$` character
- **Python Prompts**: Don't type `>>>` or `...` prompts
- **Comments**: Generally skip text after `#` (except `#!` directives)

#### Visual Cues in This Book
- **Bold Text**: User input you must type
- **Regular Text**: Prompts and system responses

### Alternative REPL Systems
- **IPython**: Enhanced interactive session with numbered commands
- **Jupyter**: Web browser-based notebooks for scientific work
- **PyPy**: Uses `>>>>` prompts (four characters vs three)
- **IDLE**: Shows `>>>` in GUI format
- **Mobile Apps**: May vary in interface

### Running Interactive Code

#### Basic Examples
```python
>>> print('Hello world!')
Hello world!
>>> print(2 ** 8)
256
>>> language = 'Python'
>>> language
'Python'
>>> 2 ** 8
256
```

#### Key Features
- **Immediate Execution**: Code runs when Enter is pressed
- **Automatic Display**: Expressions show results without print
- **Variable Assignment**: Use `=` to create variables
- **Error Handling**: Shows helpful error messages

### Why Use Interactive Mode?

#### Learning Benefits
- **Immediate Feedback**: Test code snippets instantly
- **Experimentation**: Try unfamiliar expressions safely
- **Example**: `'Hack!' * 8` → `'Hack!Hack!Hack!Hack!Hack!Hack!Hack!Hack!'`

#### Error Exploration
```python
>>> X  # Undefined variable
NameError: name 'X' is not defined

>>> sys.ps1  # Missing import
NameError: name 'sys' is not defined. Did you forget to import 'sys'?
```

#### Testing Capabilities
```python
>>> import os
>>> os.getcwd()  # Test system functions
'/Users/me/code'
```

## Program Files (Scripts/Modules)

### File Basics
- **Extension**: Use `.py` for Python files
- **Terminology**:
  - **Module**: Any `.py` file
  - **Script**: Top-level file that's run directly
  - **Program**: Series of statements for repeated execution

### Creating Your First Script

#### Example: script1.py
```python
# A first Python script
import sys                  # Load a library module
print(sys.platform)
print(2 ** 100)             # Raise 2 to a power
x = 'Hack!'
print(x * 8)                # String repetition
```

#### Key Elements
- **Comments**: Text after `#` for documentation
- **Imports**: Load external modules with `import`
- **Print Statements**: Required for output in files (unlike REPL)
- **Variables**: Created by assignment, used in expressions

### Running Files with Command Lines

#### Basic Execution
```bash
$ python3 script1.py
darwin
1267650600228229401496703205376
Hack!Hack!Hack!Hack!Hack!Hack!Hack!Hack!
```

#### Command Variations
```bash
# Windows
$ py script1.py

# With output redirection
$ python3 script1.py > saveit.txt

# Windows filename association
$ script1.py

# Full paths if needed
$ /usr/local/bin/python3 /Users/me/code/script1.py > /Users/me/data/output.txt
```

## Alternative Running Methods

### File Icon Clicks
- **Windows**: File Explorer with automatic association
- **macOS**: Finder with "Open With" Python Launcher
- **Linux**: Requires executable permission and `#!` line
- **Mobile**: Tap filename in file explorer (app-dependent)

#### Limitations
- **Output Window**: Closes immediately after execution
- **Error Messages**: May not be visible
- **Solution**: Add `input()` call to pause before exit

### IDLE GUI (Integrated Development Environment)

#### Features
- **Cross-Platform**: Runs on Windows, macOS, Linux
- **Integrated Tools**: Edit, run, browse, debug in one interface
- **Built-in**: Comes with standard Python installation

#### Key Components
- **Shell Window**: Interactive REPL with command recall
- **Edit Windows**: File editing with syntax highlighting
- **Menu Options**:
  - `File → New File`: Create new script
  - `File → Open`: Open existing file
  - `Run → Run Module`: Execute current file

#### Starting IDLE
```bash
# Universal command
$ python3 -m idlelib.idle
```

#### Additional Features
- Tab completion and balloon help
- Object browser and GUI debugger
- Right-click error messages to jump to source
- Customizable themes (including dark theme)

### Other IDEs
**Advanced Options** (not recommended for beginners):
- **PyCharm**: Professional IDE with advanced features
- **PyDev**: Eclipse-based Python development
- **Wing**: Commercial Python IDE
- **VSCode**: Microsoft's versatile code editor
- **Spyder**: Scientific Python development
- **PyScripter**: Windows-focused Python IDE

### Mobile Apps
- **Termux (Android)**: Traditional command-line interface
- **Various Apps**: Button-tap interfaces for code execution
- **Platform Variations**: See Appendix A for specific details

### Web-Based Options

#### WebAssembly (Emerging Technology)
- **Pyodide**: CPython compiled to WebAssembly
- **Browser Execution**: Run Python in web browsers
- **Limitations**: 
  - Slower than native execution
  - Limited file system access
  - Fixed set of available tools
  - Virtual storage only

#### Jupyter Notebooks
- **Scientific Focus**: Designed for STEM applications
- **Notebook Paradigm**: Interactive cells with IPython REPL
- **Server Required**: Traditional setup needs separate server
- **Browser-Based**: Also available with WebAssembly/Pyodide

### Ahead-of-Time Compilers
- **Nuitka**: Compile Python to machine code
- **Shed Skin**: C++ code generation from Python
- **Trade-offs**:
  - **Pros**: Faster execution speed
  - **Cons**: Slower development process, added complexity
  - **Recommendation**: Learn Python first with simpler tools

## Running Code in Code

### Import System Basics

#### What is a Module?
- **Definition**: Any `.py` file is automatically a module
- **Purpose**: Code reuse and organization
- **Access**: Other files import modules to use their contents

#### Basic Import Usage
```python
$ python3
>>> import script1  # Runs the file once
darwin
1267650600228229401496703205376
Hack!Hack!Hack!Hack!Hack!Hack!Hack!Hack!
```

#### Important Notes
- **Directory Requirement**: Run imports from directory containing the module
- **One-Time Execution**: Imports run only once per session
- **Subsequent Imports**: Later imports do nothing (by design)

### Reloading Modules

#### The Need for Reloading
```python
>>> import script1      # First import runs the code
>>> import script1      # Second import does nothing
```

#### Using Reload Function
```python
>>> from importlib import reload
>>> reload(script1)
darwin
1267650600228229401496703205376
Hack!Hack!Hack!Hack!Hack!Hack!Hack!Hack!
<module 'script1' from '/Users/me/Code/script1.py'>
```

#### Reload Requirements
- **Prerequisite**: Must successfully import module first
- **Function Call**: Uses parentheses (reload is a function, import is a statement)
- **Return Value**: Returns module object (shown as extra output line)

### Module Attributes System

#### Understanding Attributes
- **Definition**: Variables attached to specific objects (like modules)
- **Creation**: All top-level assignments in module become attributes
- **Access**: Use dot notation (`module.attribute`) or from statements

#### Simple Example: myfile.py
```python
title = 'Learning Python, 6th Edition'
```

#### Two Ways to Access Attributes

**Method 1: Import and Qualify**
```python
>>> import myfile
>>> myfile.title
'Learning Python, 6th Edition'
```

**Method 2: From Statement**
```python
>>> from myfile import title
>>> title
'Learning Python, 6th Edition'
```

#### Multiple Attributes Example: threenames.py
```python
a = 'PC'                       # Define three attributes
b = 'Phone'                    # Exported to other files
c = 'Tablet'
print(a, b, c)                 # Also used as variables in this file
```

**Usage Examples:**
```python
# Run as script
$ python3 threenames.py
PC Phone Tablet

# Import whole module
>>> import threenames
PC Phone Tablet
>>> threenames.b, threenames.c
('Phone', 'Tablet')

# Import specific names
>>> from threenames import b, c
>>> b, c
('Phone', 'Tablet')
```

### The exec Built-in Function

#### Purpose and Usage
```python
>>> exec(open('script1.py').read())
darwin
1267650600228229401496703205376
Hack!Hack!Hack!Hack!Hack!Hack!Hack!Hack!
```

#### How It Works
1. **File Reading**: `open('script1.py').read()` loads file content as string
2. **Execution**: `exec()` compiles and runs the string as Python code
3. **No Import**: Doesn't create module, just runs code in current namespace

#### Advantages
- **Always Current**: Runs current version without reload
- **No Module System**: Simpler than import/reload cycle

#### Disadvantages
- **Name Collisions**: Can overwrite existing variables
```python
>>> x = 999
>>> exec(open('script1.py').read())
>>> x  # Now overwritten by script's assignment
'Hack!'
```

### Command-Line Launchers

#### Using os.system
```python
>>> import os
>>> os.system('python3 script1.py')
darwin
1267650600228229401496703205376
Hack!Hack!Hack!Hack!Hack!Hack!Hack!Hack!
0  # Return value: 0 means success
```

#### Other Options
- **os.popen**: Returns file object to read command output
- **subprocess.run**: More control over command execution
- **Caution**: These can run any system command (potentially dangerous)

## Additional Launch Options

### Various Integration Methods
- **Embedded Python**: C, C++, Java programs running Python code
- **Text Editors**: Many editors can execute Python code directly
- **Excel Integration**: Python code in spreadsheet cells
- **Web Servers**: Automatic script launching for browser requests
- **Standalone Executables**: Pre-compiled Python applications

### Future-Proofing
- Launch techniques evolve rapidly with technology
- Python adapts to new platforms and interfaces
- Examples: mobile swiping, VR interfaces, voice commands

## Which Option Should I Use?

### For Beginners
**Recommended Combination:**
1. **Command Lines**: Simple, powerful, universal
2. **IDLE GUI**: User-friendly, consistent across platforms

### For Experienced Programmers
**Typical Setup:**
1. **Text Editor**: For code editing
2. **System Console**: For launching programs via command lines

### General Principle
- **Subjectivity**: Choice depends on personal preference and constraints
- **Experimentation**: Try different methods to find what works best
- **Context Matters**: Different situations may call for different approaches

## Quiz Questions & Answers

### Questions
1. How can you start a Python interactive interpreter session (REPL)?
2. Where do you type a system command line to launch a script file?
3. Name four or more ways to run the code saved in a script file.
4. What pitfall is related to clicking file icons on Windows and Linux?
5. Why might you need to reload a module?
6. How do you run a script from within the IDLE GUI?
7. How are modules, attributes, and namespaces related?

### Answers

1. **Starting REPL**: Type Python command (`py` on Windows, `python3` elsewhere) at system console (Command Prompt/PowerShell on Windows, Terminal on macOS/Linux, Termux on Android). Alternative: launch IDLE or other IDEs with built-in REPLs.

2. **System Command Location**: Same interface used for REPL - system console window. Type at system prompt (`$` in book), NOT at Python prompt (`>>>`). Different systems: Command Prompt/PowerShell (Windows), Terminal (macOS/Linux), Termux (Android).

3. **Script Execution Methods**:
   - System command lines
   - File icon clicks
   - Import and reload statements
   - exec built-in function
   - os module tools (os.system, etc.)
   - IDE GUI options (IDLE's Run→Run Module)
   - Platform-specific methods (drag-and-drop, app UIs, web notebooks)

4. **Icon Click Pitfall**: Output window disappears immediately after script ends. For scripts that just print and exit, you can't see the output. Error messages also vanish before you can read them. Solution: use `input()` to pause, or prefer command lines/IDEs.

5. **Module Reloading Need**: Python imports modules only once per session. If you modify source code and want to test changes without restarting Python, you must reload. Must import successfully first before you can reload.

6. **IDLE Script Execution**: Open script in edit window, then select `Run → Run Module` from menu. Output appears in interactive Shell window.

7. **Modules/Attributes/Namespaces Relationship**: Each module file is automatically a namespace (package of variables). Top-level assignments become module attributes. Accessed via dot notation (`module.attribute`) or from imports. Prevents name collisions by keeping each module's names in separate namespace.

## Part I Exercises

### Exercise Topics
1. **Interaction**: Start REPL and test basic expression
2. **Programs**: Create and run module file with multiple launch methods
3. **Modules**: Test importing and directory effects
4. **Scripts**: Create executable script with `#!` line
5. **Errors and Debugging**: Experiment with errors and math expressions
6. **Breaks and Cycles**: Explore circular object references
7. **Documentation**: Browse Python manuals and resources

### Key Learning Points
- Environment configuration for Python execution
- Multiple ways to launch Python programs
- Import system behavior and directory dependencies
- Platform-specific executable scripts
- Error handling and debugging strategies
- Python's object reference system
- Documentation and resource discovery

## Debugging Python Code

### Debugging Strategies (Progressive Complexity)

#### 1. Do Nothing (Read Error Messages)
- **Python's Strength**: Useful, readable error messages
- **Information Provided**: File location, line number, error type
- **Modern Enhancement**: "Did you...?" suggestions
- **When Sufficient**: For experienced programmers with familiar code

#### 2. Insert Print Statements
- **Most Common Method**: Quick debugging for most Python programmers
- **Simplicity**: Even basic "I am here" messages help
- **Fast Turnaround**: Immediate results after code changes
- **GUI Consideration**: May need to check log files for output

#### 3. Use Logging Module
- **More Formal**: Better control than print statements
- **Planning Required**: More suited to larger programs
- **Benefits**: Configurable output levels and destinations
- **Usage**: See Python library manual for details

#### 4. GUI Debuggers
- **IDLE Debugger**: Available but not commonly used
- **Other IDEs**: Most provide point-and-click debugging
- **Trade-offs**: More setup time vs. detailed code tracing
- **Best For**: Large systems, beginners wanting detailed traces

#### 5. Command-Line Debugger (pdb)
- **Full Control**: Python's built-in source code debugger
- **Features**: Step through code, display variables, set breakpoints
- **Launch Methods**:
  - `import pdb; pdb.run('code')`
  - `python3 -m pdb file.py`
  - `pdb.pm()` after errors (postmortem mode)

#### 6. Python's -i Flag
- **Interactive Mode**: Automatic REPL after script execution
- **Usage**: `python3 -i script.py`
- **Benefits**: Inspect final variable values after errors
- **Additional**: Can then import pdb for further debugging

#### 7. Exception Handling
- **Advanced Technique**: Catch and process errors in code
- **Ultimate Solution**: Handle errors gracefully in production code
- **Learning Path**: Covered in Part VII of the book

### Debugging Philosophy
- **Error Detection**: Errors are reported clearly, not silently ignored
- **Rapid Feedback**: Much better than hex dumps and memory analysis
- **Learning Tool**: Mistakes become learning opportunities
- **Safety Net**: Default exception handler provides standard error reporting

## Key Takeaways

### Essential Concepts
- **Multiple Launch Methods**: Interactive REPL, command lines, IDEs, imports
- **File Organization**: Use dedicated folders and per-chapter subfolders
- **Module System**: Imports create reusable code libraries
- **Interactive Development**: REPL excellent for learning and testing
- **Platform Flexibility**: Python runs consistently across different systems

### Best Practices
- **Beginners**: Start with command lines and IDLE
- **Code Organization**: Use `.py` extensions and logical directory structure
- **Error Handling**: Read error messages carefully, use print for debugging
- **Import Behavior**: Understand one-time loading and reload requirements
- **Tool Selection**: Choose methods that match your experience and needs

### Future Considerations
- **Technology Evolution**: New launch methods emerge regularly
- **Platform Adaptation**: Python keeps pace with changing interfaces
- **Skill Development**: Start simple, advance to sophisticated tools as needed