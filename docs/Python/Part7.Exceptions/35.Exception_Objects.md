# Python Exception Objects

## Overview

Exception objects are class instance objects that are raised and propagated during exception processing. They are identified by classes and matched against `except` clauses in `try` statements. All built-in and user-defined exceptions must be based on classes to leverage the benefits of object-oriented programming.

## Benefits of Class-Based Exceptions

### 1. Flexible Exception Categories
- **Specificity control**: Choose how specific or general exception handling should be
- **Future-proof**: Add new exception subclasses without changing existing `try` statements
- **Hierarchical organization**: Superclasses as categories, subclasses as specific types

### 2. State Information and Behavior
- **Context storage**: Store relevant information as instance attributes
- **Methods available**: Attach behavior to exception objects
- **Natural integration**: Access state and methods in exception handlers

### 3. Reuse by Inheritance
- **Hierarchy participation**: Inherit from common base classes
- **Behavior customization**: Override inherited methods as needed
- **Common interfaces**: Provide consistent error displays and handling

## Exception Matching Rules

**Key Principle**: A raised exception matches an `except` clause if that clause names the exception's class **or any superclass of it**.

```python
# Superclass matches all subclasses
try:
    raise SpecificError()
except GeneralError:  # Catches SpecificError if it inherits from GeneralError
    print("Caught!")
```

## Exception Class Hierarchies

### Basic Example

```python
class General(Exception): pass
class Specific1(General): pass
class Specific2(General): pass

def raiser0():
    raise General()     # Raise superclass instance

def raiser1():
    raise Specific1()   # Raise subclass instance

def raiser2():
    raise Specific2()   # Raise different subclass instance

for func in (raiser0, raiser1, raiser2):
    try:
        func()
    except General:     # Catches General and ALL its subclasses
        import sys
        print('caught:', sys.exc_info()[0])
```

**Output:**
```
caught: <class '__main__.General'>
caught: <class '__main__.Specific1'>
caught: <class '__main__.Specific2'>
```

### Exception Details Access

```python
class General(Exception): pass
class Specific1(General): pass
class Specific2(General): pass

def raiser0(): raise General()
def raiser1(): raise Specific1()
def raiser2(): raise Specific2()

for func in (raiser0, raiser1, raiser2):
    try:
        func()
    except General as X:                 # X is the raised instance
        print('caught:', type(X))        # Same as sys.exc_info()[0], X.__class__
```

## Why Exception Hierarchies Matter

### The Library Evolution Problem

**Initial Library Design:**
```python
# mathlib.py (Version 1.0)
class Divzero(Exception): pass
class Oflow(Exception): pass

def func():
    # ... implementation
    raise Divzero()
```

**Client Code:**
```python
# client.py
import mathlib

try:
    mathlib.func()
except (mathlib.Divzero, mathlib.Oflow):
    # handle and recover
    pass
```

**Problem: Library Update**
```python
# mathlib.py (Version 2.0) - Added new exception
class Divzero(Exception): pass
class Oflow(Exception): pass
class Uflow(Exception): pass  # NEW EXCEPTION!
```

**Consequence**: All client code must be updated to handle the new exception:
```python
# client.py - MUST BE CHANGED
try:
    mathlib.func()
except (mathlib.Divzero, mathlib.Oflow, mathlib.Uflow):  # Added Uflow
    # handle and recover
    pass
```

### The Solution: Exception Hierarchies

**Better Library Design:**
```python
# mathlib.py
class NumErr(Exception): pass    # Category superclass
class Divzero(NumErr): pass     # Specific error types
class Oflow(NumErr): pass

def func():
    # ... implementation
    raise Divzero()
```

**Future-Proof Client Code:**
```python
# client.py
import mathlib

try:
    mathlib.func()
except mathlib.NumErr:          # Catches ALL numeric errors
    # handle and recover
    pass
```

**Library Updates Work Seamlessly:**
```python
# mathlib.py (Version 2.0)
class NumErr(Exception): pass
class Divzero(NumErr): pass
class Oflow(NumErr): pass
class Uflow(NumErr): pass       # NEW - but client code still works!
```

## Built-in Exception Classes

Python organizes built-in exceptions into a hierarchy with specific roles:

### Exception Hierarchy Structure

```
BaseException
 ├── SystemExit
 ├── KeyboardInterrupt
 ├── GeneratorExit
 └── Exception
     ├── ArithmeticError
     │   ├── OverflowError
     │   ├── ZeroDivisionError
     │   └── FloatingPointError
     ├── LookupError
     │   ├── IndexError
     │   └── KeyError
     ├── OSError
     │   ├── FileNotFoundError
     │   ├── PermissionError
     │   └── TimeoutError
     └── ... (many others)
```

### Key Built-in Exception Classes

#### BaseException
- **Role**: Topmost root with printing and constructor defaults
- **Usage**: Not for direct inheritance by user classes
- **Features**: 
  - Default printing behavior
  - State retention in `args` attribute
  - Constructor argument storage

#### Exception
- **Role**: Root of user-defined exceptions
- **Usage**: Almost all user-defined classes should inherit from this
- **Purpose**: Separates application errors from system exit events
- **Benefit**: Allows catching all application exceptions while letting system exits pass

#### ArithmeticError
- **Role**: Root of numeric errors
- **Subclasses**: `OverflowError`, `ZeroDivisionError`, `FloatingPointError`
- **Usage**: Catch any numeric error with single handler

#### LookupError
- **Role**: Root of indexing errors
- **Subclasses**: `IndexError` (sequences), `KeyError` (mappings)
- **Usage**: Handle both sequence and mapping lookup failures

#### OSError
- **Role**: System and I/O errors
- **Features**: Detailed error attributes (`errno`, `strerror`, `filename`)
- **Subclasses**: `FileNotFoundError`, `PermissionError`, `TimeoutError`

### Using Built-in Categories

```python
# Catch specific numeric error
try:
    result = 10 / 0
except ZeroDivisionError:
    print("Division by zero!")

# Catch any numeric error
try:
    risky_calculation()
except ArithmeticError:
    print("Some numeric error occurred")

# Catch all application exceptions (recommended over empty except)
try:
    risky_operation()
except Exception:                    # System exits NOT caught here
    print("Application error occurred")
else:
    print("No exceptions occurred")
```

## Default Printing and State

### Automatic State Storage

Built-in exceptions automatically store constructor arguments:

```python
# No arguments
>>> raise IndexError
IndexError

# Single argument
>>> raise IndexError('bad')
IndexError: bad

# Multiple arguments
>>> i = IndexError('bad', 'stuff')
>>> i.args
('bad', 'stuff')
>>> print(i)
('bad', 'stuff')
>>> i
IndexError('bad', 'stuff')
```

### User-Defined Exception Inheritance

```python
>>> class E(Exception): pass

>>> raise E
E

>>> raise E('bad')
E: bad

>>> i = E('bad', 'stuff')
>>> i.args
('bad', 'stuff')
>>> print(i)
('bad', 'stuff')
>>> i
E('bad', 'stuff')
```

### Accessing Exception Information

```python
>>> try:
...     raise E('bad')
... except E as X:
...     print(f'{X} - {X.args} - {X!r}')
...
bad - ('bad',) - E('bad')

>>> try:
...     raise E('bad', 'stuff')
... except E as X:
...     print(f'{X} - {X.args} - {X!r}')
...
('bad', 'stuff') - ('bad', 'stuff') - E('bad', 'stuff')
```

**Important**: Exception instances are not strings themselves—they use `__str__` and `__repr__` methods for display.

## Custom Print Displays

### Default Display Behavior

```python
>>> class MyBad(Exception): pass

>>> try:
...     raise MyBad('Sorry--my mistake!')
... except MyBad as X:
...     print(X)
...
Sorry--my mistake!

>>> raise MyBad('Sorry--my mistake!')
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
MyBad: Sorry--my mistake!
```

### Custom Display with `__str__`

```python
>>> class MyBad(Exception):
...     def __str__(self):
...         return 'Stuff happens...'

>>> try:
...     raise MyBad()
... except MyBad as X:
...     print(X)
...
Stuff happens...

>>> raise MyBad()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
MyBad: Stuff happens...
```

### Why `__str__` vs `__repr__`

**Use `__str__` for exception displays** because:
- Built-in superclasses already have `__str__` methods
- `__str__` is preferred over `__repr__` in error contexts
- `__repr__` may be ignored in favor of superclass `__str__`

```python
# __repr__ is NOT used for error display
>>> class Oops(Exception):
...     def __repr__(self): 
...         return 'Custom display not used'

>>> raise Oops("Nobody's perfect")
Oops: Nobody's perfect

# __str__ IS used for error display
>>> class Oops(Exception):
...     def __str__(self): 
...         return 'Custom display used'

>>> raise Oops("Nobody's perfect")
Oops: Custom display used
```

## Custom State and Behavior

### Providing Exception Details

Exception classes can carry custom state information across module boundaries:

```python
>>> class FormatError(Exception):
...     def __init__(self, line, file):
...         self.line = line
...         self.file = file

>>> def parser(file):
...     # Parse the file first...
...     raise FormatError(62, file=file)

>>> try:
...     parser('code.py')
... except FormatError as X:
...     print(f'Error at: {X.file} #{X.line}')
...
Error at: code.py #62
```

### Comparison with Default Constructor

```python
>>> class FormatError(Exception): pass  # Uses inherited constructor

>>> def parser(file):
...     raise FormatError(file, 62)      # No keywords allowed!

>>> try:
...     parser('code.py')
... except FormatError as X:
...     print(f'Error at: {X.args[0]} #{X.args[1]}')  # Generic access
...
Error at: code.py #62
```

### Exception Methods

Exception classes can provide specialized behavior:

```python
from time import asctime

class FormatError(Exception):
    logfile = 'parser-errors.txt'
    
    def __init__(self, line, file):
        self.line = line
        self.file = file
    
    def logerror(self):
        with open(self.logfile, 'a') as log:
            print(f'Error at: {self.file} #{self.line} [{asctime()}]', file=log)

def parser(file):
    # Parse a file here...
    raise FormatError(line=62, file=file)

if __name__ == '__main__':
    try:
        parser('code.py')
    except FormatError as exc:
        exc.logerror()  # Call custom method
```

### Inheritance and Customization

```python
class CustomFormatError(FormatError):
    def logerror(self):
        # Custom logging behavior
        super().logerror()  # Call parent method
        print("Additional custom logging")

# Usage remains the same due to polymorphism
try:
    raise CustomFormatError(line=42, file='test.py')
except FormatError as exc:  # Catches subclass too
    exc.logerror()          # Runs the CustomFormatError version
```

## Exception Groups and `except*`

**Note**: Exception groups are a Python 3.11+ feature with limited practical use.

### Basic Exception Groups

**Traditional Exception Handling** (one handler runs):
```python
>>> try:
...     raise IndexError()
... except IndexError:
...     print('Got IE')
... except (SyntaxError, TypeError):
...     print('Got SE')
... 
Got IE
```

**Exception Groups** (multiple handlers can run):
```python
>>> try:
...     raise ExceptionGroup('Many', [IndexError(), SyntaxError()])
... except* IndexError:
...     print('Got IE')
... except* (SyntaxError, TypeError):
...     print('Got SE')
... 
Got IE
Got SE
```

### Exception Group Mechanics

#### Creating and Handling Groups
```python
>>> excs = ExceptionGroup('Many', [IndexError(), SyntaxError(), TypeError()])
>>> try:
...     raise excs
... except* IndexError as E:
...     print(f'Got IE: {E} => {E.exceptions}')
... except* SyntaxError as E:
...     print(f'Got SE: {E} => {E.exceptions}')
... 
Got IE: Many (1 sub-exception) => (IndexError(),)
Got SE: Many (1 sub-exception) => (SyntaxError(),)
  + Exception Group Traceback (most recent call last):
  |   File "<stdin>", line 2, in <module>
  | ExceptionGroup: Many (1 sub-exception)
  +-+---------------- 1 ----------------
    | TypeError
    +------------------------------------
```

#### Multiple Exceptions of Same Type
```python
>>> try:
...     raise ExceptionGroup('Dups', [IndexError(), TypeError(1), TypeError(2)])
... except *IndexError:
...     print('Got IE')
... except *TypeError as E:
...     print(f'Got TE: {E} => {E.exceptions}')
... 
Got IE
Got TE: Dups (2 sub-exceptions) => (TypeError(1), TypeError(2))
```

#### Individual Exceptions in Groups
```python
>>> try:
...     raise IndexError
... except* IndexError as E:
...    print(f'Got IE: {E} => {E.exceptions}')
... 
Got IE:  (1 sub-exception) => (IndexError(),)
```

#### Basic `except` with Groups
```python
>>> try:
...     raise ExceptionGroup('Lots', [IndexError(), SyntaxError()])
... except ExceptionGroup as E:
...     print(f'Got group: {E} => {E.exceptions}')
...     for exc in E.exceptions:
...         print('With exc:', type(exc))
... 
Got group: Lots (2 sub-exceptions) => (IndexError(), SyntaxError())
With exc: <class 'IndexError'>
With exc: <class 'SyntaxError'>
```

### Exception Group Rules

1. **Syntax restrictions**:
   - Empty `except*` not allowed
   - Cannot mix `except` and `except*` in same `try`
   - `else` and `finally` can be used with `except*`
   - No `break`, `continue`, or `return` in `except*` blocks

2. **Semantics**:
   - Each `except*` clause executes at most once
   - Consumes all matching exceptions in the group
   - Each exception handled by at most one clause
   - First matching clause wins (order matters)
   - Unmatched exceptions are reraised

3. **Limited utility**: 
   - Very narrow use cases
   - Adds significant complexity
   - Most programs won't need this feature

## Key Concepts Summary

### Exception Class Requirements

1. **Must be classes**: Exception objects are class instances
2. **Must inherit from built-ins**: Usually `Exception`, sometimes `BaseException`
3. **Superclass matching**: Handlers catch named class and all subclasses

### Best Practices

1. **Inherit from `Exception`**: Not `BaseException` (allows system exits to pass)
2. **Use hierarchies**: Organize related exceptions under common superclasses
3. **Custom constructors**: Store relevant context in instance attributes
4. **Custom `__str__`**: Provide meaningful error messages
5. **Add methods**: Attach behavior to exception objects when useful
6. **Be specific**: Catch specific exceptions rather than broad categories when possible

### Exception Information Access

1. **`as` clause**: Direct access to exception instance
2. **`sys.exc_info()`**: Generic access to exception details
3. **Instance attributes**: Custom state and behavior
4. **Built-in attributes**: `args` tuple for constructor arguments

## Quiz Questions

1. **What are the two main constraints on user-defined exceptions in Python?**
2. **How are raised exceptions matched to except handler clauses?**
3. **Name two ways that you can attach context information to exception objects.**
4. **Name two ways that you can specify the error-message text for exception objects.**
5. **What do `except*` clauses do in a try statement?**

## Quiz Answers

1. **Two main constraints**:
   - Must be defined by classes (class instance objects are raised/caught)
   - Must inherit from `BaseException` or its subclasses (usually `Exception`)

2. **Exception matching**:
   - By superclass relationships
   - Naming a superclass catches that class AND all its subclasses
   - Creates category system (superclass = category, subclass = specific type)

3. **Attaching context information**:
   - **Custom constructors**: Fill out specific attributes in raised instances
   - **Default constructors**: Use built-in `args` tuple attribute for automatic storage

4. **Specifying error-message text**:
   - **Custom `__str__` method**: Define operator-overloading method for display
   - **Constructor arguments**: Built-in superclasses automatically display constructor arguments

5. **`except*` clauses**:
   - Run multiple handlers for exceptions in a group
   - Heavy semantics with special syntax rules
   - Cannot combine with basic `except`
   - Rarely useful in most Python programs

## Important Notes

### Memory and Performance
- Exception classes benefit from all OOP features (inheritance, methods, attributes)
- State information travels with exception across module boundaries
- Default constructors provide automatic state retention
- Custom methods enable specialized exception handling behavior

### Design Philosophy
- **Favor hierarchies** over lists of specific exceptions
- **Plan for evolution** - new subclasses shouldn't break existing handlers
- **Provide context** - attach relevant state information
- **Be consistent** - use similar patterns across related exceptions
- **Keep it simple** - avoid overcomplicating exception designs