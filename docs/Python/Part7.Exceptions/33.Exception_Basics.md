# Python Exception Basics

## Overview

Exceptions are events that signal conditions and modify the flow of control through a program. In Python, exceptions are triggered automatically on errors and can be both triggered and intercepted by your code.

## Exception Handling Statements

Python provides four main statements for exception handling:

### 1. `try/except/else/finally`
- **Purpose**: Catch and recover from exceptions raised by Python or your code
- **Structure**: Multiple flavors and combinations available

### 2. `raise`
- **Purpose**: Trigger an exception manually in your code
- **Usage**: Can raise built-in or user-defined exceptions

### 3. `assert`
- **Purpose**: Conditionally trigger an exception in your code
- **Usage**: Primarily for debugging and sanity checks

### 4. `with`
- **Purpose**: Use context managers that automate exception handling
- **Usage**: Ensures proper resource cleanup

## Why Use Exceptions?

### The Pizza Robot Analogy
Consider a pizza-making robot that follows these steps:
1. Take an order
2. Prepare the dough
3. Add toppings
4. Bake the pie

If something goes wrong during "bake the pie" (oven breaks, robot combusts), exceptions allow the program to:
- Jump out of arbitrarily large chunks of code
- Abandon the entire plan quickly
- Handle unusual states appropriately

### Key Benefits
- **Structured "go-to"**: Jump to exception handler in a single step
- **Simplified code**: No need to check status codes after every operation
- **Coherent error response**: Handle errors only where recovery is needed

## Exception Roles

### 1. Error Handling
```python
# Python raises exceptions on runtime errors
# You can catch and respond or ignore them
try:
    risky_operation()
except SomeError:
    handle_error()
```

### 2. Event Notification
- Signal valid conditions without passing result flags
- Example: Search routine raises exception on failure instead of returning error codes

### 3. Special-Case Handling
- Handle rare conditions in higher-level exception handlers
- Eliminate special-case code scattered throughout the program

### 4. Termination Actions
- `finally` clause ensures required cleanup operations
- `with` statement provides alternative for supported objects

### 5. Unusual Control Flows
- Implement exotic control flows (like backtracking)
- Alternative to "go to" statements
- Jump out of multiple loops

## Basic Exception Handling Examples

### Default Exception Handler

```python
def fetcher(obj, index):
    return obj[index]

food = 'pizza'
fetcher(food, 4)  # Returns 'a' - normal operation
fetcher(food, 5)  # Raises IndexError - out of bounds
```

**Error Output:**
```
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<stdin>", line 2, in fetcher
IndexError: string index out of range
```

### Catching Exceptions

```python
try:
    fetcher(food, 5)
except IndexError:
    print('got exception')
# Output: got exception
```

### Exception Recovery

```python
def catcher():
    try:
        fetcher(food, 5)
    except IndexError:
        print('got exception')
    print('continuing')

catcher()
# Output:
# got exception
# continuing
```

## Important Exception Behavior

### Control Flow After Exception
- **No return to triggering code**: Once caught, control continues after the entire `try` statement
- **Function memory cleared**: Variables in exited functions are discarded and not resumable
- **Changes retained**: Modifications to mutable objects and global variables persist

### Example of Retained Changes
```python
L, S = [], 'text'

def modder():
    L.append('added')        # Change a mutable
    global S; S = 'changed'  # Change a global
    fetcher(food, 5)         # Trigger exception

try:
    modder()
except IndexError:
    print('got exception')

print(L, S)  # Output: (['added'], 'changed')
```

## Raising Exceptions Manually

### Using `raise` Statement

```python
try:
    raise IndexError  # Trigger exception manually
except IndexError:
    print('got exception')
# Output: got exception
```

### Uncaught Manual Exceptions
```python
raise IndexError
# Output:
# Traceback (most recent call last):
#   File "<stdin>", line 1, in <module>
# IndexError
```

### Using `assert` Statement

```python
assert 1 < 0, 'Not in this universe!'
# Output:
# Traceback (most recent call last):
#   File "<stdin>", line 1, in <module>
# AssertionError: Not in this universe!
```

## User-Defined Exceptions

### Basic Custom Exception
```python
class Combust(Exception): 
    pass

def makePizza():
    raise Combust()

try:
    makePizza()
except Combust:
    print('got exception')
# Output: got exception
```

### Custom Exception with Message
```python
class Combust(Exception):
    def __str__(self): 
        return 'Call the fire department!...'

raise Combust()
# Output:
# Traceback (most recent call last):
#   File "<stdin>", line 1, in <module>
# Combust: Call the fire department!...
```

## Termination Actions

### `try/finally` - Always Execute

```python
try:
    fetcher(food, 4)
finally:
    print('after fetch')
# Output:
# 'a'
# after fetch
```

### `finally` with Exception
```python
def after():
    try:
        fetcher(food, 5)  # Raises exception
    finally:
        print('after fetch')    # Always runs
    print('after try?')         # Never reached

after()
# Output:
# after fetch
# Traceback (most recent call last):
# ...
# IndexError: string index out of range
```

### `finally` without Exception
```python
def after():
    try:
        fetcher(food, 4)  # No exception
    finally:
        print('after fetch')    # Runs
    print('after try?')         # Also runs

after()
# Output:
# after fetch
# after try?
```

## The `with` Statement

Alternative to `try/finally` for certain object types:

```python
with open('pizzarobot.txt', 'w') as file:
    file.write('Catch fire!\n')
# File automatically closed on exit, even if exception occurs
```

### `with` vs `try/finally`
- **`with`**: Fewer lines, but only works with certain object types
- **`try/finally`**: More general, works in all situations
- **`with`**: Can run startup actions and supports user-defined context management

## Key Concepts Summary

### Exception Flow Control
1. **Raised by**: Python automatically OR your program manually
2. **Handled by**: `try` statements OR ignored (default handler)
3. **Result**: Program continues after `try` OR terminates with error message

### Statement Combinations
- **`try/except`**: Handle exceptions
- **`try/finally`**: Run finalization code regardless of exceptions
- **`try/except/finally`**: Both handle exceptions AND run finalization
- **`try/else`**: Execute code only if no exception occurred

### Exception Triggering
- **`raise`**: Manual exception triggering
- **`assert`**: Conditional exception for debugging
- **Programming mistakes**: Automatic exception triggering

## Error Checking Comparison

### Traditional Approach (C-style)
```c
// C program - must check every operation
if (doFirstThing() == ERROR)
    return ERROR;
if (doNextThing() == ERROR)
    return ERROR;
// ... more error checking
```

### Python Exception Approach
```python
def doStuff():
    doFirstThing()    # No error checking needed
    doNextThing()     # Exceptions handle errors
    doLastThing()

try:
    doStuff()         # Only check results where needed
except:
    badEnding()
else:
    goodEnding()
```

### Advantages of Python Approach
- **Less error-checking code**: Focus on actual work
- **No performance overhead**: No constant testing
- **Automatic error detection**: Python handles error detection
- **Cleaner code**: Avoid code distracted by error handling

## Important Notes

### Memory and State
- **No backtracking**: Local variables are discarded, but global changes remain
- **No resumption**: Cannot return to the point where exception occurred
- **State preservation**: Changes to mutable objects persist after exceptions

### Best Practices
- Use exceptions for error handling, not normal control flow
- Catch specific exceptions rather than broad `except:` clauses
- Use `finally` for cleanup that must always happen
- Consider `with` statements for resource management
- Create meaningful custom exception classes when needed

## Quiz Questions

1. **Name three things that exception processing is good for.**
2. **What happens to an exception if you don't handle it?**
3. **How can your script recover from an exception?**
4. **Name two ways to trigger exceptions in your script.**
5. **Name two ways to specify actions to be run at termination time.**

## Quiz Answers

1. **Error handling, termination actions, event notification** (also special-case handling and alternative control flows)

2. **Uncaught exceptions filter up to the default handler**, which prints an error message and shuts down the program

3. **Use `try` statements with `except` clauses** to catch and recover from exceptions

4. **`raise` and `assert` statements** (also programming mistakes, but that's not intentional)

5. **`try/finally` statements and `with` statements** ensure termination actions run regardless of exceptions