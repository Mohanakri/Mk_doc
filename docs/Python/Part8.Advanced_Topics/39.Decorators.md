# Python Decorators - Complete Study Notes

## Chapter Overview

Decorators provide a way to specify management or augmentation code for functions and classes. They are callable objects that process other callable objects, offering a clean syntax for adding functionality without modifying the original code.

## What is a Decorator?

**Definition**: A decorator is a way to specify management or augmentation code for functions and classes through callable objects that process other callable objects.

### Two Types of Decorators

1. **Function Decorators** - Do name rebinding at function definition time
2. **Class Decorators** - Do name rebinding at class definition time

## Function Decorators

### Basic Syntax

```python
@decorator              # Decorate function
def F(arg):
    ...

F(99)                   # Call function
```

**Equivalent to:**

```python
def F(arg):
    ...
F = decorator(F)        # Rebind function name to decorator result

F(99)                   # Essentially calls decorator(F)(99)
```

### Implementation Patterns

#### 1. Simple Post-Processing Decorator

```python
def decorator(F):
    # Process function F here
    return F

@decorator
def func(): 
    ...                 # func = decorator(func)
```

#### 2. Wrapper Function Pattern

```python
def decorator(F):                     # On @ decoration
    def wrapper(*args):               # On wrapped function call
        # Use F and args
        # F(*args) calls original function
    return wrapper

@decorator                            # func = decorator(func)
def func(x, y):                       # func is passed to decorator's F
    ...

func(6, 7)                            # 6, 7 are passed to wrapper's *args
```

#### 3. Class-Based Decorator

```python
class decorator:
    def __init__(self, func):         # On @ decoration
        self.func = func
    def __call__(self, *args):        # On wrapped function call
        # Use self.func and args
        # self.func(*args) calls original function

@decorator
def func(x, y):                       # func = decorator(func)
    ...

func(6, 7)                            # 6, 7 are passed to __call__'s *args
```

### Supporting Method Decoration

**Problem**: Class-based decorators don't work well with methods because `self` receives the decorator instance, not the class instance.

**Solution**: Use nested functions

```python
def decorator(F):                       # F is func or method without instance
    def wrapper(*args):                 # class instance in args[0] for method
        # F(*args) runs func or method
    return wrapper

@decorator
def func(x, y): ...

class C:
    @decorator
    def method(self, x, y): ...         # method = decorator(method)

X = C()
X.method(6, 7)                          # Really calls wrapper(X, 6, 7)
```

## Class Decorators

### Basic Syntax

```python
@decorator                 # Decorate class
class C:
    ...

x = C(99)                  # Make an instance
```

**Equivalent to:**

```python
class C:
    ...
C = decorator(C)           # Rebind class name to decorator result

x = C(99)                  # Essentially calls decorator(C)(99)
```

### Implementation Example

```python
def decorator(cls):                             # On @ decoration
    class Wrapper:
        def __init__(self, *args):              # On instance creation
            self.wrapped = cls(*args)
        def __getattr__(self, name):            # On attribute fetch
            return getattr(self.wrapped, name)
    return Wrapper

@decorator
class C:                             # C = decorator(C)
    def __init__(self, x, y):        # Run by Wrapper.__init__
        self.attr = 'hack'

x = C(6, 7)                          # Really calls Wrapper(6, 7)
print(x.attr)                        # Runs Wrapper.__getattr__, prints "hack"
```

### Supporting Multiple Instances

**Problem**: Some class decorator patterns don't support multiple instances properly.

**Solutions**:

```python
# Pattern 1: New Wrapper per instance
def decorator(C):                             # On @ decoration
    class Wrapper:
        def __init__(self, *args):            # On instance creation: new Wrapper
            self.wrapped = C(*args)           # Embed instance in instance
    return Wrapper

# Pattern 2: Factory function
def decorator(C):                             # On @ decoration
    def onCall(*args):                        # On instance creation: new Wrapper
        return Wrapper(C(*args))              # Embed instance in instance
    return onCall
```

## Decorator Nesting

Multiple decorators can be applied to a single function or class:

```python
@A
@B
@C
def f(...):
    ...
```

**Equivalent to:**

```python
def f(...):
    ...
f = A(B(C(f)))
```

The **last decorator listed is applied first** and is the most deeply nested.

### Example

```python
def d1(F): return lambda: 'X' + F()
def d2(F): return lambda: 'Y' + F()
def d3(F): return lambda: 'Z' + F()

@d1
@d2
@d3
def func():               # func = d1(d2(d3(func)))
    return 'hack'

print(func())             # Prints "XYZhack"
```

## Decorator Arguments

Decorators can accept arguments, creating three levels of callables:

```python
@decorator(A, B)
def F(arg):
    ...

F(99)
```

**Equivalent to:**

```python
def F(arg):
    ...
F = decorator(A, B)(F)    # Rebind F to result of decorator's return value

F(99)                     # Essentially calls decorator(A, B)(F)(99)
```

### Implementation Pattern

```python
def decorator(A, B):
    # Save or use A, B
    def actualDecorator(F):
        # Save or use function F
        # Return a callable: nested def, class instance with __call__, etc.
        return callable
    return actualDecorator
```

## State Retention in Decorators

Decorators need to retain state for multiple decorated objects and calls. Several approaches:

### 1. Class Instance Attributes

```python
class tracer:                                # State via instance attributes
    def __init__(self, func):                # On @ decorator
        self.calls = 0                       # Save func for later call
        self.func  = func
    def __call__(self, *args, **kwargs):     # On call to original function
        self.calls += 1
        print(f'call {self.calls} to {self.func.__name__}')
        return self.func(*args, **kwargs)
```

### 2. Global Variables

```python
calls = 0
def tracer(func):                         # State via enclosing scope and global
    def wrapper(*args, **kwargs):         # Instead of class attributes
        global calls                      # calls is global, not per-function
        calls += 1
        print(f'call {calls} to {func.__name__}')
        return func(*args, **kwargs)
    return wrapper
```

**Issue**: Shared across all decorated functions.

### 3. Enclosing Scope with nonlocal

```python
def tracer(func):                        # State via enclosing scope and nonlocal
    calls = 0                            # Instead of class attrs or global
    def wrapper(*args, **kwargs):        # calls is per-function, not global
        nonlocal calls
        calls += 1
        print(f'call {calls} to {func.__name__}')
        return func(*args, **kwargs)
    return wrapper
```

**Advantage**: Per-function state, not shared.

### 4. Function Attributes

```python
def tracer(func):                        # State via enclosing scope and func attr
    def wrapper(*args, **kwargs):        # calls is per-function, not global
        wrapper.calls += 1
        print(f'call {wrapper.calls} to {func.__name__}')
        return func(*args, **kwargs)
    wrapper.calls = 0
    return wrapper
```

**Advantage**: Accessible from outside the decorator.

## Method Decoration Pitfall

### The Problem

Class-based decorators fail on methods because:
- `self` in `__call__` receives the decorator instance, not the subject class instance
- The subject class instance is not passed in the arguments

```python
class tracer:
    def __init__(self, func):
        self.calls = 0
        self.func = func
    def __call__(self, *args, **kwargs):  # self = tracer instance
        self.calls += 1
        print(f'call {self.calls} to {self.func.__name__}')
        return self.func(*args, **kwargs)  # Missing subject instance!

class Person:
    @tracer
    def giveRaise(self, percent):  # FAILS - missing Person instance
        self.pay *= (1.0 + percent)
```

### The Solution

Use nested functions instead of classes:

```python
def tracer(func):                        
    calls = 0                            
    def wrapper(*args, **kwargs):        # args[0] = subject instance for methods
        nonlocal calls
        calls += 1
        print(f'call {calls} to {func.__name__}')
        return func(*args, **kwargs)     # Properly passes subject instance
    return wrapper
```

## Advanced: Descriptor-Based Method Decoration

For complex cases, descriptors can handle both the decorator state and method dispatch:

```python
class tracer(object):                        # A decorator+descriptor
    def __init__(self, func):                # On @ decorator
        self.calls = 0                       
        self.func  = func
    def __call__(self, *args, **kwargs):     # On call to original func/meth
        self.calls += 1
        print(f'call {self.calls} to {self.func.__name__}')
        return self.func(*args, **kwargs)
    def __get__(self, instance, owner):      # On method attribute fetch
        def wrapper(*args, **kwargs):                  
            return self(instance, *args, **kwargs)     # Runs __call__
        return wrapper
```

## Practical Examples

### 1. Call Tracing Decorator

```python
class tracer:
    def __init__(self, func):
        self.calls = 0
        self.func = func
    def __call__(self, *args, **kwargs):
        self.calls += 1
        print(f'call {self.calls} to {self.func.__name__}')
        return self.func(*args, **kwargs)

@tracer
def hack(a, b, c):
    print(a + b + c)

hack(1, 2, 3)            # call 1 to hack, 6
hack('a', 'b', 'c')      # call 2 to hack, abc
```

### 2. Complete Function and Method Support

```python
def tracer(func):                        
    calls = 0                            
    def wrapper(*args, **kwargs):        
        nonlocal calls
        calls += 1
        print(f'call {calls} to {func.__name__}')
        return func(*args, **kwargs)
    return wrapper

@tracer
def hack(a, b, c):           # Works for functions
    print(a + b + c)

class Person:
    def __init__(self, name, pay):
        self.name = name
        self.pay = pay
    
    @tracer
    def giveRaise(self, percent):        # Works for methods too
        self.pay *= (1.0 + percent)
```

## Key Design Principles

### When to Use Decorators

**Advantages:**
- Explicit syntax makes intent clear
- Applied once at definition time
- Reduces code redundancy
- Ensures consistent API usage
- Fosters code encapsulation

**Considerations:**
- May alter object types
- Can incur extra call overhead
- Can add complexity

### Best Practices

1. **For both functions and methods**: Use nested function pattern
2. **For state retention**: Choose appropriate method based on needs
   - Instance attributes: When decorator needs its own state
   - Nonlocal variables: For per-function changeable state
   - Function attributes: When state needs external access
3. **For complex scenarios**: Consider descriptor-based approaches
4. **For simplicity**: Prefer function-based over class-based when possible

## Common Use Cases

1. **Call tracing and logging**
2. **Argument validation**
3. **Caching/memoization**
4. **Timing function calls**
5. **Access control**
6. **API registration**
7. **Property creation**
8. **Static/class method declaration**

## Summary

Decorators provide a powerful and clean way to augment functions and classes with additional behavior. Understanding the underlying name rebinding mechanism, state retention options, and the differences between function and class-based implementations is crucial for effectively using and creating decorators in Python.

The key insight is that decorators are fundamentally about **callable objects managing callable objects** through automatic name rebinding at definition time, enabling clean separation of concerns and reusable augmentation patterns.