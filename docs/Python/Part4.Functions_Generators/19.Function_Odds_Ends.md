# Chapter 19: Function Odds and Ends

## Overview
This chapter covers advanced function-related topics including recursive functions, function attributes, annotations, decorations, lambda expressions, and functional programming tools like `map`, `filter`, and `reduce`.

## Function Design Concepts

### General Guidelines

#### Coupling Principles
- **Use arguments for inputs and return for outputs**: Make functions independent of the outside world
- **Minimize global variables**: Only use when truly necessary as they create dependencies and timing issues
- **Don't change mutable arguments unless expected**: Avoid tight coupling between caller and callee
- **Avoid changing variables in other modules directly**: Use accessor functions instead

#### Cohesion and Size
- **Single, unified purpose**: Each function should do one thing that can be summarized in a simple sentence
- **Keep functions small**: Long or deeply nested functions often indicate design problems
- **Keep it simple**: Python code is concise, so complexity is usually unnecessary

### Function Communication Methods
Functions can communicate with the outside world through:
- **Inputs**: Arguments, global variables, nonlocals
- **Outputs**: Return statements, global variables, mutable argument changes

## Recursive Functions

### Basic Concept
Recursion allows functions to call themselves either directly or indirectly to create loops. While less common in Python due to simpler looping tools, recursion is useful for traversing arbitrary structures.

### Simple Recursion Example
```python
def mysum(L):
    if not L:
        return 0
    else:
        return L[0] + mysum(L[1:])  # Recursive call
```

### Advanced Recursion Variants
```python
# Using ternary expression
def mysum(L):
    return 0 if not L else L[0] + mysum(L[1:])

# Using extended unpacking
def mysum(L):
    first, *rest = L
    return first if not rest else first + mysum(rest)
```

### Handling Arbitrary Structures
For nested structures like `[1, [2, [3, 4], 5], 6, [7, 8]]`:

```python
def sumtree(L, trace=False):
    tot = 0
    for x in L:
        if not isinstance(x, list):
            tot += x
            if trace: print(x, end=', ')
        else:
            tot += sumtree(x, trace)  # Recurse for sublists
    return tot
```

### Recursion vs Loops
- **Loops are often better**: More concrete, no function call overhead
- **Recursion needed for**: Arbitrary structures, unknown depth/shape
- **Memory considerations**: Each recursive call uses stack space

### Recursion Alternatives: Queues and Stacks

#### Breadth-First (Queue)
```python
def sumtree(L, trace=False):
    tot = 0
    items = list(L)
    while items:
        front = items.pop(0)
        if not isinstance(front, list):
            tot += front
        else:
            items.extend(front)  # Add to end (FIFO)
    return tot
```

#### Depth-First (Stack)
```python
def sumtree(L, trace=False):
    tot = 0
    items = list(L)
    while items:
        front = items.pop(0)
        if not isinstance(front, list):
            tot += front
        else:
            items[:0] = front  # Add to front (LIFO)
    return tot
```

### Recursion Best Practices
- **Avoid cycles**: Check for visited states
- **Record paths**: For solution reporting
- **Manage stack limits**: Use `sys.setrecursionlimit()` if needed
- **Consider alternatives**: Explicit stacks/queues for complex traversals

## Function Tools: Attributes, Annotations, Decorators

### First-Class Object Model
Functions are objects that can be:
- Assigned to variables
- Passed as arguments
- Stored in data structures
- Returned from other functions

```python
def exclaim(message):
    print(message + '!')

x = exclaim                    # Assign to variable
generic(exclaim, 'Hello')      # Pass as argument
schedule = [(exclaim, 'Hi')]   # Store in data structure
```

### Function Introspection
```python
def func(a):
    b = 'Hack'
    return b * a

# Access function attributes
func.__name__              # 'func'
func.__code__.co_varnames  # ('a', 'b')
func.__code__.co_argcount  # 1
```

### Function Attributes
Functions can have custom attributes attached:

```python
def func(): pass
func.count = 0
func.handles = 'Button-Press'
func.count += 1
```

**Use cases:**
- State information storage
- Alternative to globals/nonlocals
- Static local variable emulation

### Function Annotations
Annotations provide metadata about function arguments and return values:

```python
def func(a: 'hack', b: (1, 10), c: float) -> int:
    return a + b + c

# Annotations stored in __annotations__ dictionary
func.__annotations__
# {'a': 'hack', 'b': (1, 10), 'c': <class 'float'>, 'return': <class 'int'>}
```

**Key points:**
- Completely optional
- Don't affect function behavior
- Used by third-party tools
- Can combine with defaults: `a: 'hack' = 4`

### Function Decorators (Preview)
Decorators augment functions with additional functionality:

```python
def echo(F):
    def proxy(*args):
        print('calling', F.__name__)
        return F(*args)
    return proxy

@echo
def func(x, y):
    print('I am running...', x, y)

# Equivalent to: func = echo(func)
```

## Anonymous Functions: lambda

### Basic Syntax
```python
lambda argument1, argument2, ..., argumentN : expression-using-arguments
```

### lambda vs def
| lambda | def |
|--------|-----|
| Expression | Statement |
| Returns function object | Assigns to name |
| Single expression body | Multiple statements allowed |
| Can appear in literals/calls | Must be defined separately |

### Common Use Cases

#### Simple Operations
```python
func = lambda x, y, z: x + y + z
func(2, 3, 4)  # Returns 9
```

#### With Defaults and Scopes
```python
x = lambda a='hack', b='python': a + b
# Access to enclosing scopes (LEGB rule applies)
```

#### Jump Tables
```python
L = [lambda x: x * 2,
     lambda x: x ** 2, 
     lambda x: x // 2]

for f in L:
    print(f(5))  # Prints 10, 25, 2
```

#### Dictionary Dispatch
```python
key = 'loop'
result = {'hack': lambda s: s.upper(),
          'code': lambda s: s.lower(),
          'loop': lambda s: f'{s * 4}!'}[key]('Py')
# Returns 'PyPyPyPy!'
```

### Advanced lambda Techniques

#### Multiple Actions (Tuples)
```python
series = lambda a, b: (print(a.upper()), print(b.lower()))
```

#### Conditional Logic
```python
lower = lambda x, y: x if x < y else y
```

#### Loops (List Comprehensions)
```python
showall = lambda x: [print(y) for y in x]
```

#### Assignment (Walrus Operator)
```python
namer = lambda x: (res := x + 1) + res
```

### Nested lambda Scopes
```python
action = lambda x: (lambda y: x + y)  # Nested lambdas
act = action(99)
act(3)  # Returns 102
```

## Functional Programming Tools

### map(): Apply Function to Items
```python
# Basic usage
def inc(x): return x + 10
list(map(inc, [1, 2, 3, 4]))  # [11, 12, 13, 14]

# With lambda
list(map(lambda x: x + 3, [1, 2, 3, 4]))  # [4, 5, 6, 7]

# Multiple sequences
list(map(pow, [1, 2, 3], [2, 3, 4]))  # [1, 8, 81] (1**2, 2**3, 3**4)
```

**Equivalent list comprehension:**
```python
[inc(x) for x in [1, 2, 3, 4]]
```

### filter(): Select Items Based on Test
```python
# Basic usage
list(filter(lambda x: x > 0, range(-5, 5)))  # [1, 2, 3, 4]

# Manual equivalent
res = []
for x in range(-5, 5):
    if x > 0:
        res.append(x)
```

**Equivalent list comprehension:**
```python
[x for x in range(-5, 5) if x > 0]
```

### reduce(): Combine Items
```python
from functools import reduce

# Sum all items
reduce(lambda x, y: x + y, [1, 2, 3, 4])  # 10

# Product of all items  
reduce(lambda x, y: x * y, [1, 2, 3, 4])  # 24

# Manual equivalent
def myreduce(function, sequence):
    tally = sequence[0]
    for next in sequence[1:]:
        tally = function(tally, next)
    return tally
```

**Using operator module:**
```python
import operator, functools
functools.reduce(operator.add, [2, 4, 6])  # 12
```

## Key Takeaways

### Function Design
- Keep functions small, focused, and self-contained
- Prefer arguments/returns over globals
- Use recursion for arbitrary structures, loops for linear iteration

### Advanced Features
- Function attributes provide state storage
- Annotations offer metadata without affecting behavior
- Decorators enable function augmentation

### lambda Usage
- Best for small, inline functions
- Common in callbacks and functional programming
- Don't overuse - prefer `def` for complex logic

### Functional Tools
- `map()`: Transform all items
- `filter()`: Select items based on criteria  
- `reduce()`: Aggregate items into single result
- Often have list comprehension equivalents

### Best Practices
- Choose the right tool for the job
- Prioritize readability over cleverness
- Understand when recursion is necessary vs. optional
- Use functional tools judiciously alongside comprehensions