# Chapter 20: Comprehensions and Generators

## Overview

This chapter covers advanced function-related tools focusing on:
- **Generator functions**: User-defined ways to produce results on demand
- **Generator expressions**: Comprehension-based value generators
- **List comprehensions**: Advanced usage and applications
- **Async functions**: Brief introduction to coroutines

---

## Comprehensions: The Final Act

### List Comprehensions Review

List comprehensions apply expressions to items in iterables, providing more flexibility than `map` and `filter`.

#### Basic Syntax
```python
[expression for target in iterable]
```

#### Examples
```python
# Basic usage
>>> [ord(x) for x in 'text']
[116, 101, 120, 116]

# With condition
>>> [x for x in range(10) if x % 2 == 0]
[0, 2, 4, 6, 8]

# Combined operation and filtering
>>> [x ** 2 for x in range(10) if x % 2 == 0]
[0, 4, 16, 36, 64]
```

### Formal Comprehension Syntax

```python
[expression for target1 in iterable1 if condition1
           for target2 in iterable2 if condition2 ...
           for targetN in iterableN if conditionN]
```

#### Nested Loops
```python
>>> [x + y for x in [0, 1, 2] for y in [100, 200, 300]]
[100, 200, 300, 101, 201, 301, 102, 202, 302]

# Equivalent to:
>>> res = []
>>> for x in [0, 1, 2]:
...     for y in [100, 200, 300]:
...         res.append(x + y)
```

### Matrix Operations Example

```python
# Define matrices
>>> M = [[1, 2, 3],
...      [4, 5, 6], 
...      [7, 8, 9]]

# Extract column
>>> [row[1] for row in M]
[2, 5, 8]

# Get diagonal
>>> [M[i][i] for i in range(len(M))]
[1, 5, 9]

# Apply operation to all elements
>>> [[col + 10 for col in row] for row in M]
[[11, 12, 13], [14, 15, 16], [17, 18, 19]]
```

### When to Use List Comprehensions

**✅ Good for:**
- Simple iterations with clear logic
- Performance-critical code (faster than loops)
- Functional programming style
- Memory-efficient operations

**❌ Avoid when:**
- Logic becomes too complex
- Readability suffers
- Debugging becomes difficult

---

## Generator Functions and Expressions

### Generator Functions: yield vs return

Generator functions use `yield` to return values one at a time, suspending and resuming state.

#### Basic Generator Function
```python
def gensquares(n):
    for i in range(n):
        yield i ** 2    # Suspend here, resume later

# Usage
>>> for i in gensquares(5):
...     print(i, end=' ')
0 1 4 9 16
```

#### Manual Iteration
```python
>>> x = gensquares(3)
>>> next(x)  # 0
>>> next(x)  # 1  
>>> next(x)  # 4
>>> next(x)  # StopIteration
```

### Generator Expressions

Generator expressions are comprehensions in parentheses that return iterators instead of lists.

```python
# List comprehension (builds full list)
>>> [x ** 2 for x in range(5)]
[0, 1, 4, 9, 16]

# Generator expression (returns iterator)
>>> (x ** 2 for x in range(5))
<generator object <genexpr> at 0x...>

# Force evaluation
>>> list(x ** 2 for x in range(5))
[0, 1, 4, 9, 16]
```

### Advanced Generator Features

#### Extended Protocol: send vs next
```python
def gen():
    for i in range(10):
        X = yield i
        print('=>', X)

>>> G = gen()
>>> next(G)        # 0
>>> G.send(77)     # => 77, returns 1
>>> G.send(88)     # => 88, returns 2
```

#### yield from Extension
```python
def both(N):
    yield from range(N)
    yield from map(lambda x: x ** 2, range(N))

>>> list(both(5))
[0, 1, 2, 3, 4, 0, 1, 4, 9, 16]
```

### Generator vs Expression Comparison

| Generator Functions | Generator Expressions |
|-------------------|---------------------|
| Multiple statements | Single expression |
| More complex logic | Concise syntax |
| Better for complex state | Better for simple operations |
| `def` with `yield` | Parentheses syntax |

---

## Comprehension Types Summary

```python
# List comprehension
>>> [x * x for x in range(5)]
[0, 1, 4, 9, 16]

# Generator expression  
>>> (x * x for x in range(5))
<generator object>

# Set comprehension
>>> {x * x for x in range(5)}
{0, 1, 4, 9, 16}

# Dictionary comprehension
>>> {x: x * x for x in range(5)}
{0: 0, 1: 1, 2: 4, 3: 9, 4: 16}
```

---

## Practical Examples

### Sequence Scrambling

#### Simple Function
```python
def scramble(seq):
    return [seq[i:] + seq[:i] for i in range(len(seq))]

>>> scramble('code')
['code', 'odec', 'deco', 'ecod']
```

#### Generator Function
```python
def scramble(seq):
    for i in range(len(seq)):
        yield seq[i:] + seq[:i]

>>> list(scramble('code'))
['code', 'odec', 'deco', 'ecod']
```

#### Generator Expression
```python
>>> S = 'code'
>>> list(S[i:] + S[:i] for i in range(len(S)))
['code', 'odec', 'deco', 'ecod']
```

### Permutations Example

```python
def permute2(seq):
    if not seq:
        yield seq
    else:
        for i in range(len(seq)):
            rest = seq[:i] + seq[i+1:]
            for x in permute2(rest):
                yield seq[i:i+1] + x

>>> list(permute2('abc'))
['abc', 'acb', 'bac', 'bca', 'cab', 'cba']
```

---

## Custom map and zip Implementation

### Custom map
```python
# List version
def mymap(func, *seqs):
    return [func(*args) for args in zip(*seqs)]

# Generator version  
def mymap_func(func, *seqs):
    for args in zip(*seqs):
        yield func(*args)

# Generator expression version
def mymap_expr(func, *seqs):
    return (func(*args) for args in zip(*seqs))
```

### Custom zip with Padding
```python
def mymapPad(*seqs, pad=None):
    seqs = [list(S) for S in seqs]
    while any(seqs):
        yield tuple((S.pop(0) if S else pad) for S in seqs)

>>> list(mymapPad('abc', 'xyz123', pad=99))
[('a', 'x'), ('b', 'y'), ('c', 'z'), (99, '1'), (99, '2'), (99, '3')]
```

---

## Asynchronous Functions: Brief Overview

### Basic Async Syntax

```python
import asyncio

async def producer(label):
    await asyncio.sleep(2)  # Non-blocking sleep
    return f'Done: {label}'

async def main():
    # Create concurrent tasks
    task1 = asyncio.create_task(producer('task1'))
    task2 = asyncio.create_task(producer('task2'))
    
    # Wait for results
    print(await task1)
    print(await task2)

# Run the async program
asyncio.run(main())
```

### Key Async Concepts

- **`async def`**: Defines a coroutine function
- **`await`**: Suspends execution until awaited object completes
- **Tasks**: Enable concurrent execution of coroutines
- **Event Loop**: Manages and runs async operations

### Async Alternatives

```python
# Using gather
results = await asyncio.gather(coro1, coro2, coro3)

# Using as_completed
for nextdone in asyncio.as_completed(coros):
    print(await nextdone)

# Using TaskGroup (recommended)
async with asyncio.TaskGroup() as tg:
    tasks = [tg.create_task(producer(f'task{i}')) for i in range(3)]
```

---

## Performance Considerations

### Generator Benefits
- **Memory efficiency**: Don't store entire result set
- **Lazy evaluation**: Compute values on demand
- **Time distribution**: Spread computation across iterations
- **Infinite sequences**: Can represent unbounded data

### When Generators Excel
```python
import math

# Large factorial - list version fails
>>> math.factorial(50)  # Huge number!
>>> p = permute2(list(range(50)))  # Generator works
>>> next(p)  # Returns immediately

# List version would consume massive memory and time
```

---

## Important Notes and Gotchas

### Single-Pass Iterators
```python
>>> G = (x for x in range(3))
>>> list(G)  # [0, 1, 2]
>>> list(G)  # [] - exhausted!

# Need new generator for another pass
>>> G = (x for x in range(3))
```

### Variable Scoping in Comprehensions
```python
>>> X = 99
>>> [X for X in range(5)]  # [0, 1, 2, 3, 4]
>>> X  # 99 - unchanged (localized in comprehension)

# But walrus operator leaks out
>>> [(temp := x) for x in range(3)]  # [0, 1, 2]
>>> temp  # 2 - leaked!
```

### Python Version Compatibility Issues
```python
# Pre-3.7: StopIteration propagated through generators
# 3.7+: Must catch StopIteration explicitly in generators
def myzip(*args):
    iters = list(map(iter, args))
    while iters:
        try:
            res = [next(i) for i in iters]
        except StopIteration:
            return  # Explicit return needed in 3.7+
        yield tuple(res)
```

---

## Best Practices

### Comprehensions
1. **Keep it simple**: If you need comments to explain, use a loop
2. **Prefer readability**: Code is read more than written
3. **Use for appropriate complexity**: Single expressions work best
4. **Consider performance**: Comprehensions often faster than loops

### Generators  
1. **Use for large datasets**: When memory matters
2. **Consider lazy evaluation**: When not all results needed immediately
3. **Document generator functions**: Make the lazy behavior clear
4. **Handle exhaustion**: Remember single-pass limitation

### Async Functions
1. **Use sparingly**: Only when concurrency needed
2. **Understand the ecosystem**: Async spreads through codebase
3. **Consider alternatives**: Threading/multiprocessing may be simpler
4. **Learn the patterns**: Tasks, gather, as_completed, etc.

---

## Quick Reference

### Syntax Summary
```python
# Comprehensions
[expr for item in iterable if condition]        # List
{expr for item in iterable if condition}        # Set  
{k: v for item in iterable if condition}        # Dict
(expr for item in iterable if condition)        # Generator

# Generator function
def gen_func():
    yield value

# Async function  
async def async_func():
    result = await other_async_func()
    return result
```

### Key Built-ins for Iteration
- `map()`, `filter()`, `zip()` - Functional tools
- `iter()`, `next()` - Manual iteration
- `enumerate()`, `reversed()` - Iteration helpers
- `any()`, `all()` - Boolean aggregation
- `sum()`, `min()`, `max()` - Numeric aggregation