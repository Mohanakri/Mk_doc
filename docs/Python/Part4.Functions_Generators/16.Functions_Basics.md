# Chapter 16: Function Basics

## What are Functions?

A **function** is a package of code invoked by name that:
- Labels and groups statements for reuse
- Computes result values
- Accepts parameters as inputs
- Makes operations generally useful tools

Functions are the alternative to programming by cutting and pasting code - they allow us to factor operations into single, reusable units.

## Why Use Functions?

### 1. Maximizing Reuse and Minimizing Redundancy
- Simplest way to package logic for multiple uses
- Reduce code redundancy in programs
- Reduce maintenance effort (only one copy to update)

### 2. Dividing and Conquering
- Split systems into manageable pieces with well-defined roles
- Example: Pizza-making robot with separate functions for each subtask
- Makes larger tasks more practical

### 3. Implementing Object Methods
- Functions provide procedure (how to do something)
- When paired with an implied subject, become object-specific behavior (methods)

## Function-Related Tools Overview

| Statement/Expression | Example | Purpose |
|---------------------|---------|---------|
| Call expressions | `myfunc('hack', tool=python, *versions)` | Invoke functions |
| `def` | `def printer(message): print('Hello', message)` | Create named functions |
| `return` | `def adder(a, b=1, *c): return a + b + c[0]` | Send results back |
| `lambda` | `funcs = [lambda x: x**2, lambda x: x**3]` | Create anonymous functions |
| `global` | `def changer(): global x; x = 'new'` | Access module variables |
| `nonlocal` | `def changer(): nonlocal x; x = 'new'` | Access enclosing function variables |
| `yield` | `def squares(x): for i in range(x): yield i ** 2` | Create generators |
| `async/await` | `async def consumer(a, b): await producer(b)` | Create coroutines |

## Basic Function Tools

### `def` Statement
- Creates a function and assigns it to a name
- **Executable code** - function doesn't exist until Python runs the `def`
- Can be nested inside other statements

**Format:**
```python
def name(arg1, arg2, ... argN):    # Define function
    statements                     # Function body

name(val1, val2, ... valN)         # Call it later
```

### `return` Statement
- Sends result back to caller
- Can appear anywhere in function body
- Optional - functions return `None` by default if no return statement

**Format:**
```python
def name(arg1, arg2, ... argN):
    ...
    return result                  # Result of call expression
```

### `lambda` Expression
- Creates anonymous functions
- Limited to single expressions (no statements)
- Returns function object as result

**Format:**
```python
name = lambda arg1, arg2, ... argN: expression
name(val1, val2, ... valN)
```

## Key Concepts

### Functions are First-Class Objects
```python
def func(): ...
othername = func       # Assign function object
othername()           # Call through new name
func.attr = value     # Attach attributes
```

### `def` Executes at Runtime
```python
if test:
    def func():       # Define this way
        ...
else:
    def func():       # Or this way
        ...
func()               # Call selected version
```

### Arguments are Passed by Assignment
- Arguments match parameter names left to right by default
- Can pass by name with `name=value` syntax
- No type constraints on arguments or return values

## Polymorphism in Python

**Polymorphism** means the meaning of an operation depends on the objects being operated upon.

### Example: The `times` Function
```python
def times(x, y):
    return x * y

# Works with numbers
times(2, 4)           # Returns 8

# Works with strings and numbers  
times('Py', 4)        # Returns 'PyPyPyPy'

# Error with incompatible types
times('not', 'quite') # TypeError
```

### Benefits of Polymorphic Design
- Single function works on whole categories of object types
- Code to object interfaces, not specific data types
- Automatically works with future compatible types
- Python detects interface mismatches automatically

## Practical Example: Sequence Intersection

### Problem
Original code was limited to specific variables and couldn't be reused.

### Solution: Function
```python
def intersect(seq1, seq2):
    res = []                    # Start empty
    for x in seq1:              # Scan seq1
        if x in seq2:           # Common item?
            res.append(x)       # Add to end
    return res
```

### Benefits of Function Approach
1. **Reusable tool** - run as many times as needed
2. **General** - works on any two sequences
3. **Maintainable** - change code in only one place  
4. **Importable** - can be used by any program

### Usage Examples
```python
from inter1 import intersect

s1 = 'HACK'
s2 = 'CHOK'
intersect(s1, s2)           # Returns ['H', 'C', 'K']

# Works with mixed types
intersect([1, 2, 3], (1, 4)) # Returns [1]
```

### Alternative Implementations
```python
# List comprehension
[x for x in s1 if x in s2]

# Lambda with comprehension  
intersect = lambda seq1, seq2: [x for x in seq1 if x in seq2]
```

## Local Variables

Variables inside functions are **local** by default:
- `res` - explicitly assigned
- `seq1`, `seq2` - function parameters (passed by assignment)
- `x` - loop variable (assigned by for loop)

**Characteristics:**
- Visible only inside the function
- Exist only while function runs
- Don't clash with names elsewhere
- Don't remember values between calls

## Best Practices

### Embrace Polymorphism
- Don't check object types unnecessarily
- Code to object interfaces
- Let Python detect type mismatches

### Avoid Type Checking
```python
# Don't do this - limits flexibility
def times(x, y):
    if isinstance(x, int) and isinstance(y, int):
        return x * y
    else:
        raise TypeError("Only integers allowed")

# Do this - works with any compatible types
def times(x, y):
    return x * y
```

### Benefits of Python's Approach
- **Pros:** Less code to write, more flexible, works with future types
- **Cons:** Need to test code to detect some errors
- **Net result:** Significant win in practice

## Summary

Functions in Python are:
- Executable statements that create objects at runtime
- Polymorphic by design - work with any compatible object types
- First-class objects that can be assigned, stored, and manipulated
- The foundation for code reuse and program organization

The key to effective Python programming is embracing polymorphism and coding to object interfaces rather than specific types.