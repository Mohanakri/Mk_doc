# Chapter 17: Python Scopes

## Overview
Python scopes determine where variables are defined and looked up in your code. They help prevent name clashes and make functions more self-contained.

## Key Concepts

### Namespaces and Scopes
- **Namespace**: A place where names live
- **Scope**: The location of a name's assignment determines its visibility
- Names spring into existence when first assigned
- Assignment location determines which namespace a name belongs to

### Basic Scope Rules
- Names assigned inside a `def` are **local** to that function
- Names assigned inside a `def` don't clash with names outside
- Local names cannot be referenced from outside the function
- Variable scope is determined by where it's assigned, not by function calls (**lexical scoping**)

## The Three Scopes

### 1. Local Scope
- Variables assigned inside a `def` or `lambda`
- Only visible within that function

### 2. Nonlocal Scope  
- Variables assigned in an enclosing `def` or `lambda`
- Accessible to nested functions

### 3. Global Scope
- Variables assigned outside all `def`s and `lambda`s
- Visible throughout the entire file

## The LEGB Rule

Python searches for names in this order:

1. **L**ocal - Current function's scope
2. **E**nclosing - Any enclosing function's scope  
3. **G**lobal - Module's scope
4. **B**uilt-in - Built-in names

```python
# Example of LEGB rule
X = 99                     # Global scope

def func():
    X = 88                 # Local scope - different from global X
    print(X)               # Prints 88 (local)

func()
print(X)                  # Prints 99 (global)
```

## Built-in Scope

The built-in scope is implemented as the `builtins` module:

```python
import builtins
dir(builtins)  # Shows all built-in names like print, len, etc.

# Two ways to access built-ins:
zip                    # Normal way (LEGB rule)
builtins.zip          # Manual import way
```

### Shadowing Built-ins
You can accidentally hide built-in names:

```python
def hider():
    open = 'text'      # Shadows built-in open function
    # open('file.txt')  # Error! open is now a string
```

## The `global` Statement

Use `global` to modify variables in the module scope from within a function:

```python
X = 88                 # Global variable

def func():
    global X
    X = 99             # Changes the global X

func()
print(X)              # Prints 99
```

### Rules for `global`:
- Global names must be declared only if assigned within a function
- Global names can be referenced without declaration (LEGB rule)
- Used for changing module-level variables from functions

## Nested Functions and Enclosing Scopes

Functions can be nested inside other functions:

```python
def outer():
    X = 88             # Enclosing scope
    def inner():
        print(X + 1)   # Accesses enclosing scope X
    inner()

outer()               # Prints 89
```

### Closures and Factory Functions

Nested functions can "remember" values from enclosing scopes:

```python
def maker(N):
    def action(X):
        return X ** N  # Remembers N from enclosing scope
    return action

f = maker(2)          # f remembers N=2
print(f(3))           # Prints 9 (3**2)

g = maker(3)          # g remembers N=3  
print(g(4))           # Prints 64 (4**3)
print(f(4))           # Still prints 16 (4**2)
```

## The `nonlocal` Statement

Use `nonlocal` to modify variables in enclosing function scopes:

```python
def outer(start):
    state = start
    def inner(label):
        nonlocal state    # Allows modification of enclosing scope
        state += 1
        print(label, state)
    return inner

F = outer(0)
F('test1')            # Prints: test1 1
F('test2')            # Prints: test2 2
```

### Rules for `nonlocal`:
- Names must already exist in an enclosing `def`
- Restricts lookup to enclosing functions only
- Cannot create new names (unlike `global`)
- Only works in nested `def`, not `lambda`

## State Retention Options

### 1. Nonlocal Variables
```python
def outer(start):
    state = start
    def inner():
        nonlocal state
        state += 1
        return state
    return inner
```

**Pros**: Clean, automatic via LEGB  
**Cons**: State not accessible outside function

### 2. Global Variables
```python
state = 0
def func():
    global state
    state += 1
    return state
```

**Pros**: Simple  
**Cons**: Only one copy, name collisions, hard to maintain

### 3. Function Attributes
```python
def outer(start):
    def inner():
        inner.state += 1
        return inner.state
    inner.state = start
    return inner
```

**Pros**: Explicit, state accessible outside  
**Cons**: More verbose

### 4. Classes (Preview)
```python
class Counter:
    def __init__(self, start=0):
        self.state = start
    
    def __call__(self):
        self.state += 1
        return self.state
```

**Pros**: Full OOP features, multiple instances  
**Cons**: More complex

## Important Gotchas

### Loop Variables and Closures
When creating functions in loops, all functions remember the **last** loop value:

```python
# WRONG - All functions remember i=4
acts = []
for i in range(5):
    acts.append(lambda x: i ** x)

print(acts[0](2))  # Prints 16 (4**2), not 0

# CORRECT - Use defaults to capture current value
acts = []
for i in range(5):
    acts.append(lambda x, i=i: i ** x)

print(acts[0](2))  # Prints 0 (0**2)
```

### Argument Defaults and Scopes
Before nested scopes existed, defaults were used to pass enclosing values:

```python
def f1():
    X = 88
    def f2(X=X):        # Capture enclosing X with default
        print(X + 1)
    f2()
```

This still works but is usually unnecessary with modern nested scopes.

## Design Guidelines

### Minimize Global Variables
- **Problem**: Global variables create dependencies and make code hard to understand
- **Solution**: Use arguments and return values instead

```python
# BAD
X = 0
def func1():
    global X
    X = 88

def func2():
    global X
    X = 77

# GOOD  
def func1():
    return 88

def func2():
    return 77

result1 = func1()
result2 = func2()
```

### Minimize Cross-File Changes
- **Problem**: Changing another module's variables is implicit and hard to track
- **Solution**: Use function calls with explicit interfaces

```python
# BAD
# first.py
X = 99

# second.py  
import first
first.X = 88      # Too implicit

# GOOD
# first.py
X = 99
def setX(value):
    global X
    X = value

# second.py
import first
first.setX(88)    # Explicit interface
```

## Special Scope Cases

### Comprehension Variables
Loop variables in comprehensions are local to the expression:

```python
[x for x in range(5)]
# x is not available outside the comprehension
```

### Exception Variables  
Exception variables are local to the `except` block:

```python
try:
    risky_operation()
except ValueError as e:
    print(e)
# e is not available here
```

### Class Scopes (Preview)
Classes create their own local scope, but follow LEGB rules for name lookup.

## Best Practices

1. **Keep it simple**: Avoid deep nesting when possible
2. **Use locals**: Prefer local variables over globals
3. **Be explicit**: Use `global` and `nonlocal` when needed
4. **Avoid shadowing**: Don't redefine built-in names unless intentional
5. **Design for reuse**: Make functions self-contained
6. **Document state**: Make state retention patterns clear

## Summary

Python's scope system:
- Uses the LEGB rule for name lookup
- Supports nested functions with closure behavior
- Provides `global` and `nonlocal` for scope control
- Offers multiple state retention strategies
- Emphasizes explicit design and minimal coupling

Understanding scopes helps you write more maintainable, predictable Python code.