# Chapter 18: Arguments - Study Notes

## Overview
This chapter explores Python's argument-passing mechanisms - how objects are sent to functions as inputs. Arguments are assigned to names in functions through object references, and Python provides flexible tools for argument matching.

## Key Concepts

### Argument-Passing Basics

**Core Principle**: All Python arguments are **passed by assignment** (object reference)

- Arguments are automatically assigned to local variable names
- No aliasing between function arguments and caller variables  
- Objects are never automatically copied
- Assignment to argument names inside functions doesn't affect the caller

```python
def f(a):
    a = 99  # Changes local variable a only

b = 88
f(b)    # a and b reference same 88 initially
print(b)  # Output: 88 (b unchanged)
```

### Arguments and Shared References

#### Immutable Arguments
- Behave like "pass by value"
- Changes don't affect the caller

#### Mutable Arguments  
- Behave like "pass by pointer"
- In-place changes affect the caller

```python
def changer(a, b):
    a = 2           # Changes local name only
    b[0] = 'mod'    # Changes shared object in place

X = 1
L = [1, 2]
changer(X, L)
print(X, L)  # Output: 1 ['mod', 2]
```

### Avoiding Mutable Argument Changes

**Make copies when needed:**
```python
L = [1, 2]
changer(X, L[:])        # Pass a copy
# OR
def changer(a, b):
    b = b.copy()        # Copy within function
    # ... rest of function
```

## Special Argument-Matching Modes

### Argument Matching Overview

| Mode | Description |
|------|-------------|
| **Positionals** | Matched left to right by position |
| **Keywords** | Matched by argument name (`name=value`) |
| **Defaults** | Default values for optional arguments |
| **Starred collectors** | Collect arbitrary arguments (`*args`, `**kwargs`) |
| **Starred unpackers** | Unpack argument collections in calls |
| **Keyword-only** | Must be passed by name only |
| **Positional-only** | Must be passed by position only (Python 3.8+) |

### Argument Matching Syntax

| Syntax | Location | Interpretation |
|--------|----------|----------------|
| `func(value)` | Caller | Normal positional argument |
| `func(name=value)` | Caller | Keyword argument |
| `func(*iterable)` | Caller | Unpack iterable as positional args |
| `func(**dict)` | Caller | Unpack dict as keyword args |
| `def func(name)` | Function | Normal argument |
| `def func(name=value)` | Function | Default argument value |
| `def func(*name)` | Function | Collect extra positional args |
| `def func(**name)` | Function | Collect extra keyword args |
| `def func(*name, name)` | Function | Keyword-only arguments |
| `def func(name, /)` | Function | Positional-only arguments |

## Examples

### Keyword and Default Arguments

```python
def f(a, b=2, c=3):
    print(a, b, c)

f(1)        # Output: 1 2 3 (uses defaults)
f(1, 4)     # Output: 1 4 3 (overrides b)
f(1, c=6)   # Output: 1 2 6 (skips b, uses keyword)
```

### Arbitrary Arguments

**Collecting arguments:**
```python
def f(*args, **kwargs):
    print(args)     # Tuple of positional args
    print(kwargs)   # Dict of keyword args

f(1, 2, 3, a=4, b=5)
# Output: (1, 2, 3)
#         {'a': 4, 'b': 5}
```

**Unpacking arguments:**
```python
def func(a, b, c, d):
    print(a, b, c, d)

args = (1, 2)
kwargs = {'c': 3, 'd': 4}
func(*args, **kwargs)  # Output: 1 2 3 4
```

### Keyword-Only Arguments

```python
def kwonly(a, *, b, c='default'):
    print(a, b, c)

kwonly(1, b=2)          # Output: 1 2 default
kwonly(1, b=2, c=3)     # Output: 1 2 3
# kwonly(1, 2)          # Error: b must be keyword
```

### Positional-Only Arguments (Python 3.8+)

```python
def posonly(a, b, /, c):
    print(a, b, c)

posonly(1, 2, 3)        # Output: 1 2 3
posonly(1, 2, c=3)      # Output: 1 2 3
# posonly(1, b=2, c=3)  # Error: b must be positional
```

## Argument Ordering Rules

### Function Definitions
```python
def func(
    positional_only, /,           # Must be positional
    positional_or_keyword,        # Can be either
    *args,                        # Collects extra positionals
    keyword_only,                 # Must be keyword
    **kwargs                      # Collects extra keywords
):
    pass
```

### Function Calls
```python
func(
    positional_values,            # Positional arguments
    *iterable_unpack,            # Unpack iterables
    keyword=value,               # Keyword arguments  
    **dict_unpack               # Unpack mappings
)
```

## Practical Examples

### Custom Min Function
```python
def min1(*args):
    res = args[0]
    for arg in args[1:]:
        if arg < res:
            res = arg
    return res

def min2(first, *rest):
    for arg in rest:
        if arg < first:
            first = arg
    return first
```

### Print Function Emulation
```python
def print3(*args, sep=' ', end='\n', file=sys.stdout):
    output = ''
    first = True
    for arg in args:
        output += ('' if first else sep) + str(arg)
        first = False
    file.write(output + end)
```

## Best Practices

1. **Keep it simple** - Use basic positional arguments when possible
2. **Use keywords for clarity** - Makes calls self-documenting
3. **Be careful with mutable defaults** - They retain state between calls
4. **Make copies when needed** - To avoid unintended side effects
5. **Use keyword-only for configuration** - Prevents positional mistakes
6. **Follow ordering rules** - Prevents syntax errors

## Common Pitfalls

1. **Mutable default arguments** - Same object reused across calls
2. **Confusing definition vs call syntax** - `=` means different things
3. **Complex argument combinations** - Can make code hard to understand
4. **Side effects with mutable arguments** - In-place changes affect caller

## Summary

Python's argument system is built on assignment (object reference), providing:
- Flexible argument matching modes
- Optional keyword and default arguments  
- Tools for handling arbitrary numbers of arguments
- Control over how arguments must be passed
- Powerful unpacking capabilities for dynamic function calls

The key is understanding that arguments are object references, not copies, which enables both efficient parameter passing and potential side effects with mutable objects.