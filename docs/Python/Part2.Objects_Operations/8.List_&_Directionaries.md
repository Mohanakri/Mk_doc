# Chapter 8: Lists and Dictionaries

## Overview

Lists and dictionaries are Python's main collection workhorses - flexible objects that can contain and organize other objects. Both can be changed in place, grow and shrink on demand, and contain any type of object with arbitrary nesting.

---

## Lists

### Key Properties

Lists are Python's most flexible ordered collection type with these characteristics:

- **Ordered collections** of arbitrary objects
- **Accessed by offset** (0-based indexing)
- **Variable-length, heterogeneous, and arbitrarily nestable**
- **Mutable sequence** type
- **Arrays of object references** internally

### Common List Operations

| Operation | Interpretation |
|-----------|---------------|
| `L = []` | Empty list |
| `L = [123, 'abc', 1.23, {}]` | Four items: indexes 0..3 |
| `L = ['Pat', 40.0, ['dev', 'mgr']]` | Nested sublists |
| `L = list('code')` | List of iterable's items |
| `L = list(range(-4, 4))` | List of successive integers |
| `L[i]`, `L[i][j]`, `L[i:j]` | Index, nested index, slice |
| `len(L)` | Length |
| `L1 + L2`, `L * 3` | Concatenate, repeat |
| `3 in L` | Membership test |
| `for x in L: print(x)` | Iteration |

### Basic List Operations

```python
# Length and basic operations
len([1, 2, 3])                    # 3
[1, 2, 3] + [4, 5, 6]            # [1, 2, 3, 4, 5, 6]
['Py!'] * 4                      # ['Py!', 'Py!', 'Py!', 'Py!']

# Type compatibility
str([1, 2]) + '34'               # '[1, 2]34'
[1, 2] + list('34')              # [1, 2, '3', '4']
```

### Indexing and Slicing

```python
L = ['hack', 'Hack', 'HACK!']
L[2]                             # 'HACK!'
L[-2]                            # 'Hack' (negative indexing)
L[1:]                            # ['Hack', 'HACK!'] (slicing)

# Matrix example (nested lists)
matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
matrix[1]                        # [4, 5, 6]
matrix[1][1]                     # 5
matrix[2][0]                     # 7
```

### Changing Lists in Place

#### Index and Slice Assignment

```python
L = ['code', 'Code', 'CODE!']
L[1] = 'Hack'                    # Index assignment
# L is now ['code', 'Hack', 'CODE!']

L[0:2] = ['write', 'Python']     # Slice assignment
# L is now ['write', 'Python', 'CODE!']

# Slice assignment examples
L = [1, 2, 3]
L[1:2] = [4, 5]                  # Replace 1 item with 2
# L is now [1, 4, 5, 3]

L[1:1] = [6, 7]                  # Insert (replace nothing)
# L is now [1, 6, 7, 4, 5, 3]

L[1:2] = []                      # Delete (insert nothing)
# L is now [1, 7, 4, 5, 3]
```

### List Methods

#### Growing Lists

```python
L = ['write']
L.append('Python')               # Add one item at end
# L is now ['write', 'Python']

L.extend(['code', 'goodly'])     # Add multiple items at end
# L is now ['write', 'Python', 'code', 'goodly']
```

#### Sorting Lists

```python
L = ['abc', 'ABD', 'aBe']
L.sort()                         # Sort in place
# L is now ['ABD', 'aBe', 'abc']

L.sort(key=str.lower)            # Case-insensitive sort
L.sort(key=str.lower, reverse=True)  # Reverse order

# Mixed types need key function
L = [1, 'hack', 2]
L.sort(key=str)                  # Convert all to strings

# sorted() built-in returns new list
L = ['abc', 'ABD', 'aBe']
sorted(L)                        # Returns new sorted list
# L remains unchanged
```

#### Other List Methods

```python
L = [1, 2, 3, 4, 5]
L.pop()                          # Remove and return last item (5)
L.reverse()                      # Reverse in place
list(reversed(L))                # Return new reversed list

# Stack operations
L = []
L.append(1)                      # Push
L.append(2)
L.pop()                          # Pop (returns 2)

# Search and modify
L = ['hack', 'Py', 'code']
L.index('Py')                    # Find index of item (1)
L.insert(1, 'more')              # Insert at position
L.remove('code')                 # Remove by value
L.count('Py')                    # Count occurrences
```

### List Comprehensions and Iteration

```python
# List comprehensions
res = [x * 4 for x in 'code']
# ['cccc', 'oooo', 'dddd', 'eeee']

# With conditions
[x * 4 for x in 'program' if x >= 'p']
# ['pppp', 'rrrr', 'rrrr']

# Nested loops
[x + y for x in 'py' for y in '312']
# ['p3', 'p1', 'p2', 'y3', 'y1', 'y2']

# Equivalent loop code
res = []
for x in 'code':
    res.append(x * 4)
```

### List Unpacking (Python 3.5+)

```python
L = ['code', 'hack']
[*L, 2, 3, *L]                   # ['code', 'hack', 2, 3, 'code', 'hack']

# Any iterable
[*'Py', *'code', *range(3)]      # ['P', 'y', 'c', 'o', 'd', 'e', 0, 1, 2]
```

### Other Operations

```python
# Deletion
L = ['hack', 'more', 'Py', 'code']
del L[0]                         # Delete by index
del L[1:]                        # Delete slice

# Alternative to del
L[1:] = []                       # Same as del L[1:]
```

---

## Dictionaries

### Key Properties

Dictionaries are key-based collections with these characteristics:

- **Accessed by key**, not offset position
- **Insertion-ordered** collections (Python 3.7+)
- **Variable-length, heterogeneous, and arbitrarily nestable**
- **Mutable mapping** type
- **Hash tables** internally for fast retrieval

### Common Dictionary Operations

| Operation | Interpretation |
|-----------|---------------|
| `D = {}` | Empty dictionary |
| `D = {'name': 'Pat', 'age': 40.0}` | Two-item dictionary |
| `D = dict(name='Bob', age=40)` | Keyword construction |
| `D['name']` | Index by key |
| `'age' in D` | Key membership test |
| `D.keys()`, `D.values()`, `D.items()` | All keys, values, key+value pairs |
| `D.get(key, default)` | Fetch with default |
| `D.update(D2)` | Merge dictionaries |
| `len(D)` | Number of entries |
| `D[key] = value` | Add/change entries |
| `del D[key]` | Delete entry |

### Basic Dictionary Operations

```python
# Creating and accessing
D = {'hack': 1, 'Py': 2, 'code': 3}
D['Py']                          # 2
len(D)                           # 3
'code' in D                      # True
list(D.keys())                   # ['hack', 'Py', 'code']
```

### Changing Dictionaries in Place

```python
D = {'hack': 1, 'Py': 2, 'code': 3}

# Change existing entry
D['Py'] = ['app', 'dev']

# Add new entry
D['years'] = 32

# Delete entry
del D['code']                    # or D.pop('code')

# Modify nested objects
D['Py'][0] = 'program'
```

### Dictionary Methods

```python
D = {'program': 1, 'script': 2, 'app': 3}

# Get all keys, values, items
list(D.keys())                   # ['program', 'script', 'app']
list(D.values())                 # [1, 2, 3]
list(D.items())                  # [('program', 1), ('script', 2), ('app', 3)]

# Safe access
D.get('script')                  # 2 (key exists)
D.get('code')                    # None (key doesn't exist)
D.get('code', 4)                 # 4 (custom default)

# Update with another dictionary
D2 = {'code': 4, 'hack': 5, 'app': 6}
D.update(D2)                     # Merges D2 into D

# Pop operations
D.pop('app')                     # Remove and return value
```

### Dictionary Creation Methods

```python
# 1. Literal expression
{'name': 'Pat', 'age': 40}

# 2. Dynamic assignment
D = {}
D['name'] = 'Pat'
D['age'] = 40

# 3. Keyword arguments
dict(name='Pat', age=40)

# 4. Key/value pairs
dict([('name', 'Pat'), ('age', 40)])

# 5. Zip keys and values
dict(zip(['name', 'age'], ['Pat', 40]))

# 6. From keys with same value
dict.fromkeys(['a', 'b'], 0)     # {'a': 0, 'b': 0}
```

### Dictionary Unpacking (Python 3.5+)

```python
D = dict(a=4, c=3)
{'a': 1, 'b': 2, **D}           # {'a': 4, 'b': 2, 'c': 3}

# Multiple unpacking
dict(a=1, **{'b': 2}, **dict(c=3))  # {'a': 1, 'b': 2, 'c': 3}
```

### Dictionary Comprehensions

```python
# Basic comprehension
{k: v for (k, v) in zip(['a', 'b', 'c'], [1, 2, 3])}

# From single sequence
{x: x ** 2 for x in [1, 2, 3, 4]}
# {1: 1, 2: 4, 3: 9, 4: 16}

# From any iterable
{c: c * 4 for c in 'HACK'}
# {'H': 'HHHH', 'A': 'AAAA', 'C': 'CCCC', 'K': 'KKKK'}

# With expressions
{c.lower(): (c + '!') for c in ['HACK', 'PY', 'CODE']}
```

### Key Insertion Ordering (Python 3.7+)

```python
D = dict(a=1, b=2)
D['c'] = 3                       # New keys added at end
# D is {'a': 1, 'b': 2, 'c': 3}

D.pop('b')                       # Remove middle key
D['b'] = 2                       # Re-added key goes to end
# D is {'a': 1, 'c': 3, 'b': 2}

# popitem() removes most recently added
D.popitem()                      # ('b', 2)
```

### Dictionary Union Operator (Python 3.9+)

```python
D = dict(a=1, b=2)
D | {'b': 3, 'c': 4}            # {'a': 1, 'b': 3, 'c': 4}

# Equivalent to copy + update
C = D.copy()
C.update({'b': 3, 'c': 4})
```

---

## Advanced Usage Patterns

### Using Dictionaries as Flexible Lists

```python
# Integer keys simulate expandable arrays
D = {}
D[99] = 'hack'                   # No need to allocate 100 slots
D[62] = 'code'
D[30] = 'write'
# D is {99: 'hack', 62: 'code', 30: 'write'}
```

### Sparse Data Structures with Tuple Keys

```python
# 3D matrix with mostly empty positions
Matrix = {}
Matrix[(2, 3, 4)] = 88
Matrix[(7, 8, 9)] = 99

X, Y, Z = 2, 3, 4
Matrix[(X, Y, Z)]                # 88

# Handle missing keys
Matrix.get((2, 3, 6), 0)         # Returns 0 for missing key
```

### Nested Data Structures

```python
# Record-like structures
rec = {
    'title': 'Learning Python, 5th Edition',
    'date': {'year': 2013, 'month': 'July'},
    'isbns': ['1449355730', '9781449355739']
}

# Access nested data
rec['title']                     # 'Learning Python, 5th Edition'
rec['date']['year']              # 2013
rec['isbns'][1]                  # '9781449355739'
```

---

## Dictionary Views and Sets

### View Objects

```python
D = dict(a=1, b=2, c=3)
K = D.keys()                     # dict_keys view object
V = D.values()                   # dict_values view object

# Views reflect changes
del D['b']
list(K)                          # ['a', 'c'] - automatically updated
```

### Set Operations on Views

```python
D1 = {'a': 1, 'b': 2}
D2 = {'b': 3, 'c': 4}

# Keys views support set operations
D1.keys() | D2.keys()            # {'a', 'b', 'c'} union
D1.keys() & D2.keys()            # {'b'} intersection
D1.keys() - D2.keys()            # {'a'} difference
```

---

## Comparison and Sorting

### Dictionary Comparisons

```python
D1 = dict(a=1, b=2, c=3)
D2 = dict(c=3, b=2, a=1)        # Different insertion order
D1 == D2                         # True (order doesn't matter for equality)

# Magnitude comparisons need manual work
sorted(D1.items()) > sorted(D2.items())  # Compare sorted items
```

### Sorting Dictionary Keys

```python
D = {'c': 3, 'b': 2, 'a': 1}

# Convert to list first
Ks = list(D.keys())
Ks.sort()

# Or use sorted()
for k in sorted(D.keys()): 
    print(k, D[k])

# Sorted on dictionary directly (iterates keys)
for k in sorted(D): 
    print(k, D[k])
```

---

## Usage Guidelines

### Lists vs Dictionaries vs Sets

**Use Lists when:**
- Data is positionally ordered
- You need sequence operations (slicing, concatenation)
- Items are accessed by numeric index
- You need to maintain insertion order with duplicates

**Use Dictionaries when:**
- Data has meaningful labels/keys
- You need fast lookups by name
- Data is record-like with named fields
- You need mapping relationships

**Use Sets when:**
- You need unique collections
- Fast membership testing is important
- Mathematical set operations are needed
- No associated values are required

### Best Practices

1. **Prefer dict() constructor** for cleaner syntax when keys are strings
2. **Use .get()** to avoid KeyError exceptions
3. **Use list comprehensions** for simple transformations
4. **Remember mutability** - in-place operations modify original objects
5. **Consider collections.defaultdict** for complex default value scenarios
6. **Use meaningful key names** in dictionaries for code readability

---

## Common Patterns and Idioms

### Safe Dictionary Access

```python
# Safe access patterns
value = D.get(key, default_value)

if key in D:
    value = D[key]
else:
    value = default_value

try:
    value = D[key]
except KeyError:
    value = default_value
```

### Building Collections Dynamically

```python
# Building lists
items = []
for data in source:
    if condition(data):
        items.append(process(data))

# Building dictionaries
mapping = {}
for key, value in pairs:
    mapping[key] = process(value)
```

### Frequency Counting

```python
# Count occurrences
counts = {}
for item in sequence:
    counts[item] = counts.get(item, 0) + 1

# Or with defaultdict
from collections import defaultdict
counts = defaultdict(int)
for item in sequence:
    counts[item] += 1
```

---

## Memory and Performance Notes

- **Lists** store object references, not copies
- **Dictionaries** use hash tables for O(1) average lookup time
- **List operations** like append() are generally faster than concatenation
- **Dictionary views** are memory-efficient iterators
- **In-place operations** are usually faster than creating new objects
- **List comprehensions** are often faster than equivalent for loops

This comprehensive reference covers the essential concepts and operations for Python lists and dictionaries, providing both fundamental understanding and practical usage patterns.