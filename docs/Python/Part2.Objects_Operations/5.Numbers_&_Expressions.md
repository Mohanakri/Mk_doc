# Chapter 5: Numbers and Expressions

## Overview
Python's numeric support includes various object types for mathematical operations, from basic integers to specialized types like decimals and fractions.

## Numeric Object Types

### Core Numeric Types
- **Integers**: Positive and negative whole numbers (unlimited precision)
- **Floating-point**: Numbers with fractional parts
- **Complex numbers**: Real + imaginary parts (a+bj format)

### Advanced Numeric Types
- **Decimal**: Fixed-precision floating-point objects
- **Fraction**: Rational number objects (numerator/denominator)
- **Set objects**: Unordered collections for mathematical operations
- **Boolean**: True/False values (subclass of integers)

## Numeric Literals

### Basic Literals
| Literal | Interpretation |
|---------|----------------|
| `1234, -24, 0, 9_999_999_999_999` | Integers (unlimited size) |
| `1.23, 1., 3.14e-10, 4E210` | Floating-point numbers |
| `0o177, 0x9ff, 0b101010` | Octal, hex, and binary literals |
| `3+4j, 3.0+4.0j, 3J` | Complex number literals |
| `set('hack'), {1, 2, 3, 4}` | Sets: constructors and literals |
| `Decimal('1.0'), Fraction(1, 3)` | Decimal and fraction extension types |
| `bool(X), True, False` | Boolean type and constants |

### Number Base Systems
- **Hexadecimal**: `0x` or `0X` prefix (base 16, digits 0-9, A-F)
- **Octal**: `0o` or `0O` prefix (base 8, digits 0-7)
- **Binary**: `0b` or `0B` prefix (base 2, digits 0-1)

### Underscore Separators (Python 3.6+)
```python
9_999_999_999_999 == 9999999999999  # True - for readability
0xFF_FF_FF_FF == 0xFFFFFFFF         # True - grouping bytes
```

## Built-in Numeric Tools

### Expression Operators
- **Arithmetic**: `+, -, *, /, //, %, **`
- **Bitwise**: `&, |, ^, <<, >>, ~`
- **Comparison**: `<, <=, >, >=, ==, !=`

### Built-in Functions
- **Mathematical**: `pow(), abs(), round(), int(), hex(), bin()`
- **Conversion**: `float(), complex(), bool()`
- **Aggregation**: `sum(), min(), max()`

### Utility Modules
- **math**: Mathematical functions (sqrt, sin, cos, pi, e)
- **random**: Random number generation
- **statistics**: Statistical functions (mean, median)

## Python Expression Operators (by precedence)

| Operators | Description |
|-----------|-------------|
| `(...)`, `[...]`, `{...}` | Tuple, list, dictionary literals |
| `x.attr`, `x[i]`, `x(...)` | Attribute, indexing, calls |
| `**` | Exponentiation (right-to-left) |
| `+x`, `-x`, `~x` | Unary operators |
| `*`, `/`, `//`, `%`, `@` | Multiplication, division, modulo |
| `+`, `-` | Addition, subtraction |
| `<<`, `>>` | Bit shifts |
| `&` | Bitwise AND |
| `^` | Bitwise XOR |
| `|` | Bitwise OR |
| `<`, `<=`, `>`, `>=`, `==`, `!=` | Comparisons |
| `not` | Logical NOT |
| `and` | Logical AND |
| `or` | Logical OR |
| `lambda` | Anonymous functions |

## Mixed Types and Conversions

### Automatic Type Conversion
- Python converts "up" to the most complex type in expressions
- **Complexity ranking**: int < float < complex
- **Examples**:
  ```python
  40 + 3.14     # int converted to float → 43.14
  3 + 4j        # int converted to complex → (3+4j)
  ```

### Manual Conversions
```python
int(3.1415)    # Truncates → 3
float(3)       # Converts → 3.0
complex(2, 3)  # Creates → (2+3j)
```

## Division Operators

### Three Types of Division
1. **True Division** (`/`): Always returns float with remainder
2. **Floor Division** (`//`): Truncates to floor (rounds down)
3. **Modulus** (`%`): Returns remainder of division

```python
10 / 4    # 2.5 (true division)
10 // 4   # 2 (floor division)
10 % 4    # 2 (remainder)
divmod(10, 4)  # (2, 2) - both quotient and remainder
```

### Floor vs Truncation
- **Floor division** rounds down to closest whole number below result
- **Truncation** cuts off fractional part toward zero
- For positive numbers: floor = truncation
- For negative numbers: floor ≠ truncation

```python
5 // 2    # 2 (floor)
5 // -2   # -3 (floor, not truncation)
math.trunc(5 / -2)  # -2 (truncation toward zero)
```

## Numeric Display and Precision

### Floating-Point Limitations
```python
1.1 + 2.2  # 3.3000000000000003 (precision limitation)
# Solutions:
round(1.1 + 2.2, 1)      # 3.3
math.isclose(1.1 + 2.2, 3.3)  # True
```

### Display Formats
- **repr()**: Code-like representation
- **str()**: User-friendly format
- **String formatting**: Custom precision control

## Advanced Numeric Types

### Decimal Objects
```python
from decimal import Decimal
Decimal('0.1') + Decimal('0.1') + Decimal('0.1') - Decimal('0.3')  # Decimal('0.0')

# Setting precision
import decimal
decimal.getcontext().prec = 4
Decimal(1) / Decimal(7)  # Decimal('0.1429')
```

### Fraction Objects
```python
from fractions import Fraction
x = Fraction(1, 3)       # 1/3
y = Fraction(4, 6)       # Simplified to 2/3
x + y                    # Fraction(1, 1)
Fraction('0.25')         # Fraction(1, 4)
```

### Complex Numbers
```python
1j * 1J                  # (-1+0j)
2 + 1j * 3              # (2+3j)
(2 + 1j) * 3            # (6+3j)
# Access parts: .real and .imag attributes
```

## Set Objects

### Creating Sets
```python
x = set('abcde')                    # From sequence
y = {'a', 'b', 'c'}                # Literal syntax
z = set()                          # Empty set (not {})
```

### Set Operations
```python
x = set('abcd')
y = set('bdxy')

x - y        # Difference: {'a', 'c'}
x | y        # Union: {'a', 'b', 'c', 'd', 'x', 'y'}
x & y        # Intersection: {'b', 'd'}
x ^ y        # Symmetric difference: {'a', 'c', 'x', 'y'}
x < y        # Subset test
x > y        # Superset test
```

### Set Methods
```python
s = {1, 2, 3}
s.add(4)                    # Add single item
s.update([5, 6])           # Add multiple items
s.remove(1)                # Remove item (error if not found)
s.discard(1)               # Remove item (no error if not found)
```

### Set Comprehensions
```python
{x**2 for x in [1, 2, 3, 4]}           # {1, 4, 9, 16}
{c*4 for c in 'py3X'}                  # {'pppp', 'yyyy', '3333', 'XXXX'}
```

### Immutable Sets (frozenset)
```python
fs = frozenset([1, 2, 3])
# Can be used as dictionary keys or in other sets
```

## Boolean Objects

### Boolean Basics
- `True` and `False` are instances of `bool`
- `bool` is a subclass of `int`
- `True == 1` and `False == 0`
- Custom display format shows "True"/"False" instead of 1/0

```python
type(True)           # <class 'bool'>
isinstance(True, int)  # True
True + 4             # 5
True == 1            # True
True is 1            # False (different objects)
```

## Bitwise Operations

### Bitwise Operators
```python
x = 1                # Binary: 0001
x << 2               # Left shift: 0100 → 4
x | 3                # OR: 0001 | 0011 → 3
x & 3                # AND: 0001 & 0011 → 1
x ^ 3                # XOR: 0001 ^ 0011 → 2
~x                   # NOT: invert all bits
```

### Working with Binary
```python
X = 0b0001           # Binary literal
bin(X << 2)          # '0b100'
X.bit_length()       # Number of bits needed
```

## Number Base Conversions

### Converting to Strings
```python
oct(64)    # '0o100' (octal)
hex(64)    # '0x40' (hexadecimal)  
bin(64)    # '0b1000000' (binary)
```

### Converting from Strings
```python
int('64')           # 64 (decimal)
int('100', 8)       # 64 (from octal)
int('40', 16)       # 64 (from hex)
int('1000000', 2)   # 64 (from binary)
```

## Comparison Operations

### Basic Comparisons
```python
1 < 2                # True
2.0 >= 1            # True (mixed types converted)
2.0 == 2.0          # True
2.0 != 2.0          # False
```

### Chained Comparisons
```python
X < Y < Z           # Equivalent to: X < Y and Y < Z
1 < 2 < 3.0 < 4     # True
X < Y > Z           # Equivalent to: X < Y and Y > Z
```

### Floating-Point Equality Issues
```python
1.1 + 2.2 == 3.3              # False (precision issue)
# Solutions:
round(1.1 + 2.2, 1) == round(3.3, 1)  # True
math.isclose(1.1 + 2.2, 3.3)          # True
```

## Common Use Cases

### Set Operations for Data Processing
```python
# Remove duplicates
L = [1, 2, 1, 3, 2, 4, 5]
L = list(set(L))  # [1, 2, 3, 4, 5]

# Find differences
set([1, 3, 5, 7]) - set([1, 2, 4, 5, 6])  # {3, 7}

# Order-neutral equality
set([1, 2, 3]) == set([3, 2, 1])  # True
```

### Practical Applications
```python
# Database-style operations
engineers = {'pat', 'ann', 'bob', 'sue'}
managers = {'sue', 'tom'}

engineers & managers    # Who is both? {'sue'}
engineers | managers    # All people
engineers - managers    # Engineers who aren't managers
```

## Key Points to Remember

### Variable Assignment Rules
1. Variables are created when first assigned
2. Variables are replaced with values in expressions  
3. Variables must be assigned before use
4. No need to declare variable types

### Performance Considerations
- Integer math with very large numbers is slower
- Decimal and Fraction objects trade speed for precision
- Set operations are generally efficient
- String formatting is for display, not computation

### Type Conversion Hierarchy
- Automatic: int → float → complex
- Manual conversion functions available
- Mixed-type comparisons work for numbers only

### Precision and Accuracy
- Floating-point has hardware limitations
- Use Decimal for fixed-precision needs
- Use Fraction for exact rational arithmetic
- Consider rounding for display vs. computation needs