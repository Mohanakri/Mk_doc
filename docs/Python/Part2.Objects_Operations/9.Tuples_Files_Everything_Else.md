# Chapter 9: Tuples, Files, and Everything Else

## Overview

This chapter covers the final core object types in Python:
- **Tuples**: Immutable collections of objects
- **Files**: Interface to external files on your computer
- **Object comparisons, equality, and truth values**
- **Common gotchas and best practices**

---

## Tuples

### What are Tuples?

Tuples are **immutable sequences** that work like lists but cannot be changed in place.

**Key Characteristics:**
- Ordered collections of arbitrary objects
- Accessed by offset (indexing and slicing)
- Immutable sequence type
- Fixed-length, heterogeneous, and arbitrarily nestable
- Arrays of object references

### Tuple Syntax

```python
# Basic tuple creation
T = (0, 'Py', 1.2, 3)          # Four-item tuple
T = 0, 'Py', 1.2, 3            # Same as above (parentheses optional)
T = ()                          # Empty tuple
T = (0,)                        # One-item tuple (comma required!)

# Nested tuples
T = ('Pat', ('dev', 'mgr'))

# From iterables
T = tuple('hack')               # ('h', 'a', 'c', 'k')
```

### Common Tuple Operations

| Operation | Description | Example |
|-----------|-------------|---------|
| `T[i]` | Index | `T[0]` |
| `T[i:j]` | Slice | `T[1:3]` |
| `len(T)` | Length | `len(T)` |
| `T1 + T2` | Concatenation | `(1,2) + (3,4)` |
| `T * 3` | Repetition | `(1,2) * 3` |
| `'item' in T` | Membership | `'Py' in T` |
| `for x in T:` | Iteration | Loop through items |

### Tuple Methods

```python
T = (1, 2, 3, 2, 4, 2)

# Search methods
T.index(2)      # 1 (first occurrence)
T.index(2, 2)   # 3 (after offset 2)
T.count(2)      # 3 (how many 2s)
```

### Tuple Syntax Peculiarities

**Single-item tuples require a comma:**
```python
x = (40)        # This is an integer!
y = (40,)       # This is a tuple
```

**Parentheses are often optional:**
```python
# These are equivalent
T = (1, 2, 3, 4)
T = 1, 2, 3, 4

# Sequence assignment uses tuples
a, b, c = 1, 2, 3  # Both sides are tuples
```

### Converting and Processing Tuples

```python
# Convert to list for sorting
T = ('cc', 'aa', 'dd', 'bb')
tmp = list(T)
tmp.sort()
T = tuple(tmp)

# Or use sorted() built-in
sorted(T, reverse=True)  # Returns a list

# List comprehensions with tuples
T = (1, 2, 3, 4, 5)
L = [x + 20 for x in T]  # [21, 22, 23, 24, 25]

# Simulate tuple comprehension
tuple(x + 20 for x in T)  # (21, 22, 23, 24, 25)
```

### Immutability Rules

```python
T = (1, [2, 3], 4)

# This fails - can't change tuple itself
T[1] = 'mod'  # TypeError

# This works - can change mutable objects inside
T[1][0] = 'mod'  # T becomes (1, ['mod', 3], 4)
```

### Why Use Tuples?

**Use Cases:**
- **Integrity**: Immutable collections that won't change unexpectedly
- **Dictionary keys**: Tuples can be keys, lists cannot
- **Fixed associations**: When you need ordered but unchanging data
- **Function returns**: Common for returning multiple values

**Lists vs Tuples:**
- **Lists**: Ordered collections that might need to change
- **Tuples**: Fixed associations of objects

---

## Named Tuples

Named tuples provide both positional and named access to fields:

```python
from collections import namedtuple

# Create a named tuple class
Rec = namedtuple('Rec', ['name', 'age', 'jobs'])

# Create instances
pat = Rec('Pat', age=40.5, jobs=['dev', 'mgr'])

# Access by position
pat[0], pat[2]  # ('Pat', ['dev', 'mgr'])

# Access by attribute
pat.name, pat.jobs  # ('Pat', ['dev', 'mgr'])

# Convert to dictionary
D = pat._asdict()
D['name']  # 'Pat'
```

---

## Files

### File Basics

Files provide access to external files on your system through Python file objects.

**Opening Files:**
```python
# Basic syntax
file_object = open(filename, mode)

# Examples
output = open('data.txt', 'w')     # Write text
input = open('data.txt', 'r')      # Read text (default)
input = open('data.txt')           # Read text (default)
binary = open('data.bin', 'wb')   # Write binary
```

### File Modes

| Mode | Description |
|------|-------------|
| `'r'` | Read text (default) |
| `'w'` | Write text (creates/empties file) |
| `'a'` | Append text |
| `'b'` | Binary mode (add to other modes) |
| `'+'` | Read and write |

### Common File Operations

| Method | Description | Example |
|--------|-------------|---------|
| `read()` | Read entire file | `content = file.read()` |
| `read(N)` | Read N characters | `chunk = file.read(100)` |
| `readline()` | Read one line | `line = file.readline()` |
| `readlines()` | Read all lines into list | `lines = file.readlines()` |
| `write(string)` | Write string to file | `file.write('Hello')` |
| `writelines(list)` | Write list of strings | `file.writelines(lines)` |
| `close()` | Close file | `file.close()` |
| `flush()` | Flush output buffer | `file.flush()` |
| `seek(offset)` | Change file position | `file.seek(0)` |

### File Examples

**Basic File Writing and Reading:**
```python
# Writing
myfile = open('myfile.txt', 'w')
myfile.write('hello text file\n')
myfile.write('goodbye text file\n')
myfile.close()

# Reading
myfile = open('myfile.txt')
line1 = myfile.readline()  # 'hello text file\n'
line2 = myfile.readline()  # 'goodbye text file\n'
empty = myfile.readline()  # '' (end of file)
myfile.close()

# Read all at once
content = open('myfile.txt').read()
print(content)  # Displays with proper newlines
```

**File Iteration (Best Practice):**
```python
# Most efficient way to read lines
for line in open('myfile.txt'):
    print(line, end='')  # line already has \n
```

### Text vs Binary Files

**Text Files:**
- Content as `str` strings
- Unicode encoding/decoding automatic
- Newline translation by default
- Mode: `'r'`, `'w'`, `'a'`

**Binary Files:**
- Content as `bytes` strings
- No encoding/decoding
- No newline translation
- Mode: `'rb'`, `'wb'`, `'ab'`

```python
# Binary file example
myfile = open('data.bin', 'wb')
myfile.write(b'\x00\x01hack\x02\x03')
myfile.close()

data = open('data.bin', 'rb').read()
print(data)  # b'\x00\x01hack\x02\x03'
```

---

## Storing Objects in Files

### Method 1: String Conversion

```python
# Writing objects as strings
X, Y, Z = 62, 63, 64
S = 'Text'
D = {'a': 1, 'b': 2}
L = [1, 2, 3]

F = open('datafile.txt', 'w')
F.write(S + '\n')
F.write(f'{X},{Y},{Z}\n')
F.write(str(L) + '$' + str(D) + '\n')
F.close()

# Reading and parsing
F = open('datafile.txt')
line1 = F.readline().rstrip()  # Remove \n
line2 = F.readline().rstrip()
numbers = [int(x) for x in line2.split(',')]

line3 = F.readline()
parts = line3.split('$')
list_obj = eval(parts[0])  # Dangerous but works
dict_obj = eval(parts[1])
```

### Method 2: Pickle (Recommended)

```python
import pickle

# Store any Python object
D = {'a': 1, 'b': 2}
F = open('datafile.pkl', 'wb')  # Binary mode required
pickle.dump(D, F)
F.close()

# Retrieve the object
F = open('datafile.pkl', 'rb')
E = pickle.load(F)  # E == D
F.close()
```

### Method 3: JSON

```python
import json

# Create nested data
who = dict(first='Pat', last='Smith')
rec = dict(name=who, job=['dev', 'mgr'], age=40.5)

# Save to file
with open('data.json', 'w') as file:
    json.dump(rec, file, indent=4)

# Load from file
with open('data.json', 'r') as file:
    data = json.load(file)
```

### Other Storage Options

**CSV Module:**
```python
import csv

# Read CSV
with open('data.csv') as file:
    reader = csv.reader(file)
    for row in reader:
        print(row)
```

**Struct Module (Binary Data):**
```python
import struct

# Pack data
data = struct.pack('i6s', 62, b'Python')

# Unpack data
values = struct.unpack('i6s', data)  # (62, b'Python')
```

---

## File Context Managers

**With Statement (Recommended):**
```python
# Automatically closes file
with open('data.txt') as myfile:
    for line in myfile:
        process(line)
# File is automatically closed here
```

**Try/Finally (Manual):**
```python
myfile = open('data.txt')
try:
    for line in myfile:
        process(line)
finally:
    myfile.close()  # Always executes
```

---

## Object Comparisons and Truth

### Comparison Rules

**Equality (`==`) vs Identity (`is`):**
```python
L1 = [1, 2, 3]
L2 = [1, 2, 3]

L1 == L2  # True (same values)
L1 is L2  # False (different objects)

# String caching exception
S1 = 'text'
S2 = 'text'
S1 is S2  # True (Python caches short strings)
```

### Comparison Behavior by Type

**Numbers:** Compared by magnitude after type conversion
```python
1 < 1.1  # True (1 becomes 1.0)
```

**Strings:** Lexicographic comparison (by character codes)
```python
'abc' < 'ac'  # True
```

**Lists/Tuples:** Element-by-element, recursively
```python
[1, 3] > [1, 2]  # True (3 > 2)
```

**Dictionaries:** Equal if same (key, value) pairs
```python
{'a': 1, 'b': 2} == {'b': 2, 'a': 1}  # True
```

**Mixed Types:**
```python
11 == '11'   # False (different types)
11 >= '11'   # TypeError (can't compare)
```

### Truth Values

**False Values:**
- Numbers: `0`, `0.0`, `0j`
- Collections: `[]`, `()`, `{}`, `set()`
- Strings: `''`
- Special: `None`, `False`

**True Values:**
- Everything else!

```python
# Common pattern
if mylist:          # Instead of: if len(mylist) > 0:
    process(mylist)

# Using bool()
bool([])      # False
bool([1])     # True
bool('')      # False
bool('text')  # True
```

---

## Common Gotchas and Best Practices

### 1. Assignment Creates References

```python
# Problem
L = [1, 2, 3]
M = ['X', L, 'Y']
L[1] = 0           # Changes M too!
print(M)           # ['X', [1, 0, 3], 'Y']

# Solution: Copy when needed
M = ['X', L[:], 'Y']  # Embed a copy
```

### 2. Repetition Creates Shared References

```python
# Problem
L = [4, 5, 6]
Y = [L] * 4        # Four references to same list
L[1] = 0           # Changes all four!

# Solution: Create separate copies
Y = [list(L) for i in range(4)]  # Four separate copies
```

### 3. Cyclic Data Structures

```python
# Creates a cycle
L = ['stuff']
L.append(L)        # L now contains reference to itself
print(L)           # ['stuff', [...]]
```

### 4. Immutable Types Can't Be Changed

```python
# Problem
T = (1, 2, 3)
T[2] = 4          # TypeError!

# Solution: Create new object
T = T[:2] + (4,)  # (1, 2, 4)
```

### 5. File Handling Best Practices

```python
# Good: Use context managers
with open('file.txt', 'w') as f:
    f.write('data')
# File automatically closed

# Avoid: Manual close (error-prone)
f = open('file.txt', 'w')
f.write('data')
f.close()  # Might not execute if error occurs
```

---

## Key Takeaways

1. **Tuples** are immutable sequences - use for fixed data
2. **Files** require explicit opening/closing - use context managers
3. **Pickle** for Python objects, **JSON** for interoperability
4. **Understanding references** prevents unexpected object sharing
5. **Truth testing** works on all objects - empty = False
6. **Copy objects** when you need independence from originals
7. **Use appropriate comparison operators** (== for value, is for identity)

---

## Quick Reference

### Tuple Creation
```python
()              # Empty
(item,)         # Single item (comma required)
(a, b, c)       # Multiple items
tuple(sequence) # From sequence
```

### File Operations
```python
# Reading
with open('file.txt') as f:
    content = f.read()        # All content
    lines = f.readlines()     # All lines
    line = f.readline()       # One line

# Writing  
with open('file.txt', 'w') as f:
    f.write('text')           # Write string
    f.writelines(lines)       # Write list of strings
```

### Object Storage
```python
# Pickle (Python objects)
import pickle
pickle.dump(obj, file)
obj = pickle.load(file)

# JSON (limited types, portable)
import json
json.dump(obj, file)
obj = json.load(file)
```