# Python String Fundamentals - Chapter 7 Notes

## Overview
Strings are **immutable sequences** of characters used to store and represent text-based information. They are ordered collections with positional indexing.

## String Literal Forms

### Basic Quote Types
```python
# Single quotes
'cod"e'

# Double quotes  
"cod'e"

# Triple quotes (multiline)
'''...code...'''
"""...code..."""
```

### Special String Types
```python
# Escape sequences
"c\to\nd\0e"

# Raw strings (ignore escapes)
r"C:\new\test.bin"

# Bytes literals (Chapter 37)
b'co\x01de'

# Unicode literals (Chapter 37)  
'h\u00c4ck'
```

## Escape Sequences

### Common Escape Characters
| Escape | Meaning |
|--------|---------|
| `\\` | Backslash (stores one \) |
| `\'` | Single quote |
| `\"` | Double quote |
| `\n` | Newline |
| `\r` | Carriage return |
| `\t` | Horizontal tab |
| `\v` | Vertical tab |
| `\a` | Bell |
| `\b` | Backspace |
| `\f` | Formfeed |

### Numeric Escapes
| Escape | Meaning |
|--------|---------|
| `\xhh` | Hexadecimal (exactly 2 hex digits) |
| `\ooo` | Octal (up to 3 digits, 377 ceiling) |
| `\0` | Null character |
| `\uhhhh` | Unicode 16-bit (exactly 4 hex digits) |
| `\Uhhhhhhhh` | Unicode 32-bit (exactly 8 hex digits) |
| `\N{name}` | Unicode character by name |

### Examples
```python
s = 'a\nb\tc'  # newline and tab
print(s)
# Output:
# a
# b    c

s = 'a\0b\0c'  # null characters
len(s)  # 5 characters
```

## Raw Strings
Raw strings suppress escape sequence processing by prefixing with `r`:

```python
# Problem with regular strings on Windows
myfile = open('C:\new\text.dat', 'w')  # \n and \t interpreted as escapes

# Solution with raw strings
myfile = open(r'C:\new\text.dat', 'w')  # Backslashes preserved

# Alternative: double backslashes
myfile = open('C:\\new\\text.dat', 'w')
```

**Note:** Raw strings cannot end with an odd number of backslashes.

## Triple-Quoted Strings

### Multiline Text
```python
quip = """Python strings
  sure have
a lot of options"""

print(quip)
# Output:
# Python strings
#   sure have  
# a lot of options
```

### Common Uses
- Multiline error messages
- Embedded HTML, XML, JSON, YAML
- Docstrings (documentation)
- Temporarily disabling code blocks

## String Operations

### Basic Operations
```python
# Length
len('abc')  # 3

# Concatenation
'abc' + 'def'  # 'abcdef'

# Repetition
'Py!' * 4  # 'Py!Py!Py!Py!'

# Membership testing
'k' in 'hack'  # True
'HACK' in 'abcHACKdef'  # True

# Iteration
for c in 'hack':
    print(c, end=' ')  # h a c k e r
```

### Indexing and Slicing

#### Indexing Rules
- First item at offset 0
- Negative indexes count from end (-1 is last)
- Out-of-bounds offsets raise IndexError

```python
S = 'code'
S[0]    # 'c' (first character)
S[-1]   # 'e' (last character)
S[-2]   # 'd' (second from end)
```

#### Slicing Rules
- Format: `S[start:end:step]`
- Upper bound is non-inclusive
- Defaults: start=0, end=len(S), step=1
- Out-of-bounds offsets are adjusted

```python
S = 'code'
S[1:3]    # 'od' (offsets 1 and 2)
S[1:]     # 'ode' (offset 1 to end)
S[:-1]    # 'cod' (all but last)
S[::-1]   # 'edoc' (reverse)
S[::2]    # 'cd' (every other character)
```

## String Conversion

### Type Conversions
```python
# String to number
int('62')     # 62
float('1.5')  # 1.5

# Number to string  
str(62)       # '62'
str(3.14)     # '3.14'

# Mixed operations require conversion
'62' + str(1)     # '621' (concatenation)
int('62') + 1     # 63 (addition)
```

### Character Code Conversions
```python
# Character to code point
ord('h')      # 104

# Code point to character
chr(104)      # 'h'

# Process all characters
for c in 'hack':
    print(c, ord(c))
# h 104
# a 97  
# c 99
# k 107
```

## String Comparisons
Strings are compared lexicographically (by character code points):

```python
'hack' == 'hack'  # True
'hact' > 'hack'   # True (t > k)
'hacker' > 'hack' # True (longer wins when prefix matches)
```

## String Methods

### Method Call Syntax
```python
S = 'hack'
result = S.find('ac')  # Call find method on string S
```

### Common String Methods

#### Search and Replace
```python
S = 'textly!'
S.find('ly')           # 4 (position of substring)
S.replace('ly', 'ful') # 'textful!' (replace all occurrences)
S.replace('PY', 'CODE', 1)  # Replace only first occurrence

# Multiple replacements
'WHAT and HOW'.replace('WHAT', 'CODE').replace('HOW', 'PYTHON')
```

#### Case Conversion
```python
S = "Python's strings"
S.upper()      # "PYTHON'S STRINGS"
S.lower()      # "python's strings" 
S.title()      # "Python'S Strings"
S.capitalize() # "Python's strings"
S.swapcase()   # "pYTHON'S STRINGS"
```

#### Content Testing
```python
S = "Python123"
S.isalpha()     # False (contains numbers)
S.isdigit()     # False (contains letters)
S.isalnum()     # True (alphanumeric)
S.islower()     # False
S.isupper()     # False
S.isspace()     # False
```

#### Whitespace Handling
```python
S = "  Python  \n"
S.strip()       # "Python" (remove leading/trailing whitespace)
S.lstrip()      # "Python  \n" (remove leading)
S.rstrip()      # "  Python" (remove trailing)
```

#### Parsing and Splitting
```python
# Split on whitespace (default)
'aaa bbb  ccc'.split()    # ['aaa', 'bbb', 'ccc']

# Split on specific delimiter
'Python,3.12,scripting'.split(',')  # ['Python', '3.12', 'scripting']

# Join list back to string
'-'.join(['a', 'b', 'c'])  # 'a-b-c'
```

#### Prefix/Suffix Testing
```python
S = "Python programming"
S.startswith('Python')    # True
S.endswith('ing')         # True
S.endswith('gram', 7, 15) # True (substring from 7 to 15)
```

## String Formatting

Python provides three main formatting approaches:

### 1. Formatting Expression (% operator)
```python
# Basic substitution
'There are %d ways to %s!' % (3, 'format')
# 'There are 3 ways to format!'

# Type-specific codes
'%d %s %g you' % (1, 'formatter', 4.0)
# '1 formatter 4 you'

# %s works with any type
'%s -- %s -- %s' % (42, 3.14159, [1, 2, 3])
# '42 -- 3.14159 -- [1, 2, 3]'
```

#### Format Codes
| Code | Meaning |
|------|---------|
| `%s` | String (any object) |
| `%d` | Decimal integer |
| `%f` | Floating point |
| `%e` | Exponential notation |
| `%g` | General format |
| `%x` | Hexadecimal |
| `%o` | Octal |

#### Advanced Formatting
```python
x = 1234
'%d...%-6d...%06d' % (x, x, x)
# '1234...1234  ...001234'

x = 1.23456789
'%-6.2f | %05.2f | %+06.1f' % (x, x, x)
# '1.23   | 01.23 | +001.2'
```

#### Dictionary-Based Formatting
```python
'%(qty)s more %(tool)s' % {'qty': 1, 'tool': 'formatter'}
# '1 more formatter'

# Using variables
name = 'Pat'
year = 2024
'%(name)s from %(year)s' % vars()
# 'Pat from 2024'
```

### 2. Format Method
```python
# Positional arguments
'{}, {}, and {}'.format('expr', 'method', 'fstring')
# 'expr, method, and fstring'

# Numbered positions
'{0}, {1}, and {2}'.format('expr', 'method', 'fstring')
# 'expr, method, and fstring'

# Keyword arguments
'{first}, {second}, and {third}'.format(
    first='expr', second='method', third='fstring')
# 'expr, method, and fstring'
```

#### Advanced Format Method
```python
# Object attributes and dictionary keys
import sys
'This {1[kind]} runs {0.platform}'.format(sys, {'kind': 'laptop'})

# Format specifications
'{:10} = {:10}'.format('text', 123.4567)
# 'text       =   123.4567'

'{:>10} = {:<10}'.format('text', 123.4567)  
# '      text = 123.4567  '

# Number formatting
'{:,.2f}'.format(12345.678)     # '12,345.68'
'{:X}, {:o}, {:b}'.format(255, 255, 255)  # 'FF, 377, 11111111'
```

### 3. F-String Literals (Python 3.6+)
```python
what = 'coding'
tool = 'Python'

# Basic interpolation
f'Learning {what} in {tool}'
# 'Learning coding in Python'

# Expressions in braces
f'Learning {what.upper() + "!"} in {tool + str(3.12)}'
# 'Learning CODING! in Python3.12'
```

#### F-String Format Specifications
```python
a = 3.14156
b = 1_234_567

# Number formatting
f'{a:.2f} and {b:09}'           # '3.14 and 001234567'
f'{a * 1000:,.2f} and {b:,}'    # '3,141.56 and 1,234,567'
f'{a * 1000:e} and {b:+012,}'   # '3.141560e+03 and +001,234,567'

# Debug with =
f'{a=:.2f} and {b=:,}'          # 'a=3.14 and b=1,234,567'

# String modes
c = 'h\xc4ck'
f'{c!s} and {c!r} and {c!a}'    # "hÄck and 'hÄck' and 'h\\xc4ck'"
```

## Type Categories

### Immutable vs Mutable
- **Immutable**: numbers, strings, tuples, frozensets
  - Cannot be changed in place
  - Operations create new objects
- **Mutable**: lists, dictionaries, sets, bytearray
  - Can be modified in place
  - Support direct modification operations

### Operation Categories
1. **Numbers**: Support arithmetic operations
2. **Sequences**: Support indexing, slicing, concatenation
3. **Mappings**: Support key-based indexing

## Best Practices

### Changing Strings
Since strings are immutable, create new strings:
```python
# Build new string with operations
S = 'text'
S = S + 'ual!'              # 'textual!'
S = S[:4] + ' processing'   # 'text processing'

# Use methods
S = S.replace('text', 'data')  # 'data processing'

# For many changes, use list manipulation
S = 'text'
L = list(S)           # ['t', 'e', 'x', 't']
L[0] = 'h'
S = ''.join(L)        # 'hext'
```

### Template Usage
```python
# For collected values
values = {'tool': 'Python', 'role': 'scripting'}

# Expression with dictionary
'Use %(tool)s for %(role)s.' % values

# Method with unpacking
'Use {tool} for {role}.'.format(**values)

# F-string with variables
tool, role = 'Python', 'scripting'
f'Use {tool} for {role}.'
```

## Common Gotchas

1. **Immutability**: Strings cannot be changed in place
2. **Raw string limitations**: Cannot end with odd number of backslashes
3. **F-string quote nesting**: Requires Python 3.12+ for same quotes
4. **Escape warnings**: Invalid escapes will become errors in future Python versions
5. **Template vs code**: F-strings are runtime code, not static templates

## Performance Tips

1. Use `join()` for concatenating many strings
2. Consider `bytearray` for frequent modifications of simple text
3. F-strings are generally fastest for simple substitutions
4. Format method allows reusable templates
5. Expression format is most compact for simple cases