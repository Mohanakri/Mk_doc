# Chapter 4: Introducing Python Objects

## Overview

In Python, we do "things" with "stuff":
- **Things**: Operations like addition and concatenation
- **Stuff**: Objects on which we perform those operations

> Everything in Python is an object - even simple numbers qualify with values and supported operations.

## The Python Conceptual Hierarchy

```
Programs are composed of modules
├── Modules contain statements
    ├── Statements contain expressions
        └── Expressions create and process objects
```

## Why Use Built-in Objects?

### Key Benefits

1. **Easy to Write**: Powerful tools like collections (lists) and search tables (dictionaries) are available immediately
2. **Foundation for Extensions**: Custom objects are often built on top of built-in objects
3. **Performance**: Built-in objects use optimized algorithms, often implemented in C
4. **Standardization**: Always the same across Python installations

## Python's Core Object Types

| Object Type | Example Literals/Creation |
|-------------|---------------------------|
| **Numbers** | `1234`, `3.1415`, `0b111`, `1_234`, `3+4j`, `Decimal`, `Fraction` |
| **Strings** | `'code'`, `"app's"`, `b'a\x01c'`, `'h\u00c4ck'`, `'hÄck'` |
| **Lists** | `[1, [2, 'three'], 4.5]`, `list(range(10))` |
| **Dictionaries** | `{'job': 'dev', 'years': 40}`, `dict(hours=10)` |
| **Tuples** | `(1, 'app', 4, 'U')`, `tuple('hack')`, `namedtuple` |
| **Files** | `open('docs.txt')`, `open(r'C:\data.bin', 'wb')` |
| **Sets** | `set('abc')`, `{'a', 'b', 'c'}` |
| **Other** | Booleans, types, None |

## Numbers

### Basic Operations
```python
>>> 123 + 222                    # Integer addition
345
>>> 1.5 * 4                      # Floating-point multiplication
6.0
>>> 1_234_567, 0x15, bin(21)     # Separators, hex, binary
(1234567, 21, '0b10101')
>>> 2 ** 100                     # 2 to the power 100
1267650600228229401496703205376
```

### Working with Large Numbers
```python
>>> len(str(2 ** 12345))         # Count digits in a huge number
3717
```

### Math Module
```python
>>> import math
>>> math.pi
3.141592653589793
>>> math.sqrt(85)
9.219544457292887

>>> import random
>>> random.random()
0.7082048489415967
>>> random.choice([1, 2, 3, 4])
2
```

## Strings

Strings are **sequences** - positionally ordered collections of other objects.

### Sequence Operations

#### Indexing and Length
```python
>>> S = 'Code'
>>> len(S)               # Length
4
>>> S[0]                 # First item (zero-based)
'C'
>>> S[-1]                # Last item (negative indexing)
'e'
```

#### Slicing
```python
>>> S[1:3]               # Slice from offset 1 to 2 (not 3)
'od'
>>> S[1:]                # Everything past the first
'ode'
>>> S[:3]                # Everything but the last
'Cod'
>>> S[:-1]               # Everything but the last (using negative)
'Cod'
>>> S[:]                 # Complete copy
'Code'
```

#### Concatenation and Repetition
```python
>>> S + 'xyz'            # Concatenation
'Codexyz'
>>> S * 3                # Repetition
'CodeCodeCode'
```

### Immutability

!!! important "Strings are Immutable"
    You cannot change a string in place after creation. Operations create new strings.

```python
>>> S[0] = 'z'           # This will raise an error!
TypeError: 'str' object does not support item assignment

>>> S = 'Z' + S[1:]      # But you can create new strings
>>> S
'Zode'
```

### String Methods

```python
>>> S = 'Code'
>>> S.find('od')                 # Find substring offset
1
>>> S.replace('od', 'abl')       # Replace substrings
'Cable'

>>> line = 'aaa,bbb,ccccc,dd'
>>> line.split(',')              # Split on delimiter
['aaa', 'bbb', 'ccccc', 'dd']

>>> S = 'code'
>>> S.upper()                    # Case conversion
'CODE'
>>> S.isalpha()                  # Content test
True
```

### String Formatting

Three main approaches:

```python
>>> tool = 'Python'
>>> major = 3
>>> minor = 3

# Format expression (original)
>>> 'Using %s version %s.%s' % (tool, major, minor + 9)
'Using Python version 3.12'

# Format method (newer)
>>> 'Using {} version {}.{}'.format(tool, major, minor + 9)
'Using Python version 3.12'

# f-strings (newest)
>>> f'Using {tool} version {major}.{minor + 9}'
'Using Python version 3.12'
```

### Unicode Support

```python
>>> 'hÄck'                      # Normal str strings are Unicode text
'hÄck'
>>> b'a\x01c'                   # bytes strings are byte-based data
b'a\x01c'

# Encoding/Decoding
>>> 'Code'.encode('utf-8')      # Encoded to bytes
b'Code'
>>> b'Code'.decode('utf-8')     # Decoded to text
'Code'
```

## Lists

Lists are **mutable sequences** - they can be changed in place and have no fixed size.

### Sequence Operations
```python
>>> L = [123, 'text', 1.23]     # Mixed-type list
>>> len(L)
3
>>> L[0]                        # Indexing
123
>>> L[:-1]                      # Slicing
[123, 'text']
>>> L + [4, 5, 6]              # Concatenation
[123, 'text', 1.23, 4, 5, 6]
```

### List-Specific Operations

#### Growing and Shrinking
```python
>>> L.append('Py')              # Add to end
>>> L
[123, 'text', 1.23, 'Py']

>>> L.pop(2)                    # Remove by index
1.23
>>> L
[123, 'text', 'Py']
```

#### Sorting and Reversing
```python
>>> M = ['bb', 'aa', 'cc']
>>> M.sort()                    # Sort in place
>>> M
['aa', 'bb', 'cc']
>>> M.reverse()                 # Reverse in place
>>> M
['cc', 'bb', 'aa']
```

### Nesting - Matrices
```python
>>> M = [[1, 2, 3],             # 3x3 matrix
         [4, 5, 6],
         [7, 8, 9]]
>>> M[1]                        # Get row 2
[4, 5, 6]
>>> M[1][2]                     # Get row 2, item 3
6
```

### List Comprehensions

Powerful way to process structures:

```python
# Extract column 2 from matrix
>>> col2 = [row[1] for row in M]
>>> col2
[2, 5, 8]

# With transformations
>>> [row[1] + 1 for row in M]
[3, 6, 9]

# With filtering
>>> [row[1] for row in M if row[1] % 2 == 0]
[2, 8]

# Multiple values
>>> [[x ** 2, x ** 3] for x in range(4)]
[[0, 0], [1, 1], [4, 8], [9, 27]]
```

### Generator Expressions
```python
>>> G = (sum(row) for row in M)  # Generator instead of list
>>> next(G)                      # Get next result
6
>>> next(G)
15
```

### Set and Dictionary Comprehensions
```python
>>> {sum(row) for row in M}      # Set comprehension
{24, 6, 15}

>>> {i: sum(M[i]) for i in range(3)}  # Dictionary comprehension
{0: 6, 1: 15, 2: 24}
```

## Dictionaries

Dictionaries are **mappings** - they store objects by key instead of position.

### Basic Operations
```python
>>> D = {'name': 'Pat', 'job': 'dev', 'age': 40}
>>> D['name']                   # Access by key
'Pat'
>>> D['job'] = 'mgr'           # Change value
>>> D
{'name': 'Pat', 'job': 'mgr', 'age': 40}
```

### Creating Dictionaries
```python
# Empty dictionary, then populate
>>> D = {}
>>> D['name'] = 'Pat'
>>> D['job'] = 'dev'
>>> D['age'] = 40

# Using dict() with keywords
>>> pat1 = dict(name='Pat', job='dev', age=40)

# Using dict() with zip
>>> pat2 = dict(zip(['name', 'job', 'age'], ['Pat', 'dev', 40]))
```

### Nesting
```python
>>> rec = {'name': {'first': 'Pat', 'last': 'Smith'},
           'jobs': ['dev', 'mgr'],
           'age': 40.5}

>>> rec['name']['last']         # Access nested dictionary
'Smith'
>>> rec['jobs'][-1]             # Access nested list
'mgr'
>>> rec['jobs'].append('janitor')  # Modify nested list
```

### Handling Missing Keys

#### Using `in` test
```python
>>> 'e' in D                    # Check if key exists
False
>>> if not 'e' in D:
        print('missing key!')
```

#### Using `get()` method
```python
>>> D.get('a', 'missing')       # Return default if key absent
1
>>> D.get('e', 'missing')
'missing'
```

#### Using ternary expression
```python
>>> D['e'] if 'e' in D else 0   # Conditional access
0
```

### Dictionary Methods and Iteration

```python
>>> D = dict(a=1, b=2, c=3)

# Get keys, values, items
>>> list(D.keys())
['a', 'b', 'c']
>>> list(D.values())
[1, 2, 3]
>>> list(D.items())
[('a', 1), ('b', 2), ('c', 3)]

# Iteration
>>> for key in D:
        print(key, '=>', D[key])

>>> for key, value in D.items():
        print(key, '=>', value)
```

## Tuples

Tuples are **immutable sequences** - like lists but cannot be changed.

### Basic Operations
```python
>>> T = (1, 2, 3, 4)           # 4-item tuple
>>> len(T)
4
>>> T + (5, 6)                 # Concatenation creates new tuple
(1, 2, 3, 4, 5, 6)
>>> T[0], T[1:]                # Indexing and slicing
(1, (2, 3, 4))
```

### Tuple Methods
```python
>>> T.index(4)                 # Find index of value
3
>>> T.count(4)                 # Count occurrences
1
```

### Immutability
```python
>>> T[0] = 2                   # This will raise an error!
TypeError: 'tuple' object does not support item assignment

>>> T = (2,) + T[1:]           # But you can create new tuples
>>> T
(2, 2, 3, 4)
```

### Why Use Tuples?

- **Integrity constraint**: Cannot be changed accidentally
- **Fixed collections**: Calendar dates, coordinates, etc.
- **Dictionary keys**: Immutable objects can be used as keys

## Files

File objects provide access to external files on your computer.

### Text Files
```python
# Writing
>>> f = open('data.txt', 'w')   # Open for writing
>>> f.write('Hello\n')          # Write text
6
>>> f.write('world!\n')
7
>>> f.close()                   # Always close files

# Reading
>>> f = open('data.txt')        # Open for reading (default)
>>> text = f.read()             # Read entire file
>>> text
'Hello\nworld!\n'
>>> print(text)
Hello
world!
```

### File Iteration
```python
>>> for line in open('data.txt'):
        print(line.rstrip())    # Remove \n for clean display
```

### Binary Files
```python
>>> bf = open('data.bin', 'wb')
>>> bf.write(b'h\xFFa\xEEc\xDDk\n')  # Write binary data
8
>>> bf.close()
>>> open('data.bin', 'rb').read()    # Read binary data
b'h\xffa\xeec\xddk\n'
```

### Unicode Files
```python
>>> tf = open('unidata.txt', 'w', encoding='utf-8')
>>> tf.write('hÄck')
6
>>> tf.close()
>>> open('unidata.txt', 'r', encoding='utf-8').read()
'hÄck'
```

## Sets

Sets are **unordered collections** of unique, immutable objects.

```python
>>> X = set('hack')             # Create from sequence
>>> Y = {'a', 'p', 'p'}         # Set literal (duplicates removed)
>>> X, Y
({'c', 'k', 'a', 'h'}, {'p', 'a'})

# Set operations
>>> X & Y                       # Intersection
{'a'}
>>> X | Y                       # Union
{'p', 'c', 'k', 'h', 'a'}
>>> X - Y                       # Difference
{'c', 'k', 'h'}

# Practical uses
>>> list(set([3, 1, 2, 1, 3, 1]))  # Remove duplicates
[1, 2, 3]
>>> set('code') == set('deoc')      # Order-neutral equality
True
```

## Other Core Objects

### Booleans and None
```python
>>> 1 > 2, 1 < 2               # Boolean results
(False, True)
>>> bool('hack')               # All objects have Boolean value
True

>>> X = None                   # None placeholder
>>> print(X)
None
>>> L = [None] * 100          # Initialize list with Nones
```

### Types
```python
>>> L = [1, 2, 3]
>>> type(L)                    # Get object type
<class 'list'>

# Type checking (usually not recommended)
>>> type(L) == list
True
>>> isinstance(L, list)        # Preferred method
True
```

## Key Concepts

### Polymorphism
> The meaning of an operation depends on the objects being operated on.

```python
>>> 'hello' + ' world'         # String concatenation
'hello world'
>>> [1, 2] + [3, 4]           # List concatenation
[1, 2, 3, 4]
>>> 3 + 4                     # Numeric addition
7
```

### Dynamic vs Strong Typing

- **Dynamically typed**: No type declarations needed; types determined at runtime
- **Strongly typed**: Can only perform operations valid for an object's type

### Mutability Classification

| **Immutable** | **Mutable** |
|---------------|-------------|
| Numbers       | Lists       |
| Strings       | Dictionaries|
| Tuples        | Sets        |
| Frozen sets   | Byte arrays |

## Getting Help

### Using `dir()` and `help()`
```python
>>> S = 'Code'
>>> dir(S)                     # List all attributes/methods
['__add__', '__class__', ..., 'upper', 'zfill']

>>> help(S.replace)            # Get help on specific method
Help on built-in function replace:
replace(old, new, count=-1, /) method of builtins.str instance
    Return a copy with all occurrences of substring old replaced by new.
```

## Best Practices

1. **Use built-in objects** when possible - they're optimized and well-tested
2. **Avoid type checking** - embrace polymorphism instead
3. **Prefer immutable objects** when you don't need to change data
4. **Use meaningful variable names** and consistent coding style
5. **Close files explicitly** or use context managers
6. **Leverage comprehensions** for concise data processing

## Summary

Python's core object types provide a powerful foundation for programming:

- **Numbers** for mathematical operations
- **Strings** for text processing with Unicode support
- **Lists** for ordered, mutable collections
- **Dictionaries** for key-based data storage
- **Tuples** for immutable sequences
- **Files** for external data access
- **Sets** for unique collections and mathematical operations

These objects support both generic sequence operations and type-specific methods, making Python both powerful and flexible through polymorphism.