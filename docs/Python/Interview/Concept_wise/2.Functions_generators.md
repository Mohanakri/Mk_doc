# 🐍 Python Functions and Generators - Questions & Answers

## 🔧 Function Basics

??? question "Q1: How do you define a function in Python?"

    ```python
    def function_name(parameters):
        """Optional docstring"""
        # Function body
        return value  # Optional
    
    # Example
    def greet(name):
        """Greets a person with their name"""
        return f"Hello, {name}!"
    
    print(greet("Alice"))  # Output: Hello, Alice!
    ```

??? question "Q2: What are the different types of function arguments?"

    ```python
    def example_function(pos_arg, default_arg="default", *args, **kwargs):
        """
        pos_arg: Positional argument (required)
        default_arg: Default argument (optional)
        *args: Variable positional arguments (tuple)
        **kwargs: Variable keyword arguments (dictionary)
        """
        print(f"Positional: {pos_arg}")
        print(f"Default: {default_arg}")
        print(f"Args: {args}")
        print(f"Kwargs: {kwargs}")
    
    # Usage examples
    example_function("required")
    example_function("required", "custom", 1, 2, 3, key="value")
    ```

??? question "Q3: How do you use lambda functions?"

    ```python
    # Basic lambda syntax
    lambda arguments: expression
    
    # Examples
    square = lambda x: x ** 2
    print(square(5))  # Output: 25
    
    # Lambda with multiple arguments
    add = lambda x, y: x + y
    print(add(3, 4))  # Output: 7
    
    # Lambda with higher-order functions
    numbers = [1, 2, 3, 4, 5]
    squared = list(map(lambda x: x**2, numbers))
    print(squared)  # Output: [1, 4, 9, 16, 25]
    
    # Lambda with filter
    even_numbers = list(filter(lambda x: x % 2 == 0, numbers))
    print(even_numbers)  # Output: [2, 4]
    ```

## 🎯 Advanced Function Concepts

??? question "Q4: What is function scope and how does it work?"

    ```python
    # Global scope
    global_var = "I'm global"
    
    def outer_function():
        # Enclosing scope
        enclosing_var = "I'm in enclosing scope"
        
        def inner_function():
            # Local scope
            local_var = "I'm local"
            print(f"Local: {local_var}")
            print(f"Enclosing: {enclosing_var}")
            print(f"Global: {global_var}")
        
        inner_function()
    
    outer_function()
    
    # LEGB Rule: Local -> Enclosing -> Global -> Built-in
    ```

??? question "Q5: How do decorators work in Python?"

    ```python
    # Basic decorator
    def my_decorator(func):
        def wrapper(*args, **kwargs):
            print("Before function execution")
            result = func(*args, **kwargs)
            print("After function execution")
            return result
        return wrapper
    
    # Using decorator with @ syntax
    @my_decorator
    def greet(name):
        print(f"Hello, {name}!")
        return f"Greeting for {name}"
    
    # Decorator with parameters
    def repeat(times):
        def decorator(func):
            def wrapper(*args, **kwargs):
                for _ in range(times):
                    result = func(*args, **kwargs)
                return result
            return wrapper
        return decorator
    
    @repeat(3)
    def say_hello():
        print("Hello!")
    
    say_hello()  # Prints "Hello!" 3 times
    ```

??? question "Q6: What are closures and how are they used?"

    ```python
    def outer_function(x):
        # This variable is captured by the closure
        outer_var = x
        
        def inner_function(y):
            # Inner function has access to outer_var
            return outer_var + y
        
        return inner_function
    
    # Creating closures
    add_10 = outer_function(10)
    add_20 = outer_function(20)
    
    print(add_10(5))  # Output: 15
    print(add_20(5))  # Output: 25
    
    # Practical example: Counter closure
    def make_counter():
        count = 0
        
        def counter():
            nonlocal count
            count += 1
            return count
        
        return counter
    
    counter1 = make_counter()
    counter2 = make_counter()
    
    print(counter1())  # Output: 1
    print(counter1())  # Output: 2
    print(counter2())  # Output: 1
    ```

## 🔄 Generators

??? question "Q7: What are generators and how do they work?"

    ```python
    # Generator function using yield
    def number_generator(n):
        """Generate numbers from 0 to n-1"""
        for i in range(n):
            print(f"Generating {i}")
            yield i
    
    # Using the generator
    gen = number_generator(3)
    print(type(gen))  # <class 'generator'>
    
    # Iterating through generator
    for num in gen:
        print(f"Received: {num}")
    
    # Generator expressions
    squares_gen = (x**2 for x in range(5))
    print(list(squares_gen))  # Output: [0, 1, 4, 9, 16]
    ```

??? question "Q8: What's the difference between generators and regular functions?"

    ```python
    # Regular function - returns all values at once
    def regular_function(n):
        result = []
        for i in range(n):
            result.append(i**2)
        return result
    
    # Generator function - yields values one at a time
    def generator_function(n):
        for i in range(n):
            yield i**2
    
    # Memory comparison
    import sys
    
    regular_result = regular_function(1000)
    generator_result = generator_function(1000)
    
    print(f"Regular function size: {sys.getsizeof(regular_result)} bytes")
    print(f"Generator size: {sys.getsizeof(generator_result)} bytes")
    
    # Generator maintains state between yields
    def stateful_generator():
        print("Starting generator")
        yield 1
        print("Between first and second yield")
        yield 2
        print("Between second and third yield")
        yield 3
        print("Generator finished")
    
    gen = stateful_generator()
    print(next(gen))  # Output: Starting generator \n 1
    print(next(gen))  # Output: Between first and second yield \n 2
    ```

??? question "Q9: How do you use generator methods (send, throw, close)?"

    ```python
    def interactive_generator():
        """Generator that can receive values"""
        value = None
        while True:
            try:
                received = yield value
                if received is not None:
                    value = f"Received: {received}"
                else:
                    value = "No value received"
            except GeneratorExit:
                print("Generator is closing")
                break
            except Exception as e:
                value = f"Exception caught: {e}"
    
    # Using generator methods
    gen = interactive_generator()
    
    # Start the generator
    print(next(gen))  # Output: None
    
    # Send a value
    print(gen.send("Hello"))  # Output: Received: Hello
    
    # Throw an exception
    print(gen.throw(ValueError, "Test error"))  # Output: Exception caught: Test error
    
    # Close the generator
    gen.close()  # Output: Generator is closing
    ```

## 🔗 Function Composition and Higher-Order Functions

??? question "Q10: How do you create and use higher-order functions?"

    ```python
    # Function that takes another function as argument
    def apply_operation(numbers, operation):
        """Apply operation to each number in the list"""
        return [operation(num) for num in numbers]
    
    # Function that returns another function
    def create_multiplier(factor):
        """Create a function that multiplies by factor"""
        def multiplier(x):
            return x * factor
        return multiplier
    
    # Usage examples
    numbers = [1, 2, 3, 4, 5]
    
    # Using built-in functions
    squared = apply_operation(numbers, lambda x: x**2)
    print(squared)  # Output: [1, 4, 9, 16, 25]
    
    # Using created functions
    double = create_multiplier(2)
    doubled = apply_operation(numbers, double)
    print(doubled)  # Output: [2, 4, 6, 8, 10]
    
    # Function composition
    def compose(f, g):
        """Compose two functions: f(g(x))"""
        return lambda x: f(g(x))
    
    add_one = lambda x: x + 1
    multiply_by_two = lambda x: x * 2
    
    # Compose functions
    composed = compose(multiply_by_two, add_one)
    print(composed(5))  # Output: 12 (5+1)*2
    ```

??? question "Q11: How do you use functools for function utilities?"

    ```python
    from functools import partial, reduce, wraps
    
    # partial - create partial functions
    def multiply(x, y, z):
        return x * y * z
    
    # Create partial function
    double = partial(multiply, 2)  # Fix x=2
    triple = partial(multiply, 3)  # Fix x=3
    
    print(double(4, 5))  # Output: 40 (2*4*5)
    print(triple(4, 5))  # Output: 60 (3*4*5)
    
    # reduce - apply function cumulatively
    numbers = [1, 2, 3, 4, 5]
    sum_all = reduce(lambda x, y: x + y, numbers)
    print(sum_all)  # Output: 15
    
    # wraps - preserve function metadata in decorators
    def my_decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            print(f"Calling {func.__name__}")
            return func(*args, **kwargs)
        return wrapper
    
    @my_decorator
    def example_function():
        """This is an example function"""
        pass
    
    print(example_function.__name__)  # Output: example_function
    print(example_function.__doc__)   # Output: This is an example function
    ```

## ⚡ Generator Expressions and Itertools

??? question "Q12: How do you use generator expressions effectively?"

    ```python
    # Generator expressions vs list comprehensions
    # List comprehension (creates entire list in memory)
    squares_list = [x**2 for x in range(10)]
    
    # Generator expression (creates generator object)
    squares_gen = (x**2 for x in range(10))
    
    # Memory efficient processing
    def process_large_file(filename):
        """Process large file line by line"""
        with open(filename, 'r') as file:
            # Generator expression for memory efficiency
            lines = (line.strip().upper() for line in file if line.strip())
            for processed_line in lines:
                yield processed_line
    
    # Chaining generator expressions
    numbers = range(100)
    even_numbers = (x for x in numbers if x % 2 == 0)
    squared_evens = (x**2 for x in even_numbers)
    large_squares = (x for x in squared_evens if x > 100)
    
    print(list(large_squares))  # Process chain when needed
    ```

??? question "Q13: How do you use itertools with generators?"

    ```python
    import itertools
    
    # itertools.count - infinite arithmetic sequence
    counter = itertools.count(start=1, step=2)
    first_10_odds = [next(counter) for _ in range(10)]
    print(first_10_odds)  # Output: [1, 3, 5, 7, 9, 11, 13, 15, 17, 19]
    
    # itertools.cycle - infinite repetition
    colors = itertools.cycle(['red', 'green', 'blue'])
    color_sequence = [next(colors) for _ in range(7)]
    print(color_sequence)  # Output: ['red', 'green', 'blue', 'red', 'green', 'blue', 'red']
    
    # itertools.chain - flatten iterables
    list1 = [1, 2, 3]
    list2 = [4, 5, 6]
    list3 = [7, 8, 9]
    chained = list(itertools.chain(list1, list2, list3))
    print(chained)  # Output: [1, 2, 3, 4, 5, 6, 7, 8, 9]
    
    # itertools.combinations and permutations
    items = ['A', 'B', 'C']
    combinations = list(itertools.combinations(items, 2))
    permutations = list(itertools.permutations(items, 2))
    
    print(combinations)  # Output: [('A', 'B'), ('A', 'C'), ('B', 'C')]
    print(permutations)  # Output: [('A', 'B'), ('A', 'C'), ('B', 'A'), ('B', 'C'), ('C', 'A'), ('C', 'B')]
    
    # itertools.groupby - group consecutive elements
    data = [1, 1, 2, 2, 2, 3, 1, 1]
    grouped = [(key, list(group)) for key, group in itertools.groupby(data)]
    print(grouped)  # Output: [(1, [1, 1]), (2, [2, 2, 2]), (3, [3]), (1, [1, 1])]
    ```

## 🚀 Advanced Generator Patterns

??? question "Q14: How do you create coroutines using generators?"

    ```python
    def coroutine_example():
        """Simple coroutine that processes sent values"""
        print("Coroutine started")
        try:
            while True:
                value = yield
                if value is not None:
                    print(f"Processing: {value}")
        except GeneratorExit:
            print("Coroutine terminated")
    
    # Using coroutine
    coro = coroutine_example()
    next(coro)  # Prime the coroutine
    
    coro.send("Hello")
    coro.send("World")
    coro.close()
    
    # More complex coroutine - running average
    def running_average():
        """Calculate running average of sent values"""
        total = 0
        count = 0
        average = None
        
        while True:
            value = yield average
            if value is not None:
                total += value
                count += 1
                average = total / count
    
    avg_coro = running_average()
    next(avg_coro)  # Prime
    
    print(avg_coro.send(10))  # Output: 10.0
    print(avg_coro.send(20))  # Output: 15.0
    print(avg_coro.send(30))  # Output: 20.0
    ```

??? question "Q15: How do you implement the iterator protocol?"

    ```python
    class NumberSequence:
        """Custom iterator that generates a sequence of numbers"""
        
        def __init__(self, start, end, step=1):
            self.start = start
            self.end = end
            self.step = step
            self.current = start
        
        def __iter__(self):
            return self
        
        def __next__(self):
            if self.current >= self.end:
                raise StopIteration
            
            value = self.current
            self.current += self.step
            return value
    
    # Using custom iterator
    seq = NumberSequence(1, 10, 2)
    for num in seq:
        print(num)  # Output: 1, 3, 5, 7, 9
    
    # Generator version (simpler)
    def number_sequence(start, end, step=1):
        current = start
        while current < end:
            yield current
            current += step
    
    # Both produce the same result
    for num in number_sequence(1, 10, 2):
        print(num)  # Output: 1, 3, 5, 7, 9
    ```

## 📚 Best Practices and Tips

??? question "Q16: What are the best practices for writing functions?"

    ```python
    def calculate_circle_area(radius):
        """
        Calculate the area of a circle.
        
        Args:
            radius (float): The radius of the circle
            
        Returns:
            float: The area of the circle
            
        Raises:
            ValueError: If radius is negative
        """
        import math
        
        # Input validation
        if radius < 0:
            raise ValueError("Radius cannot be negative")
        
        # Single responsibility - only calculate area
        return math.pi * radius ** 2
    
    # Function should be pure when possible
    def pure_function(x, y):
        """Pure function - same input always gives same output"""
        return x + y
    
    # Avoid side effects in functions when possible
    def impure_function(data):
        """Function with side effects - modifies global state"""
        global counter
        counter += 1
        data.append(counter)  # Modifies input
    
    # Better approach - return new data
    def better_function(data):
        """Returns new data without side effects"""
        return data + [len(data) + 1]
    ```

??? question "Q17: When should you use generators vs lists?"

    ```python
    import sys
    import time
    
    # Use generators for:
    # 1. Large datasets (memory efficiency)
    def process_large_dataset():
        """Generator for processing large amounts of data"""
        for i in range(1000000):
            yield i ** 2
    
    # 2. Infinite sequences
    def fibonacci():
        """Infinite Fibonacci sequence"""
        a, b = 0, 1
        while True:
            yield a
            a, b = b, a + b
    
    # 3. Pipeline processing
    def read_data():
        for i in range(100):
            yield i
    
    def process_data(data_gen):
        for item in data_gen:
            yield item * 2
    
    def filter_data(data_gen):
        for item in data_gen:
            if item % 3 == 0:
                yield item
    
    # Chain generators for efficient processing
    pipeline = filter_data(process_data(read_data()))
    result = list(pipeline)
    
    # Use lists for:
    # 1. Small datasets that fit in memory
    # 2. When you need random access
    # 3. When you need to use the data multiple times
    
    small_data = [x**2 for x in range(100)]
    print(small_data[50])  # Random access
    print(len(small_data))  # Need length
    print(sum(small_data))  # Use multiple times
    ```