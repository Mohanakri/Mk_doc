# Example
    matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
    transposed = matrix_transpose(matrix)  # [[1, 4, 7], [2, 5, 8], [3, 6, 9]]
    spiral = spiral_traverse(matrix)       # [1, 2, 3, 6, 9, 8, 7, 4, 5]
    ```

??? question "Q21: How do you handle list-based number representations?"
    **Pattern**: Digit/number manipulation
    ```python
    def add_large_numbers(num1_list, num2_list):
        """Add two numbers represented as digit lists"""
        result = []
        carry = 0
        i, j = len(num1_list) - 1, len(num2_list) - 1
        
        while i >= 0 or j >= 0 or carry:
            digit1 = num1_list[i] if i >= 0 else 0
            digit2 = num2_list[j] if j >= 0 else 0
            
            total = digit1 + digit2 + carry
            result.append(total % 10)
            carry = total // 10
            
            i -= 1
            j -= 1
        
        return result[::-1]
    
    def multiply_large_numbers(num1_list, num2_list):
        """Multiply two numbers represented as digit lists"""
        if not num1_list or not num2_list:
            return [0]
        
        n1, n2 = len(num1_list), len(num2_list)
        result = [0] * (n1 + n2)
        
        for i in range(n1 - 1, -1, -1):
            for j in range(n2 - 1, -1, -1):
                mult = num1_list[i] * num2_list[j]
                pos1, pos2 = i + j, i + j + 1
                
                total = mult + result[pos2]
                result[pos2] = total % 10
                result[pos1] += total // 10
        
        # Remove leading zeros
        start = 0
        while start < len(result) and result[start] == 0:
            start += 1
        
        return result[start:] if start < len(result) else [0]
    
    def number_to_list_and_back(num):
        """Convert number to digit list and back"""
        # Number to list
        digit_list = [int(d) for d in str(num)]
        
        # List back to number
        number = 0
        for digit in digit_list:
            number = number * 10 + digit
        
        return digit_list, number
    
    # Example
    num1 = [1, 2, 3]  # represents 123
    num2 = [4, 5, 6]  # represents 456
    sum_result = add_large_numbers(num1, num2)  # [5, 7, 9] (579)
    ```

??? question "Q22: How do you calculate probability and combinatorics?"
    **Pattern**: Mathematical computations
    ```python
    def factorial(n):
        """Calculate factorial"""
        if n <= 1:
            return 1
        result = 1
        for i in range(2, n + 1):
            result *= i
        return result
    
    def combinations(n, r):
        """Calculate C(n,r) = n! / (r! * (n-r)!)"""
        if r > n or r < 0:
            return 0
        if r == 0 or r == n:
            return 1
        
        # Optimize by using smaller value
        r = min(r, n - r)
        result = 1
        for i in range(r):
            result = result * (n - i) // (i + 1)
        return result
    
    def permutations(n, r):
        """Calculate P(n,r) = n! / (n-r)!"""
        if r > n or r < 0:
            return 0
        result = 1
        for i in range(n, n - r, -1):
            result *= i
        return result
    
    def pascal_triangle(n):
        """Generate Pascal's triangle up to n rows"""
        triangle = []
        for i in range(n):
            row = [1]
            if triangle:
                for j in range(1, len(triangle[-1])):
                    row.append(triangle[-1][j-1] + triangle[-1][j])
                row.append(1)
            triangle.append(row)
        return triangle
    
    def binomial_coefficient_list(n):
        """Generate list of binomial coefficients for (1+x)^n"""
        coefficients = [1]
        for i in range(1, n + 1):
            coefficients.append(coefficients[-1] * (n - i + 1) // i)
        return coefficients
    
    # Example
    triangle = pascal_triangle(5)
    # [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]
    ```

??? question "Q23: How do you perform geometric calculations on points?"
    **Pattern**: Coordinate geometry
    ```python
    import math
    
    def distance_between_points(point1, point2):
        """Calculate Euclidean distance between two points"""
        return math.sqrt(sum((a - b) ** 2 for a, b in zip(point1, point2)))
    
    def closest_pair_of_points(points):
        """Find the closest pair of points"""
        if len(points) < 2:
            return None, float('inf')
        
        min_distance = float('inf')
        closest_pair = None
        
        for i in range(len(points)):
            for j in range(i + 1, len(points)):
                dist = distance_between_points(points[i], points[j])
                if dist < min_distance:
                    min_distance = dist
                    closest_pair = (points[i], points[j])
        
        return closest_pair, min_distance
    
    def convex_hull(points):
        """Find convex hull using Graham scan algorithm"""
        def cross_product(o, a, b):
            return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0])
        
        points = sorted(set(points))
        if len(points) <= 1:
            return points
        
        # Build lower hull
        lower = []
        for p in points:
            while len(lower) >= 2 and cross_product(lower[-2], lower[-1], p) <= 0:
                lower.pop()
            lower.append(p)
        
        # Build upper hull
        upper = []
        for p in reversed(points):
            while len(upper) >= 2 and cross_product(upper[-2], upper[-1], p) <= 0:
                upper.pop()
            upper.append(p)
        
        return lower[:-1] + upper[:-1]
    
    def polygon_area(vertices):
        """Calculate area of polygon using shoelace formula"""
        n = len(vertices)
        if n < 3:
            return 0
        
        area = 0
        for i in range(n):
            j = (i + 1) % n
            area += vertices[i][0] * vertices[j][1]
            area -= vertices[j][0] * vertices[i][1]
        
        return abs(area) / 2
    
    # Example
    points = [(0, 0), (1, 1), (2, 0), (1, -1)]
    hull = convex_hull(points)  # Convex hull vertices
    area = polygon_area(points)  # Polygon area
    ```

??? question "Q24: How do you implement mathematical sequences?"
    **Pattern**: Sequence generation
    ```python
    def fibonacci_sequence(n):
        """Generate first n Fibonacci numbers"""
        if n <= 0:
            return []
        elif n == 1:
            return [0]
        elif n == 2:
            return [0, 1]
        
        fib = [0, 1]
        for i in range(2, n):
            fib.append(fib[i-1] + fib[i-2])
        return fib
    
    def prime_numbers(limit):
        """Generate all prime numbers up to limit using Sieve of Eratosthenes"""
        if limit < 2:
            return []
        
        sieve = [True] * (limit + 1)
        sieve[0] = sieve[1] = False
        
        for i in range(2, int(limit ** 0.5) + 1):
            if sieve[i]:
                for j in range(i * i, limit + 1, i):
                    sieve[j] = False
        
        return [i for i, is_prime in enumerate(sieve) if is_prime]
    
    def arithmetic_progression(start, diff, n):
        """Generate arithmetic progression"""
        return [start + i * diff for i in range(n)]
    
    def geometric_progression(start, ratio, n):
        """Generate geometric progression"""  
        result = [start]
        current = start
        for _ in range(n - 1):
            current *= ratio
            result.append(current)
        return result
    
    def collatz_sequence(n):
        """Generate Collatz sequence starting from n"""
        sequence = [n]
        while n != 1:
            if n % 2 == 0:
                n = n // 2
            else:
                n = 3 * n + 1
            sequence.append(n)
        return sequence
    
    # Example
    fib = fibonacci_sequence(10)  # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]
    primes = prime_numbers(30)    # [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]
    collatz = collatz_sequence(7) # [7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]
    ```

---

## 🔄 Pattern 4: Sequence Analysis

??? question "Q25: How do you check if a list is a palindrome?"
    **Pattern**: Symmetry validation
    ```python
    def is_palindrome(lst):
        """Check if list reads the same forwards and backwards"""
        return lst == lst[::-1]
    
    def is_palindrome_iterative(lst):
        """Check palindrome using two pointers"""
        left, right = 0, len(lst) - 1
        while left < right:
            if lst[left] != lst[right]:
                return False
            left += 1
            right -= 1
        return True
    
    def longest_palindromic_subsequence(lst):
        """Find length of longest palindromic subsequence"""
        n = len(lst)
        dp = [[0] * n for _ in range(n)]
        
        # Single elements are palindromes of length 1
        for i in range(n):
            dp[i][i] = 1
        
        # Check for palindromes of length 2 and more
        for length in range(2, n + 1):
            for i in range(n - length + 1):
                j = i + length - 1
                if lst[i] == lst[j]:
                    if length == 2:
                        dp[i][j] = 2
                    else:
                        dp[i][j] = dp[i + 1][j - 1] + 2
                else:
                    dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])
        
        return dp[0][n - 1]
    
    def shortest_palindrome(lst):
        """Find shortest palindrome by adding elements to the front"""
        def is_palindrome_helper(arr):
            return arr == arr[::-1]
        
        for i in range(len(lst)):
            candidate = lst[i:] + lst[::-1]
            if is_palindrome_helper(candidate):
                return candidate
        return lst + lst[::-1]
    
    # Example
    palindrome_list = [1, 2, 3, 2, 1]
    is_pal = is_palindrome(palindrome_list)  # True
    
    sequence = [1, 2, 3, 4, 3, 2, 5]
    lps_length = longest_palindromic_subsequence(sequence)  # 5
    ```

??? question "Q26: How do you detect and analyze patterns in sequences?"
    **Pattern**: Pattern recognition
    ```python
    def find_repeating_pattern(lst):
        """Find the shortest repeating pattern in a list"""
        n = len(lst)
        for pattern_len in range(1, n // 2 + 1):
            if n % pattern_len == 0:
                pattern = lst[:pattern_len]
                is_repeating = True
                
                for i in range(pattern_len, n, pattern_len):
                    if lst[i:i + pattern_len] != pattern:
                        is_repeating = False
                        break
                
                if is_repeating:
                    return pattern
        
        return lst  # No repeating pattern found
    
    def find_arithmetic_pattern(lst):
        """Check if list forms arithmetic progression"""
        if len(lst) < 2:
            return True, 0
        
        diff = lst[1] - lst[0]
        for i in range(2, len(lst)):
            if lst[i] - lst[i-1] != diff:
                return False, None
        
        return True, diff
    
    def find_geometric_pattern(lst):
        """Check if list forms geometric progression"""
        if len(lst) < 2 or 0 in lst[:-1]:
            return False, None
        
        ratio = lst[1] / lst[0]
        for i in range(2, len(lst)):
            if abs(lst[i] / lst[i-1] - ratio) > 1e-9:
                return False, None
        
        return True, ratio
    
    def find_pattern_period(lst):
        """Find the period of a repeating pattern"""
        n = len(lst)
        for period in range(1, n // 2 + 1):
            matches = True
            for i in range(period, n):
                if lst[i] != lst[i % period]:
                    matches = False
                    break
            if matches:
                return period
        return n
    
    def detect_trend(lst):
        """Detect if sequence is increasing, decreasing, or constant"""
        if len(lst) < 2:
            return "insufficient_data"
        
        increasing = all(lst[i] >= lst[i-1] for i in range(1, len(lst)))
        decreasing = all(lst[i] <= lst[i-1] for i in range(1, len(lst)))
        strictly_increasing = all(lst[i] > lst[i-1] for i in range(1, len(lst)))
        strictly_decreasing = all(lst[i] < lst[i-1] for i in range(1, len(lst)))
        constant = all(lst[i] == lst[0] for i in range(len(lst)))
        
        if constant:
            return "constant"
        elif strictly_increasing:
            return "strictly_increasing"
        elif strictly_decreasing:
            return "strictly_decreasing"
        elif increasing:
            return "non_decreasing"
        elif decreasing:
            return "non_increasing"
        else:
            return "mixed"
    
    # Example
    repeating = [1, 2, 3, 1, 2, 3, 1, 2, 3]
    pattern = find_repeating_pattern(repeating)  # [1, 2, 3]
    
    arithmetic = [2, 5, 8, 11, 14]
    is_arith, diff = find_arithmetic_pattern(arithmetic)  # True, 3
    ```

??? question "Q27: How do you find and manipulate subsequences?"
    **Pattern**: Subsequence operations
    ```python
    def all_subsequences(lst):
        """Generate all possible subsequences"""
        n = len(lst)
        subsequences = []
        
        # Generate all possible binary representations
        for i in range(2**n):
            subseq = []
            for j in range(n):
                if (i >> j) & 1:
                    subseq.append(lst[j])
            subsequences.append(subseq)
        
        return subsequences
    
    def longest_increasing_subsequence(lst):
        """Find the actual longest increasing subsequence"""
        if not lst:
            return []
        
        n = len(lst)
        dp = [1] * n
        parent = [-1] * n
        
        for i in range(1, n):
            for j in range(i):
                if lst[j] < lst[i] and dp[j] + 1 > dp[i]:
                    dp[i] = dp[j] + 1
                    parent[i] = j
        
        # Find the ending position of LIS
        max_length = max(dp)
        max_index = dp.index(max_length)
        
        # Reconstruct the LIS
        lis = []
        current = max_index
        while current != -1:
            lis.append(lst[current])
            current = parent[current]
        
        return list(reversed(lis))
    
    def is_subsequence(s, t):
        """Check if s is a subsequence of t"""
        i = j = 0
        while i < len(s) and j < len(t):
            if s[i] == t[j]:
                i += 1
            j += 1
        return i == len(s)
    
    def distinct_subsequences_count(s, t):
        """Count distinct subsequences of s that equal t"""
        m, n = len(s), len(t)
        dp = [[0] * (n + 1) for _ in range(m + 1)]
        
        # Empty string is subsequence of any string
        for i in range(m + 1):
            dp[i][0] = 1
        
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                dp[i][j] = dp[i-1][j]
                if s[i-1] == t[j-1]:
                    dp[i][j] += dp[i-1][j-1]
        
        return dp[m][n]
    
    # Example
    sequence = [10, 9, 2, 5, 3, 7, 101, 18]
    lis = longest_increasing_subsequence(sequence)  # [2, 3, 7, 18] or similar
    
    s = "rabbbit"
    t = "rabbit"
    count = distinct_subsequences_count(s, t)  # 3
    ```

??? question "Q28: How do you analyze frequency and distribution?"
    **Pattern**: Statistical distribution analysis
    ```python
    from collections import Counter, defaultdict
    
    def frequency_analysis(lst):
        """Comprehensive frequency analysis"""
        counter = Counter(lst)
        
        # Basic frequency stats
        most_common = counter.most_common()
        mode = most_common[0][0] if most_common else None
        mode_frequency = most_common[0][1] if most_common else 0
        
        # Frequency distribution
        freq_dist = {}
        for freq in counter.values():
            freq_dist[freq] = freq_dist.get(freq, 0) + 1
        
        return {
            'counter': dict(counter),
            'most_common': most_common,
            'mode': mode,
            'mode_frequency': mode_frequency,
            'unique_count': len(counter),
            'frequency_distribution': freq_dist
        }
    
    def top_k_frequent(lst, k):
        """Find k most frequent elements"""
        counter = Counter(lst)
        return [item for item, freq in counter.most_common(k)]
    
    def group_anagrams(words):
        """Group words that are anagrams of each other"""
        anagram_groups = defaultdict(list)
        
        for word in words:
            # Sort characters to create a key
            key = ''.join(sorted(word))
            anagram_groups[key].append(word)
        
        return list(anagram_groups.values())
    
    def find_frequency_patterns(lst):
        """Find patterns in element frequencies"""
        counter = Counter(lst)
        frequencies = list(counter.values())
        
        # Check if all elements have same frequency
        uniform_frequency = len(set(frequencies)) == 1
        
        # Check if frequencies form arithmetic progression
        sorted_freqs = sorted(frequencies)
        is_arithmetic = True
        if len(sorted_freqs) > 1:
            diff = sorted_freqs[1] - sorted_freqs[0]
            for i in range(2, len(sorted_freqs)):
                if sorted_freqs[i] - sorted_freqs[i-1] != diff:
                    is_arithmetic = False
                    break
        
        return {
            'uniform_frequency': uniform_frequency,
            'arithmetic_frequencies': is_arithmetic,
            'frequency_range': (min(frequencies), max(frequencies)) if frequencies else (0, 0)
        }
    
    # Example
    data = ['apple', 'banana', 'apple', 'cherry', 'banana', 'apple']
    analysis = frequency_analysis(data)
    top_2 = top_k_frequent(data, 2)  # ['apple', 'banana']
    ```

??? question "Q29: How do you detect cycles and loops in sequences?"
    **Pattern**: Cycle detection
    ```python
    def detect_cycle_floyd(lst):
        """Detect cycle using Floyd's algorithm (for linked list like structure)"""
        # This assumes lst contains indices pointing to next elements
        if not lst:
            return False, -1
        
        slow = fast = 0
        
        # Phase 1: Detect if cycle exists
        while fast < len(lst) and lst[fast] < len(lst):
            slow = lst[slow]
            fast = lst[lst[fast]] if lst[fast] < len(lst) else len(lst)
            
            if slow == fast:
                # Cycle detected, find start
                start = 0
                while start != slow:
                    start = lst[start]
                    slow = lst[slow]
                return True, start
        
        return False, -1
    
    def find_duplicate_number(lst):
        """Find duplicate in array where numbers are 1 to n"""
        # Using Floyd's cycle detection for duplicate finding
        slow = fast = lst[0]
        
        # Find intersection point
        while True:
            slow = lst[slow]
            fast = lst[lst[fast]]
            if slow == fast:
                break
        
        # Find start of cycle (duplicate number)
        slow = lst[0]
        while slow != fast:
            slow = lst[slow]
            fast = lst[fast]
        
        return slow
    
    def cycle_length(lst, start_pos):
        """Find length of cycle starting at given position"""
        if start_pos >= len(lst):
            return 0
        
        current = lst[start_pos]
        length = 1
        
        while current != start_pos and current < len(lst):
            current = lst[current]
            length += 1
            if length > len(lst):  # Prevent infinite loop
                return -1
        
        return length if current == start_pos else 0
    
    def periodic_sequence_detection(lst):
        """Detect if sequence eventually becomes periodic"""
        seen = {}
        for i, val in enumerate(lst):
            if val in seen:
                period_start = seen[val]
                period_length = i - period_start
                
                # Check if it's truly periodic
                is_periodic = True
                for j in range(i, len(lst)):
                    expected_pos = period_start + ((j - period_start) % period_length)
                    if expected_pos >= len(lst) or lst[j] != lst[expected_pos]:
                        is_periodic = False
                        break
                
                if is_periodic:
                    return True, period_start, period_length
            
            seen[val] = i
        
        return False, -1, -1
    
    # Example
    # Array representing indices: [1, 3, 4, 2, 2] means 0->1, 1->3, 2->4, 3->2, 4->2
    indices = [1, 3, 4, 2, 2]
    has_cycle, cycle_start = detect_cycle_floyd(indices)
    
    # For duplicate detection: [1, 3, 4, 2, 2]
    duplicate = find_duplicate_number([1, 3, 4, 2, 2])  # 2
    ```

??? question "Q30: How do you find the longest common patterns?"
    **Pattern**: Pattern matching across sequences
    ```python
    def longest_common_subsequence_length(seq1, seq2):
        """Find length of longest common subsequence"""
        m, n = len(seq1), len(seq2)
        dp = [[0] * (n + 1) for _ in range(m + 1)]
        
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                if seq1[i-1] == seq2[j-1]:
                    dp[i][j] = dp[i-1][j-1] + 1
                else:
                    dp[i][j] = max(dp[i-1][j], dp[i][j-1])
        
        return dp[m][n]
    
    def longest_common_subsequence(seq1, seq2):
        """Return the actual longest common subsequence"""
        m, n = len(seq1), len(seq2)
        dp = [[0] * (n + 1) for _ in range(m + 1)]
        
        # Fill DP table
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                if seq1[i-1] == seq2[j-1]:
                    dp[i][j] = dp[i-1][j-1] + 1
                else:
                    dp[i][j] = max(dp[i-1][j], dp[i][j-1])
        
        # Reconstruct LCS
        lcs = []
        i, j = m, n
        while i > 0 and j > 0:
            if seq1[i-1] == seq2[j-1]:
                lcs.append(seq1[i-1])
                i -= 1
                j -= 1
            elif dp[i-1][j] > dp[i][j-1]:
                i -= 1
            else:
                j -= 1
        
        return list(reversed(lcs))
    
    def longest_common_substring(str1, str2):
        """Find longest common substring (contiguous)"""
        m, n = len(str1), len(str2)
        dp = [[0] * (n + 1) for _ in range(m + 1)]
        max_length = 0
        ending_pos = 0
        
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                if str1[i-1] == str2[j-1]:
                    dp[i][j] = dp[i-1][j-1] + 1
                    if dp[i][j] > max_length:
                        max_length = dp[i][j]
                        ending_pos = i
                else:
                    dp[i][j] = 0
        
        start_pos = ending_pos - max_length
        return str1[start_pos:ending_pos], max_length
    
    def all_common_subsequences(seq1, seq2, min_length=1):
        """Find all common subsequences of minimum length"""
        def backtrack(i, j, current_subseq):
            if len(current_subseq) >= min_length:
                result.add(tuple(current_subseq))
            
            if i >= len(seq1) or j >= len(seq2):
                return
            
            # Try to extend current subsequence
            for ii in range(i, len(seq1)):
                for jj in range(j, len(seq2)):
                    if seq1[ii] == seq2[jj]:
                        backtrack(ii + 1, jj + 1, current_subseq + [seq1[ii]])
        
        result = set()
        backtrack(0, 0, [])
        return [list(subseq) for subseq in result]
    
    # Example
    seq1 = ['A', 'B', 'C', 'D', 'E']
    seq2 = ['A', 'C', 'E', 'F']
    lcs = longest_common_subsequence(seq1, seq2)  # ['A', 'C', 'E']
    ```

??? question "Q31: How do you perform sequence transformations?"
    **Pattern**: Transformation operations
    ```python
    def edit_distance(seq1, seq2):
        """Calculate minimum edit distance (Levenshtein distance)"""
        m, n = len(seq1), len(seq2)
        dp = [[0] * (n + 1) for _ in range(m + 1)]
        
        # Initialize base cases
        for i in range(m + 1):
            dp[i][0] = i
        for j in range(n + 1):
            dp[0][j] = j
        
        # Fill DP table
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                if seq1[i-1] == seq2[j-1]:
                    dp[i][j] = dp[i-1][j-1]  # No operation needed
                else:
                    dp[i][j] = 1 + min(
                        dp[i-1][j],      # Delete
                        dp[i][j-1],      # Insert
                        dp[i-1][j-1]     # Replace
                    )
        
        return dp[m][n]
    
    def sequence_alignment(seq1, seq2):
        """Find optimal sequence alignment with operations"""
        m, n = len(seq1), len(seq2)
        dp = [[0] * (n + 1) for _ in range(m + 1)]
        operations = [['' for _ in range(n + 1)] for _ in range(m + 1)]
        
        # Initialize
        for i in range(m + 1):
            dp[i][0] = i
            operations[i][0] = 'D' * i
        for j in range(n + 1):
            dp[0][j] = j
            operations[0][j] = 'I' * j
        
        # Fill tables
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                if seq1[i-1] == seq2[j-1]:
                    dp[i][j] = dp[i-1][j-1]
                    operations[i][j] = operations[i-1][j-1] + 'M'
                else:
                    costs = [
                        dp[i-1][j] + 1,      # Delete
                        dp[i][j-1] + 1,      # Insert
                        dp[i-1][j-1] + 1     # Replace
                    ]
                    min_cost = min(costs)
                    dp[i][j] = min_cost
                    
                    if min_cost == costs[0]:
                        operations[i][j] = operations[i-1][j] + 'D'
                    elif min_cost == costs[1]:
                        operations[i][j] = operations[i][j-1] + 'I'
                    else:
                        operations[i][j] = operations[i-1][j-1] + 'R'
        
        return dp[m][n], operations[m][n]
    
    def transform_sequence(source, target, operations):
        """Apply transformation operations to convert source to target"""
        result = list(source)
        i = 0
        
        for op in operations:
            if op == 'M':  # Match, move forward
                i += 1
            elif op == 'D':  # Delete
                if i < len(result):
                    result.pop(i)
            elif op == 'I':  # Insert
                if i <= len(result):
                    # Need to determine what to insert based on target
                    result.insert(i, '?')  # Placeholder
                i += 1
            elif op == 'R':  # Replace
                if i < len(result):
                    result[i] = '?'  # Placeholder
                i += 1
        
        return result
    
    def find_minimum_swaps(lst, target):
        """Find minimum swaps to transform list to target"""
        if len(lst) != len(target):
            return -1
        
        # Create position mapping for target
        target_pos = {val: i for i, val in enumerate(target)}
        
        # Create array of target positions for current array
        positions = []
        for val in lst:
            if val not in target_pos:
                return -1  # Impossible transformation
            positions.append(target_pos[val])
        
        # Count cycles in permutation
        visited = [False] * len(positions)
        swaps = 0
        
        for i in range(len(positions)):
            if not visited[i]:
                cycle_length = 0
                current = i
                
                while not visited[current]:
                    visited[current] = True
                    current = positions[current]
                    cycle_length += 1
                
                if cycle_length > 1:
                    swaps += cycle_length - 1
        
        return swaps
    
    # Example
    source = "kitten"
    target = "sitting"
    distance, ops = sequence_alignment(list(source), list(target))
    print(f"Edit distance: {distance}")  # 3
    ```

??? question "Q32: How do you analyze sequence complexity?"
    **Pattern**: Complexity measurement
    ```python
    def kolmogorov_complexity_estimate(lst):
        """Estimate complexity based on compressibility"""
        import zlib
        
        # Convert to string representation
        str_repr = ''.join(map(str, lst))
        
        # Compress and measure
        compressed = zlib.compress(str_repr.encode())
        compression_ratio = len(compressed) / len(str_repr) if str_repr else 1
        
        return {
            'original_length': len(str_repr),
            'compressed_length': len(compressed),
            'compression_ratio': compression_ratio,
            'complexity_estimate': 1 - compression_ratio
        }
    
    def entropy_calculation(lst):
        """Calculate Shannon entropy of sequence"""
        import math
        from collections import Counter
        
        if not lst:
            return 0
        
        counter = Counter(lst)
        total = len(lst)
        entropy = 0
        
        for count in counter.values():
            probability = count / total
            entropy -= probability * math.log2(probability)
        
        return entropy
    
    def sequence_randomness_tests(lst):
        """Perform various randomness tests"""
        def runs_test(sequence):
            """Count runs (sequences of identical elements)"""
            if not sequence:
                return 0
            
            runs = 1
            for i in range(1, len(sequence)):
                if sequence[i] != sequence[i-1]:
                    runs += 1
            return runs
        
        def autocorrelation(sequence, lag=1):
            """Calculate autocorrelation at given lag"""
            if len(sequence) <= lag:
                return 0
            
            n = len(sequence) - lag
            mean = sum(sequence) / len(sequence)
            
            numerator = sum((sequence[i] - mean) * (sequence[i + lag] - mean) 
                          for i in range(n))
            denominator = sum((x - mean) ** 2 for x in sequence)
            
            return numerator / denominator if denominator != 0 else 0
        
        return {
            'entropy': entropy_calculation(lst),
            'runs': runs_test(lst),
            'autocorr_lag1': autocorrelation([float(x) for x in lst if isinstance(x, (int, float))]),
            'unique_ratio': len(set(lst)) / len(lst) if lst else 0
        }
    
    def pattern_complexity_score(lst):
        """Calculate overall pattern complexity score"""
        if not lst:
            return 0
        
        # Various complexity measures
        entropy = entropy_calculation(lst)
        max_entropy = math.log2(len(set(lst))) if len(set(lst)) > 1 else 0
        normalized_entropy = entropy / max_entropy if max_entropy > 0 else 0
        
        # Repetition penalty
        pattern = find_repeating_pattern(lst)
        repetition_factor = len(pattern) / len(lst) if pattern != lst else 1
        
        # Trend complexity
        trend = detect_trend(lst)
        trend_complexity = {
            'constant': 0,
            'strictly_increasing': 0.2,
            'strictly_decreasing': 0.2,
            'non_decreasing': 0.4,
            'non_increasing': 0.4,
            'mixed': 1.0
        }.get(trend, 0.5)
        
        # Combine measures
        complexity_score = (normalized_entropy * 0.4 + 
                          repetition_factor * 0.3 + 
                          trend_complexity * 0.3)
        
        return min(complexity_score, 1.0)
    
    # Example
    simple_pattern = [1, 2, 1, 2, 1, 2]
    complex_pattern = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3]
    
    simple_score = pattern_complexity_score(simple_pattern)    # Low score
    complex_score = pattern_complexity_score(complex_pattern)  # Higher score
    ```

---

## 🚀 Pattern 5: Advanced Algorithms

??? question "Q33: How do you implement cache and memoization systems?"
    **Pattern**: LRU Cache and optimization
    ```python
    class LRUCache:
        """Least Recently Used Cache implementation"""
        
        def __init__(self, capacity):
            self.capacity = capacity
            self.cache = {}
            self.order = []  # Most recent at end
        
        def get(self, key):
            if key in self.cache:
                # Move to end (most recent)
                self.order.remove(key)
                self.order.append(key)
                return self.cache[key]
            return -1
        
        def put(self, key, value):
            if key in self.cache:
                # Update existing
                self.cache[key] = value
                self.order.remove(key)
                self.order.append(key)
            else:
                # Add new
                if len(self.cache) >= self.capacity:
                    # Remove least recently used
                    oldest = self.order.pop(0)
                    del self.cache[oldest]
                
                self.cache[key] = value
                self.order.append(key)
        
        def display(self):
            return [(key, self.cache[key]) for key in self.order]
    
    class DoublyLinkedNode:
        """Node for efficient LRU implementation"""
        def __init__(self, key=0, value=0):
            self.key = key
            self.value = value
            self.prev = None
            self.next = None
    
    class OptimizedLRUCache:
        """O(1) LRU Cache using doubly linked list + hash map"""
        
        def __init__(self, capacity):
            self.capacity = capacity
            self.cache = {}
            
            # Create dummy head and tail
            self.head = DoublyLinkedNode()
            self.tail = DoublyLinkedNode()
            self.head.next = self.tail
            self.tail.prev = self.head
        
        def _add_node(self, node):
            """Add node right after head"""
            node.prev = self.head
            node.next = self.head.next
            
            self.head.next.prev = node
            self.head.next = node
        
        def _remove_node(self, node):
            """Remove an existing node"""
            prev_node = node.prev
            next_node = node.next
            
            prev_node.next = next_node
            next_node.prev = prev_node
        
        def _move_to_head(self, node):
            """Move node to head (most recent)"""
            self._remove_node(node)
            self._add_node(node)
        
        def _pop_tail(self):
            """Remove last node before tail"""
            last_node = self.tail.prev
            self._remove_node(last_node)
            return last_node
        
        def get(self, key):
            node = self.cache.get(key)
            if node:
                self._move_to_head(node)
                return node.value
            return -1
        
        def put(self, key, value):
            node = self.cache.get(key)
            
            if node:
                # Update existing
                node.value = value
                self._move_to_head(node)
            else:
                # Add new
                new_node = DoublyLinkedNode(key, value)
                
                if len(self.cache) >= self.capacity:
                    # Remove LRU
                    tail = self._pop_tail()
                    del self.cache[tail.key]
                
                self.cache[key] = new_node
                self._add_node(new_node)
    
    def memoization_decorator(func):
        """Decorator for function memoization"""
        cache = {}
        
        def wrapper(*args, **kwargs):
            # Create hashable key
            key = (args, tuple(sorted(kwargs.items())))
            
            if key not in cache:
                cache[key] = func(*args, **kwargs)
            return cache[key]
        
        wrapper.cache = cache
        wrapper.cache_clear = lambda: cache.clear()
        return wrapper
    
    @memoization_decorator
    def fibonacci_memo(n):
        """Memoized fibonacci calculation"""
        if n <= 1:
            return n
        return fibonacci_memo(n-1) + fibonacci_memo(n-2)
    
    # Example usage
    lru = LRUCache(3)
    lru.put(1, "first")
    lru.put(2, "second")
    lru.put(3, "third")
    lru.put(4, "fourth")  # Evicts key 1
    print(lru.get(2))     # Returns "second", moves to most recent
    ```

??? question "Q34: How do you implement advanced sorting algorithms?"
    **Pattern**: Complex sorting strategies
    ```python
    def merge_sort(lst):
        """Merge sort implementation"""
        if len(lst) <= 1:
            return lst
        
        mid = len(lst) // 2
        left = merge_sort(lst[:mid])
        right = merge_sort(lst[mid:])
        
        return merge_sorted_arrays(left, right)
    
    def merge_sorted_arrays(left, right):
        """Merge two sorted arrays"""
        result = []
        i = j = 0
        
        while i < len(left) and j < len(right):
            if left[i] <= right[j]:
                result.append(left[i])
                i += 1
            else:
                result.append(right[j])
                j += 1
        
        result.extend(left[i:])
        result.extend(right[j:])
        return result
    
    def quick_sort(lst):
        """Quick sort implementation"""
        if len(lst) <= 1:
            return lst
        
        pivot = lst[len(lst) // 2]
        left = [x for x in lst if x < pivot]
        middle = [x for x in lst if x == pivot]
        right = [x for x in lst if x > pivot]
        
        return quick_sort(left) + middle + quick_sort(right)
    
    def heap_sort(lst):
        """Heap sort implementation"""
        def heapify(arr, n, i):
            largest = i
            left = 2 * i + 1
            right = 2 * i + 2
            
            if left < n and arr[left] > arr[largest]:
                largest = left
            
            if right < n and arr[right] > arr[largest]:
                largest = right
            
            if largest != i:
                arr[i], arr[largest] = arr[largest], arr[i]
                heapify(arr, n, largest)
        
        n = len(lst)
        arr = lst.copy()
        
        # Build max heap
        for i in range(n // 2 - 1, -1, -1):
            heapify(arr, n, i)
        
        # Extract elements one by one
        for i in range(n - 1, 0, -1):
            arr[0], arr[i] = arr[i], arr[0]
            heapify(arr, i, 0)
        
        return arr
    
    def counting_sort(lst, max_val=None):
        """Counting sort for integers"""
        if not lst:
            return []
        
        if max_val is None:
            max_val = max(lst)
        
        min_val = min(lst)
        range_val = max_val - min_val + 1
        
        count = [0] * range_val
        output = [0] * len(lst)
        
        # Count occurrences
        for num in lst:
            count[num - min_val] += 1
        
        # Cumulative count
        for i in range(1, range_val):
            count[i] += count[i - 1]
        
        # Build output array
        for i in range(len(lst) - 1, -1, -1):
            output[count[lst[i] - min_val] - 1] = lst[i]
            count[lst[i] - min_val] -= 1
        
        return output
    
    def radix_sort(lst):
        """Radix sort for non-negative integers"""
        if not lst:
            return []
        
        max_num = max(lst)
        exp = 1
        
        while max_num // exp > 0:
            lst = counting_sort_by_digit(lst, exp)
            exp *= 10
        
        return lst
    
    def counting_sort_by_digit(lst, exp):
        """Helper for radix sort"""
        output = [0] * len(lst)
        count = [0] * 10
        
        for num in lst:
            digit = (num // exp) % 10
            count[digit] += 1
        
        for i in range(1, 10):
            count[i] += count[i - 1]
        
        for i in range(len(lst) - 1, -1, -1):
            digit = (lst[i] // exp) % 10
            output[count[digit] - 1] = lst[i]
            count[digit] -= 1
        
        return output
    
    def sort_comparison(lst, algorithms=None):
        """Compare different sorting algorithms"""
        import time
        
        if algorithms is None:
            algorithms = {
                'merge_sort': merge_sort,
                'quick_sort': quick_sort,
                'heap_sort': heap_sort,
                'python_sorted': sorted
            }
        
        results = {}
        
        for name, algo in algorithms.items():
            test_list = lst.copy()
            start_time = time.time()
            sorted_list = algo(test_list)
            end_time = time.time()
            
            results[name] = {
                'time': end_time - start_time,
                'result': sorted_list[:10] if len(sorted_list) > 10 else sorted_list
            }
        
        return results
    
    # Example
    numbers = [64, 34, 25, 12, 22, 11, 90, 88, 76, 50, 42]
    merge_sorted = merge_sort(numbers)
    quick_sorted = quick_sort(numbers)
    heap_sorted = heap_sort(numbers)
    ```

??? question "Q35: How do you implement graph algorithms on lists?"
    **Pattern**: Graph representation and traversal
    ```python
    def build_adjacency_list(edges):
        """Build adjacency list from edge list"""
        graph = {}
        for u, v in edges:
            if u not in graph:
                graph[u] = []
            if v not in graph:
                graph[v] = []
            graph[u].append(v)
            graph[v].append(u)  # For undirected graph
        return graph
    
    def depth_first_search(graph, start, visited=None):
        """DFS traversal"""
        if visited is None:
            visited = set()
        
        path = []
        
        def dfs_helper(node):
            visited.add(node)
            path.append(node)
            
            for neighbor in graph.get(node, []):
                if neighbor not in visited:
                    dfs_helper(neighbor)
        
        dfs_helper(start)
        return path
    
    def breadth_first_search(graph, start):
        """BFS traversal"""
        from collections import deque
        
        visited = set([start])
        queue = deque([start])
        path = []
        
        while queue:
            node = queue.popleft()
            path.append(node)
            
            for neighbor in graph.get(node, []):
                if neighbor not in visited:
                    visited.add(neighbor)
                    queue.append(neighbor)
        
        return path
    
    def find_shortest_path(graph, start, end):
        """Find shortest path using BFS"""
        from collections import deque
        
        if start == end:
            return [start]
        
        queue = deque([(start, [start])])
        visited = set([start])
        
        while queue:
            node, path = queue.popleft()
            
            for neighbor in graph.get(node, []):
                if neighbor == end:
                    return path + [neighbor]
                
                if neighbor not in visited:
                    visited.add(neighbor)
                    queue.append((neighbor, path + [neighbor]))
        
        return None  # No path found
    
    def detect_cycle(graph):
        """Detect cycle in undirected graph"""
        visited = set()
        
        def has_cycle_util(node, parent):
            visited.add(node)
            
            for neighbor in graph.get(node, []):
                if neighbor not in visited:
                    if has_cycle_util(neighbor, node):
                        return True
                elif neighbor != parent:
                    return True
            
            return False
        
        for node in graph:
            if node not in visited:
                if has_cycle_util(node, -1):
                    return True
        
        return False
    
    def topological_sort(graph):
        """Topological sort for DAG"""
        from collections import defaultdict, deque
        
        # Calculate in-degrees
        in_degree = defaultdict(int)
        for node in graph:
            in_degree[node] = 0
        
        for node in graph:
            for neighbor in graph[node]:
                in_degree[neighbor] += 1
        
        # Queue for nodes with no incoming edge
        queue = deque([node for node in in_degree if in_degree[node] == 0])
        topo_order = []
        
        while queue:
            node = queue.popleft()
            topo_order.append(node)
            
            for neighbor in graph.get(node, []):
                in_degree[neighbor] -= 1
                if in_degree[neighbor] == 0:
                    queue.append(neighbor)
        
        return topo_order if len(topo_order) == len(graph) else None
    
    def connected_components(graph):
        """Find all connected components"""
        visited = set()
        components = []
        
        for node in graph:
            if node not in visited:
                component = []
                stack = [node]
                
                while stack:
                    current = stack.pop()
                    if current not in visited:
                        visited.add(current)
                        component.append(current)
                        stack.extend(neighbor for neighbor in graph.get(current, []) 
                                   if neighbor not in visited)
                
                components.append(component)
        
        return components
    
    # Example
    edges = [(0, 1), (1, 2), (2, 3), (3, 0), (2, 4)]
    graph = build_adjacency_list(edges)
    dfs_path = depth_first_search(graph, 0)
    bfs_path = breadth_first_search(graph, 0)
    shortest = find_shortest_path(graph, 0, 4)
    has_cycle = detect_cycle(graph)
    components = connected_components(graph)
    ```

??? question "Q36: How do you implement dynamic programming solutions?"
    **Pattern**: Optimization problems
    ```python
    def knapsack_01(weights, values, capacity):
        """0/1 Knapsack problem"""
        n = len(weights)
        dp = [[0 for _ in range(capacity + 1)] for _ in range(n + 1)]
        
        for i in range(1, n + 1):
            for w in range(1, capacity + 1):
                if weights[i-1] <= w:
                    dp[i][w] = max(
                        values[i-1] + dp[i-1][w - weights[i-1]],
                        dp[i-1][w]
                    )
                else:
                    dp[i][w] = dp[i-1][w]
        
        # Backtrack to find items
        w = capacity
        items = []
        for i in range(n, 0, -1):
            if dp[i][w] != dp[i-1][w]:
                items.append(i-1)
                w -= weights[i-1]
        
        return dp[n][capacity], items[::-1]
    
    def coin_change(coins, amount):
        """Minimum coins needed to make amount"""
        dp = [float('inf')] * (amount + 1)
        dp[0] = 0
        
        for coin in coins:
            for i in range(coin, amount + 1):
                dp[i] = min(dp[i], dp[i - coin] + 1)
        
        return dp[amount] if dp[amount] != float('inf') else -1
    
    def longest_palindromic_substring(s):
        """Find longest palindromic substring"""
        if not s:
            return ""
        
        n = len(s)
        dp = [[False] * n for _ in range(n)]
        start = 0
        max_len = 1
        
        # Single characters are palindromes
        for i in range(n):
            dp[i][i] = True
        
        # Check for palindromes of length 2
        for i in range(n - 1):
            if s[i] == s[i + 1]:
                dp[i][i + 1] = True
                start = i
                max_len = 2
        
        # Check for palindromes of length 3 and more
        for length in range(3, n + 1):
            for i in range(n - length + 1):
                j = i + length - 1
                
                if s[i] == s[j] and dp[i + 1][j - 1]:
                    dp[i][j] = True
                    start = i
                    max_len = length
        
        return s[start:start + max_len]
    
    def word_break(s, word_dict):
        """Check if string can be segmented into dictionary words"""
        word_set = set(word_dict)
        dp = [False] * (len(s) + 1)
        dp[0] = True
        
        for i in range(1, len(s) + 1):
            for j in range(i):
                if dp[j] and s[j:i] in word_set:
                    dp[i] = True
                    break
        
        return dp[len(s)]
    
    def house_robber(houses):
        """Maximum money that can be robbed without robbing adjacent houses"""
        if not houses:
            return 0
        if len(houses) == 1:
            return houses[0]
        
        dp = [0] * len(houses)
        dp[0] = houses[0]
        dp[1] = max(houses[0], houses[1])
        
        for i in range(2, len(houses)):
            dp[i] = max(dp[i-1], dp[i-2] + houses[i])
        
        return dp[-1]
    
    def unique_paths(m, n):
        """Number of unique paths in m x n grid"""
        dp = [[1] * n for _ in range(m)]
        
        for i in range(1, m):
            for j in range(1, n):
                dp[i][j] = dp[i-1][j] + dp[i][j-1]
        
        return dp[m-1][n-1]
    
    def stock_profit_max(prices):
        """Maximum profit from buying and selling stock once"""
        if len(prices) < 2:
            return 0
        
        min_price = prices[0]
        max_profit = 0
        
        for price in prices[1:]:
            max_profit = max(max_profit, price - min_price)
            min_price = min(min_price, price)
        
        return max_profit
    
    def stock_profit_multiple_transactions(prices):
        """Maximum profit with multiple buy/sell transactions"""
        if len(prices) < 2:
            return 0
        
        profit = 0
        for i in range(1, len(prices)):
            if prices[i] > prices[i-1]:
                profit += prices[i] - prices[i-1]
        
        return profit
    
    # Example
    weights = [1, 3, 4, 5]
    values = [1, 4, 5, 7]
    capacity = 7
    max_value, selected_items = knapsack_01(weights, values, capacity)
    
    coins = [1, 3, 4]
    amount = 6
    min_coins = coin_change(coins, amount)  # 2 (3 + 3)
    ```

??? question "Q37: How do you implement string matching algorithms?"
    **Pattern**: Pattern searching
    ```python
    def naive_string_search(text, pattern):
        """Naive string matching algorithm"""
        matches = []
        n, m = len(text), len(pattern)
        
        for i in range(n - m + 1):
            if text[i:i + m] == pattern:
                matches.append(i)
        
        return matches
    
    def kmp_search(text, pattern):
        """Knuth-Morris-Pratt algorithm"""
        def build_lps_array(pattern):
            """Build longest proper prefix which is also suffix array"""
            m = len(pattern)
            lps = [0] * m
            length = 0
            i = 1
            
            while i < m:
                if pattern[i] == pattern[length]:
                    length += 1
                    lps[i] = length
                    i += 1
                else:# Python List Advanced Patterns - Complete Interview Guide

## 📚 Table of Contents
### Pattern 1: Manipulation & Transformation (Questions 1-8)
### Pattern 2: Search & Selection (Questions 9-16)
### Pattern 3: Mathematical Operations (Questions 17-24)
### Pattern 4: Sequence Analysis (Questions 25-32)
### Pattern 5: Advanced Algorithms (Questions 33-40)

---

## 🔧 Pattern 1: Manipulation & Transformation

??? question "Q1: How do you reverse a list at specific positions?"
    **Pattern**: Index-based manipulation
    ```python
    def reverse_at_position(lst, start, end):
        """Reverse list elements between start and end indices"""
        lst[start:end+1] = lst[start:end+1][::-1]
        return lst
    
    # Example usage
    nums = [1, 2, 3, 4, 5, 6, 7]
    result = reverse_at_position(nums, 2, 5)  # [1, 2, 6, 5, 4, 3, 7]
    ```

??? question "Q2: How do you remove duplicates while preserving order?"
    **Pattern**: Order-preserving filtering
    ```python
    def remove_duplicates_preserve_order(lst):
        """Remove duplicates maintaining original order"""
        seen = set()
        result = []
        for item in lst:
            if item not in seen:
                seen.add(item)
                result.append(item)
        return result
    
    # One-liner using dict (Python 3.7+)
    def remove_duplicates_dict(lst):
        return list(dict.fromkeys(lst))
    
    # Example
    nums = [1, 2, 2, 3, 1, 4, 3]
    result = remove_duplicates_preserve_order(nums)  # [1, 2, 3, 4]
    ```

??? question "Q3: How do you flatten a nested list structure?"
    **Pattern**: Recursive structure processing
    ```python
    def flatten_nested_list(lst):
        """Flatten arbitrarily nested list"""
        result = []
        for item in lst:
            if isinstance(item, list):
                result.extend(flatten_nested_list(item))
            else:
                result.append(item)
        return result
    
    # Using generators for memory efficiency
    def flatten_generator(lst):
        for item in lst:
            if isinstance(item, list):
                yield from flatten_generator(item)
            else:
                yield item
    
    # Example
    nested = [1, [2, 3], [4, [5, 6]], 7]
    result = flatten_nested_list(nested)  # [1, 2, 3, 4, 5, 6, 7]
    ```

??? question "Q4: How do you rotate a list by K positions?"
    **Pattern**: Circular shifting
    ```python
    def rotate_list(lst, k):
        """Rotate list k positions to the right"""
        if not lst or k == 0:
            return lst
        
        n = len(lst)
        k = k % n  # Handle k > n
        return lst[-k:] + lst[:-k]
    
    def rotate_left(lst, k):
        """Rotate list k positions to the left"""  
        return rotate_list(lst, -k)
    
    # Example
    nums = [1, 2, 3, 4, 5]
    right_rotated = rotate_list(nums, 2)  # [4, 5, 1, 2, 3]
    left_rotated = rotate_left(nums, 2)   # [3, 4, 5, 1, 2]
    ```

??? question "Q5: How do you partition a list based on a condition?"
    **Pattern**: Conditional partitioning
    ```python
    def partition_list(lst, condition):
        """Partition list into two sublists based on condition"""
        true_items = []
        false_items = []
        
        for item in lst:
            if condition(item):
                true_items.append(item)
            else:
                false_items.append(item)
        
        return true_items, false_items
    
    # Using list comprehensions
    def partition_comprehension(lst, condition):
        return ([x for x in lst if condition(x)], 
                [x for x in lst if not condition(x)])
    
    # Example
    numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    evens, odds = partition_list(numbers, lambda x: x % 2 == 0)
    # evens: [2, 4, 6, 8, 10], odds: [1, 3, 5, 7, 9]
    ```

??? question "Q6: How do you create all permutations of a list?"
    **Pattern**: Combinatorial generation
    ```python
    from itertools import permutations
    
    def get_permutations_builtin(lst):
        """Get all permutations using itertools"""
        return list(permutations(lst))
    
    def get_permutations_recursive(lst):
        """Generate permutations recursively"""
        if len(lst) <= 1:
            return [lst]
        
        result = []
        for i, item in enumerate(lst):
            remaining = lst[:i] + lst[i+1:]
            for perm in get_permutations_recursive(remaining):
                result.append([item] + perm)
        return result
    
    # Example
    items = [1, 2, 3]
    perms = get_permutations_recursive(items)
    # [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]
    ```

??? question "Q7: How do you merge and sort multiple lists?"
    **Pattern**: Multi-source aggregation
    ```python
    def merge_and_sort(*lists):
        """Merge multiple lists and sort the result"""
        merged = []
        for lst in lists:
            merged.extend(lst)
        return sorted(merged)
    
    def merge_sorted_lists(list1, list2):
        """Efficiently merge two already sorted lists"""
        result = []
        i, j = 0, 0
        
        while i < len(list1) and j < len(list2):
            if list1[i] <= list2[j]:
                result.append(list1[i])
                i += 1
            else:
                result.append(list2[j])
                j += 1
        
        # Add remaining elements
        result.extend(list1[i:])
        result.extend(list2[j:])
        return result
    
    # Example
    list_a = [1, 3, 5]
    list_b = [2, 4, 6]
    merged = merge_sorted_lists(list_a, list_b)  # [1, 2, 3, 4, 5, 6]
    ```

??? question "Q8: How do you create a sliding window over a list?"
    **Pattern**: Moving window processing
    ```python
    def sliding_window(lst, window_size):
        """Generate sliding windows of specified size"""
        if window_size > len(lst):
            return []
        
        windows = []
        for i in range(len(lst) - window_size + 1):
            windows.append(lst[i:i + window_size])
        return windows
    
    # Generator version for memory efficiency
    def sliding_window_generator(lst, window_size):
        for i in range(len(lst) - window_size + 1):
            yield lst[i:i + window_size]
    
    # Example
    numbers = [1, 2, 3, 4, 5, 6]
    windows = sliding_window(numbers, 3)
    # [[1, 2, 3], [2, 3, 4], [3, 4, 5], [4, 5, 6]]
    ```

---

## 🔍 Pattern 2: Search & Selection

??? question "Q9: How do you find the Kth largest/smallest element?"
    **Pattern**: Order-statistic selection
    ```python
    import heapq
    
    def find_kth_largest(lst, k):
        """Find kth largest element using heap"""
        return heapq.nlargest(k, lst)[-1]
    
    def find_kth_smallest(lst, k):
        """Find kth smallest element using heap"""
        return heapq.nsmallest(k, lst)[-1]
    
    def find_kth_largest_quickselect(lst, k):
        """Find kth largest using quickselect algorithm"""
        def quickselect(arr, left, right, k):
            if left == right:
                return arr[left]
            
            pivot_index = partition(arr, left, right)
            
            if k == pivot_index:
                return arr[k]
            elif k < pivot_index:
                return quickselect(arr, left, pivot_index - 1, k)
            else:
                return quickselect(arr, pivot_index + 1, right, k)
        
        def partition(arr, left, right):
            pivot = arr[right]
            i = left
            for j in range(left, right):
                if arr[j] >= pivot:  # For kth largest
                    arr[i], arr[j] = arr[j], arr[i]
                    i += 1
            arr[i], arr[right] = arr[right], arr[i]
            return i
        
        return quickselect(lst.copy(), 0, len(lst) - 1, k - 1)
    
    # Example
    numbers = [3, 1, 4, 1, 5, 9, 2, 6]
    third_largest = find_kth_largest(numbers, 3)  # 5
    ```

??? question "Q10: How do you find the first non-repeating element?"
    **Pattern**: Frequency-based search
    ```python
    def first_non_repeating(lst):
        """Find first element that appears exactly once"""
        from collections import Counter
        
        counts = Counter(lst)
        for item in lst:
            if counts[item] == 1:
                return item
        return None
    
    def first_non_repeating_manual(lst):
        """Manual implementation without Counter"""
        counts = {}
        
        # Count frequencies
        for item in lst:
            counts[item] = counts.get(item, 0) + 1
        
        # Find first non-repeating
        for item in lst:
            if counts[item] == 1:
                return item
        return None
    
    # Example
    elements = [4, 5, 1, 2, 0, 4, 5]
    first_unique = first_non_repeating(elements)  # 1
    ```

??? question "Q11: How do you find all pairs with a given sum?"
    **Pattern**: Two-pointer/Hash-based search
    ```python
    def find_pairs_with_sum(lst, target_sum):
        """Find all pairs that sum to target"""
        seen = set()
        pairs = set()
        
        for num in lst:
            complement = target_sum - num
            if complement in seen:
                # Ensure consistent ordering in pairs
                pair = (min(num, complement), max(num, complement))
                pairs.add(pair)
            seen.add(num)
        
        return list(pairs)
    
    def find_pairs_sorted_array(lst, target_sum):
        """Two-pointer approach for sorted array"""
        lst_sorted = sorted(lst)
        left, right = 0, len(lst_sorted) - 1
        pairs = []
        
        while left < right:
            current_sum = lst_sorted[left] + lst_sorted[right]
            if current_sum == target_sum:
                pairs.append((lst_sorted[left], lst_sorted[right]))
                left += 1
                right -= 1
            elif current_sum < target_sum:
                left += 1
            else:
                right -= 1
        
        return pairs
    
    # Example
    numbers = [1, 2, 3, 4, 5, 6]
    pairs = find_pairs_with_sum(numbers, 7)  # [(1, 6), (2, 5), (3, 4)]
    ```

??? question "Q12: How do you search in a rotated sorted array?"
    **Pattern**: Modified binary search
    ```python
    def search_rotated_array(lst, target):
        """Search for target in rotated sorted array"""
        left, right = 0, len(lst) - 1
        
        while left <= right:
            mid = (left + right) // 2
            
            if lst[mid] == target:
                return mid
            
            # Check which half is sorted
            if lst[left] <= lst[mid]:  # Left half is sorted
                if lst[left] <= target < lst[mid]:
                    right = mid - 1
                else:
                    left = mid + 1
            else:  # Right half is sorted
                if lst[mid] < target <= lst[right]:
                    left = mid + 1
                else:
                    right = mid - 1
        
        return -1  # Not found
    
    def find_rotation_point(lst):
        """Find the pivot point in rotated array"""
        left, right = 0, len(lst) - 1
        
        while left < right:
            mid = (left + right) // 2
            if lst[mid] > lst[right]:
                left = mid + 1
            else:
                right = mid
        
        return left
    
    # Example
    rotated = [4, 5, 6, 7, 0, 1, 2]
    index = search_rotated_array(rotated, 0)  # 4
    pivot = find_rotation_point(rotated)      # 4
    ```

??? question "Q13: How do you find elements missing from a range?"
    **Pattern**: Set-based difference analysis
    ```python
    def find_missing_numbers(lst, start, end):
        """Find missing numbers in a given range"""
        expected = set(range(start, end + 1))
        actual = set(lst)
        return sorted(list(expected - actual))
    
    def find_missing_in_sequence(lst):
        """Find missing numbers in consecutive sequence"""
        if not lst:
            return []
        
        lst_set = set(lst)
        min_val, max_val = min(lst), max(lst)
        missing = []
        
        for i in range(min_val, max_val + 1):
            if i not in lst_set:
                missing.append(i)
        
        return missing
    
    def find_duplicate_and_missing(lst, n):
        """Find duplicate and missing number in 1 to n"""
        expected_sum = n * (n + 1) // 2
        expected_sum_squares = n * (n + 1) * (2 * n + 1) // 6
        
        actual_sum = sum(lst)
        actual_sum_squares = sum(x * x for x in lst)
        
        diff_sum = actual_sum - expected_sum  # duplicate - missing
        diff_squares = actual_sum_squares - expected_sum_squares
        
        # duplicate + missing = diff_squares / diff_sum
        sum_dup_miss = diff_squares // diff_sum
        
        duplicate = (diff_sum + sum_dup_miss) // 2
        missing = sum_dup_miss - duplicate
        
        return duplicate, missing
    
    # Example
    numbers = [1, 2, 4, 6, 7, 9]
    missing = find_missing_in_sequence(numbers)  # [3, 5, 8]
    ```

??? question "Q14: How do you find the intersection and union of multiple lists?"
    **Pattern**: Set operations on sequences
    ```python
    def list_intersection(*lists):
        """Find intersection of multiple lists"""
        if not lists:
            return []
        
        result = set(lists[0])
        for lst in lists[1:]:
            result &= set(lst)
        
        return list(result)
    
    def list_union(*lists):
        """Find union of multiple lists"""
        result = set()
        for lst in lists:
            result |= set(lst)
        return list(result)
    
    def list_difference(list1, list2):
        """Find elements in list1 but not in list2"""
        return list(set(list1) - set(list2))
    
    def symmetric_difference(list1, list2):
        """Find elements in either list but not in both"""
        return list(set(list1) ^ set(list2))
    
    # Preserve order versions
    def intersection_preserve_order(list1, list2):
        """Intersection preserving order of first list"""
        set2 = set(list2)
        return [x for x in list1 if x in set2]
    
    # Example
    list_a = [1, 2, 3, 4, 5]
    list_b = [3, 4, 5, 6, 7]
    list_c = [4, 5, 6, 7, 8]
    
    intersection = list_intersection(list_a, list_b, list_c)  # [4, 5]
    union = list_union(list_a, list_b)  # [1, 2, 3, 4, 5, 6, 7]
    ```

??? question "Q15: How do you find local maxima and minima?"
    **Pattern**: Peak/valley detection
    ```python
    def find_local_maxima(lst):
        """Find all local maximum points"""
        if len(lst) < 3:
            return []
        
        maxima = []
        for i in range(1, len(lst) - 1):
            if lst[i] > lst[i-1] and lst[i] > lst[i+1]:
                maxima.append((i, lst[i]))
        
        return maxima
    
    def find_local_minima(lst):
        """Find all local minimum points"""
        if len(lst) < 3:
            return []
        
        minima = []
        for i in range(1, len(lst) - 1):
            if lst[i] < lst[i-1] and lst[i] < lst[i+1]:
                minima.append((i, lst[i]))
        
        return minima
    
    def find_peak_element(lst):
        """Find any peak element using binary search"""
        left, right = 0, len(lst) - 1
        
        while left < right:
            mid = (left + right) // 2
            if lst[mid] < lst[mid + 1]:
                left = mid + 1
            else:
                right = mid
        
        return left
    
    # Example
    values = [1, 3, 2, 4, 1, 5, 2]
    maxima = find_local_maxima(values)  # [(1, 3), (3, 4), (5, 5)]
    minima = find_local_minima(values)  # [(2, 2), (4, 1), (6, 2)]
    ```

??? question "Q16: How do you find the longest substring/subarray patterns?"
    **Pattern**: Sliding window with conditions
    ```python
    def longest_increasing_subsequence_length(lst):
        """Find length of longest increasing subsequence"""
        if not lst:
            return 0
        
        dp = [1] * len(lst)
        
        for i in range(1, len(lst)):
            for j in range(i):
                if lst[j] < lst[i]:
                    dp[i] = max(dp[i], dp[j] + 1)
        
        return max(dp)
    
    def longest_common_subsequence(list1, list2):
        """Find longest common subsequence between two lists"""
        m, n = len(list1), len(list2)
        dp = [[0] * (n + 1) for _ in range(m + 1)]
        
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                if list1[i-1] == list2[j-1]:
                    dp[i][j] = dp[i-1][j-1] + 1
                else:
                    dp[i][j] = max(dp[i-1][j], dp[i][j-1])
        
        return dp[m][n]
    
    def longest_consecutive_sequence(lst):
        """Find length of longest consecutive sequence"""
        if not lst:
            return 0
        
        num_set = set(lst)
        longest = 0
        
        for num in num_set:
            # Only start counting if it's the beginning of a sequence
            if num - 1 not in num_set:
                current_num = num
                current_length = 1
                
                while current_num + 1 in num_set:
                    current_num += 1
                    current_length += 1
                
                longest = max(longest, current_length)
        
        return longest
    
    # Example
    numbers = [100, 4, 200, 1, 3, 2]
    consecutive_len = longest_consecutive_sequence(numbers)  # 4 ([1,2,3,4])
    ```

---

## 🧮 Pattern 3: Mathematical Operations

??? question "Q17: How do you find the maximum/minimum sum subarray?"
    **Pattern**: Dynamic programming optimization
    ```python
    def max_subarray_sum(lst):
        """Find maximum sum of contiguous subarray (Kadane's algorithm)"""
        if not lst:
            return 0
        
        max_sum = current_sum = lst[0]
        
        for i in range(1, len(lst)):
            current_sum = max(lst[i], current_sum + lst[i])
            max_sum = max(max_sum, current_sum)
        
        return max_sum
    
    def max_subarray_with_indices(lst):
        """Return max sum subarray with start and end indices"""
        if not lst:
            return 0, 0, 0
        
        max_sum = current_sum = lst[0]
        start = end = temp_start = 0
        
        for i in range(1, len(lst)):
            if current_sum < 0:
                current_sum = lst[i]
                temp_start = i
            else:
                current_sum += lst[i]
            
            if current_sum > max_sum:
                max_sum = current_sum
                start = temp_start
                end = i
        
        return max_sum, start, end
    
    def min_subarray_sum(lst):
        """Find minimum sum of contiguous subarray"""
        if not lst:
            return 0
        
        min_sum = current_sum = lst[0]
        
        for i in range(1, len(lst)):
            current_sum = min(lst[i], current_sum + lst[i])
            min_sum = min(min_sum, current_sum)
        
        return min_sum
    
    # Example
    numbers = [-2, 1, -3, 4, -1, 2, 1, -5, 4]
    max_sum = max_subarray_sum(numbers)  # 6 (subarray [4,-1,2,1])
    ```

??? question "Q18: How do you calculate cumulative operations?"
    **Pattern**: Prefix/suffix computations
    ```python
    def cumulative_sum(lst):
        """Calculate cumulative sum array"""
        if not lst:
            return []
        
        result = [lst[0]]
        for i in range(1, len(lst)):
            result.append(result[-1] + lst[i])
        return result
    
    def cumulative_product(lst):
        """Calculate cumulative product array"""
        if not lst:
            return []
        
        result = [lst[0]]
        for i in range(1, len(lst)):
            result.append(result[-1] * lst[i])
        return result
    
    def prefix_suffix_products(lst):
        """Calculate prefix and suffix products for each position"""
        n = len(lst)
        if n == 0:
            return []
        
        prefix = [1] * n
        suffix = [1] * n
        
        # Calculate prefix products
        for i in range(1, n):
            prefix[i] = prefix[i-1] * lst[i-1]
        
        # Calculate suffix products
        for i in range(n-2, -1, -1):
            suffix[i] = suffix[i+1] * lst[i+1]
        
        # Product of all except current element
        result = [prefix[i] * suffix[i] for i in range(n)]
        return result
    
    def running_average(lst, window_size):
        """Calculate running average with specified window"""
        if len(lst) < window_size:
            return []
        
        result = []
        window_sum = sum(lst[:window_size])
        result.append(window_sum / window_size)
        
        for i in range(window_size, len(lst)):
            window_sum += lst[i] - lst[i - window_size]
            result.append(window_sum / window_size)
        
        return result
    
    # Example
    numbers = [1, 2, 3, 4, 5]
    cum_sum = cumulative_sum(numbers)     # [1, 3, 6, 10, 15]
    products = prefix_suffix_products(numbers)  # [120, 60, 40, 30, 24]
    ```

??? question "Q19: How do you find statistical measures?"
    **Pattern**: Statistical analysis
    ```python
    def calculate_statistics(lst):
        """Calculate comprehensive statistics for a list"""
        if not lst:
            return {}
        
        n = len(lst)
        sorted_lst = sorted(lst)
        
        # Basic measures
        mean = sum(lst) / n
        median = (sorted_lst[n//2] + sorted_lst[(n-1)//2]) / 2
        mode_count = {}
        for x in lst:
            mode_count[x] = mode_count.get(x, 0) + 1
        mode = max(mode_count.keys(), key=mode_count.get)
        
        # Variance and standard deviation
        variance = sum((x - mean) ** 2 for x in lst) / n
        std_dev = variance ** 0.5
        
        # Quartiles
        q1 = sorted_lst[n//4] if n >= 4 else sorted_lst[0]
        q3 = sorted_lst[3*n//4] if n >= 4 else sorted_lst[-1]
        iqr = q3 - q1
        
        return {
            'count': n,
            'mean': mean,
            'median': median,
            'mode': mode,
            'variance': variance,
            'std_dev': std_dev,
            'min': min(lst),
            'max': max(lst),
            'range': max(lst) - min(lst),
            'q1': q1,
            'q3': q3,
            'iqr': iqr
        }
    
    def detect_outliers(lst, method='iqr'):
        """Detect outliers using IQR or Z-score method"""
        if method == 'iqr':
            stats = calculate_statistics(lst)
            lower_bound = stats['q1'] - 1.5 * stats['iqr']
            upper_bound = stats['q3'] + 1.5 * stats['iqr']
            return [x for x in lst if x < lower_bound or x > upper_bound]
        
        elif method == 'zscore':
            mean = sum(lst) / len(lst)
            std_dev = (sum((x - mean) ** 2 for x in lst) / len(lst)) ** 0.5
            return [x for x in lst if abs((x - mean) / std_dev) > 2]
    
    # Example
    data = [1, 2, 3, 4, 5, 100]  # 100 is an outlier
    stats = calculate_statistics(data)
    outliers = detect_outliers(data)  # [100]
    ```

??? question "Q20: How do you perform matrix operations on 2D lists?"
    **Pattern**: 2D array manipulation
    ```python
    def matrix_transpose(matrix):
        """Transpose a 2D matrix"""
        if not matrix or not matrix[0]:
            return []
        
        rows, cols = len(matrix), len(matrix[0])
        return [[matrix[i][j] for i in range(rows)] for j in range(cols)]
    
    def matrix_multiply(A, B):
        """Multiply two matrices"""
        if not A or not B or len(A[0]) != len(B):
            return None
        
        rows_A, cols_A = len(A), len(A[0])
        rows_B, cols_B = len(B), len(B[0])
        
        result = [[0] * cols_B for _ in range(rows_A)]
        
        for i in range(rows_A):
            for j in range(cols_B):
                for k in range(cols_A):
                    result[i][j] += A[i][k] * B[k][j]
        
        return result
    
    def rotate_matrix_90(matrix):
        """Rotate matrix 90 degrees clockwise"""
        n = len(matrix)
        # First transpose
        for i in range(n):
            for j in range(i, n):
                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]
        
        # Then reverse each row
        for i in range(n):
            matrix[i].reverse()
        
        return matrix
    
    def spiral_traverse(matrix):
        """Traverse matrix in spiral order"""
        if not matrix or not matrix[0]:
            return []
        
        result = []
        top, bottom = 0, len(matrix) - 1
        left, right = 0, len(matrix[0]) - 1
        
        while top <= bottom and left <= right:
            # Traverse right
            for j in range(left, right + 1):
                result.append(matrix[top][j])
            top += 1
            
            # Traverse down
            for i in range(top, bottom + 1):
                result.append(matrix[i][right])
            right -= 1
            
            # Traverse left (if we still have rows)
            if top <= bottom:
                for j in range(right, left - 1, -1):
                    result.append(matrix[bottom][j])
                bottom -= 1
            
            # Traverse up (if we still have columns)
            if left <= right:
                for i in range(bottom, top - 1, -1):
                    result.append(matrix[i][left])
                left += 1
        
        return result
    
    # Example
    matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
    transposed = matrix_transpose(matrix)  # [[1, 4, 7], [2, 5, 8], [3, 6, 9]]
    spiral = spiral_traverse(matrix)       # [1, 2, 3, 6, 9, 8, 7, 4, 5]