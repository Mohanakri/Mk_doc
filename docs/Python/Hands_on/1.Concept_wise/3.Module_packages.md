

# Python Modules, Packages & Benchmarking - Complete Practice Guide

## üìö Table of Contents
### Benchmarking Questions
### Module Basics Questions
### Module Import Questions  
### Package Questions
### Advanced Module Topics

---

## ‚è±Ô∏è Benchmarking Questions

??? question "Q1: How do you measure execution time of a function using timeit?"
    ```python
    import timeit
    
    # Method 1: Using timeit.timeit()
    def example_function():
        return sum(range(100))
    
    # Measure execution time
    execution_time = timeit.timeit(example_function, number=10000)
    print(f"Execution time: {execution_time:.6f} seconds")
    
    # Method 2: Using timeit with setup code
    code_to_test = """
    result = sum(range(100))
    """
    
    time_taken = timeit.timeit(code_to_test, number=10000)
    print(f"Time taken: {time_taken:.6f} seconds")
    
    # Method 3: Command line usage
    # python -m timeit "sum(range(100))"
    ```

??? question "Q2: How do you benchmark multiple approaches and compare performance?"
    ```python
    import timeit
    import time
    
    def approach1_list_comprehension():
        return [x**2 for x in range(1000)]
    
    def approach2_map():
        return list(map(lambda x: x**2, range(1000)))
    
    def approach3_for_loop():
        result = []
        for x in range(1000):
            result.append(x**2)
        return result
    
    # Benchmark all approaches
    approaches = [
        ("List Comprehension", approach1_list_comprehension),
        ("Map Function", approach2_map),
        ("For Loop", approach3_for_loop)
    ]
    
    for name, func in approaches:
        time_taken = timeit.timeit(func, number=1000)
        print(f"{name}: {time_taken:.6f} seconds")
    ```

??? question "Q3: How do you use time.perf_counter() for precise timing?"
    ```python
    import time
    
    def benchmark_with_perf_counter():
        start = time.perf_counter()
        
        # Code to benchmark
        result = sum(x**2 for x in range(100000))
        
        end = time.perf_counter()
        execution_time = end - start
        
        print(f"Execution time: {execution_time:.6f} seconds")
        return result
    
    # Context manager for timing
    class Timer:
        def __enter__(self):
            self.start = time.perf_counter()
            return self
        
        def __exit__(self, *args):
            self.end = time.perf_counter()
            self.duration = self.end - self.start
    
    # Usage
    with Timer() as timer:
        result = sum(range(1000000))
    
    print(f"Operation took: {timer.duration:.6f} seconds")
    ```

??? question "Q4: How do you profile memory usage while benchmarking?"
    ```python
    import tracemalloc
    import time
    
    def memory_benchmark():
        # Start tracing memory allocations
        tracemalloc.start()
        
        start_time = time.perf_counter()
        
        # Code to benchmark
        large_list = [i**2 for i in range(100000)]
        
        end_time = time.perf_counter()
        
        # Get memory usage
        current, peak = tracemalloc.get_traced_memory()
        tracemalloc.stop()
        
        print(f"Execution time: {end_time - start_time:.6f} seconds")
        print(f"Current memory usage: {current / 1024 / 1024:.2f} MB")
        print(f"Peak memory usage: {peak / 1024 / 1024:.2f} MB")
        
        return large_list
    
    # Alternative using memory_profiler (pip install memory-profiler)
    # @profile decorator can be used for line-by-line memory profiling
    ```

---

## üîß Module Basics Questions

??? question "Q5: What is a Python module and how do you create one?"
    ```python
    # Create a file called math_utils.py
    """
    math_utils.py - A simple math utilities module
    """
    
    def add(a, b):
        """Add two numbers"""
        return a + b
    
    def multiply(a, b):
        """Multiply two numbers"""
        return a * b
    
    def factorial(n):
        """Calculate factorial of n"""
        if n <= 1:
            return 1
        return n * factorial(n - 1)
    
    # Module-level variable
    PI = 3.14159
    
    # Code that runs when module is imported
    print(f"Math utils module loaded with PI = {PI}")
    
    # main.py - Using the module
    import math_utils
    
    result1 = math_utils.add(5, 3)
    result2 = math_utils.multiply(4, 6)
    print(f"Addition: {result1}, Multiplication: {result2}")
    print(f"PI value: {math_utils.PI}")
    ```

??? question "Q6: What are the different ways to import modules?"
    ```python
    # 1. Import entire module
    import math
    result = math.sqrt(16)
    
    # 2. Import specific functions
    from math import sqrt, sin, cos
    result = sqrt(16)
    
    # 3. Import with alias
    import math as m
    result = m.sqrt(16)
    
    # 4. Import specific function with alias
    from math import sqrt as square_root
    result = square_root(16)
    
    # 5. Import all (not recommended)
    from math import *
    result = sqrt(16)
    
    # 6. Conditional import
    try:
        import numpy as np
        HAS_NUMPY = True
    except ImportError:
        HAS_NUMPY = False
        print("NumPy not available")
    
    # 7. Dynamic import
    import importlib
    math_module = importlib.import_module('math')
    result = math_module.sqrt(16)
    ```

??? question "Q7: How do you handle module search paths and PYTHONPATH?"
    ```python
    import sys
    import os
    
    # View current Python path
    print("Current Python path:")
    for path in sys.path:
        print(f"  {path}")
    
    # Add custom path to sys.path
    custom_path = "/path/to/my/modules"
    if custom_path not in sys.path:
        sys.path.insert(0, custom_path)
    
    # Alternative: Add to PYTHONPATH environment variable
    # export PYTHONPATH="${PYTHONPATH}:/path/to/my/modules"
    
    # Check if module exists before importing
    def safe_import(module_name):
        try:
            module = __import__(module_name)
            return module
        except ImportError:
            print(f"Module {module_name} not found")
            return None
    
    # Find module location
    import math
    print(f"Math module location: {math.__file__}")
    
    # Using importlib to find module spec
    import importlib.util
    spec = importlib.util.find_spec("math")
    if spec:
        print(f"Math module found at: {spec.origin}")
    ```

??? question "Q8: What is __name__ == '__main__' and why is it important?"
    ```python
    # my_module.py
    def main_function():
        print("This is the main function")
    
    def helper_function():
        print("This is a helper function")
    
    # This code only runs when script is executed directly
    if __name__ == "__main__":
        print("Script is being run directly")
        main_function()
    else:
        print(f"Script imported as module: {__name__}")
    
    # Benefits:
    # 1. Code reusability - module can be imported without running main code
    # 2. Testing - allows for easy testing of individual functions
    # 3. Script vs Module distinction
    
    # Example usage:
    # python my_module.py  -> runs main code
    # import my_module     -> doesn't run main code, just imports functions
    
    # Advanced example with argument parsing
    import sys
    
    def process_data(data):
        return [x * 2 for x in data]
    
    def main():
        if len(sys.argv) > 1:
            numbers = [int(x) for x in sys.argv[1:]]
            result = process_data(numbers)
            print(f"Result: {result}")
        else:
            print("Usage: python script.py num1 num2 num3...")
    
    if __name__ == "__main__":
        main()
    ```

---

## üì¶ Package Questions

??? question "Q9: How do you create a Python package with __init__.py?"
    ```python
    # Directory structure:
    # my_package/
    #   __init__.py
    #   module1.py
    #   module2.py
    #   subpackage/
    #     __init__.py
    #     submodule.py
    
    # my_package/__init__.py
    """
    My Package - A sample Python package
    """
    
    __version__ = "1.0.0"
    __author__ = "Your Name"
    
    # Import frequently used functions to package level
    from .module1 import important_function
    from .module2 import another_function
    
    # Define what gets imported with "from my_package import *"
    __all__ = ['important_function', 'another_function', 'helper_function']
    
    def helper_function():
        return "Helper from package init"
    
    print(f"My Package v{__version__} initialized")
    
    # my_package/module1.py
    def important_function():
        return "This is important!"
    
    def private_function():
        return "This is private to module1"
    
    # my_package/module2.py
    from .module1 import private_function  # Relative import
    
    def another_function():
        return f"Another function: {private_function()}"
    
    # Usage:
    import my_package
    
    # These work because of __init__.py imports
    result1 = my_package.important_function()
    result2 = my_package.helper_function()
    ```

??? question "Q10: What are relative vs absolute imports and when to use them?"
    ```python
    # Package structure:
    # myproject/
    #   __init__.py
    #   main.py
    #   utils/
    #     __init__.py
    #     helpers.py
    #     formatters.py
    #   data/
    #     __init__.py
    #     processors.py
    
    # Absolute imports (preferred for clarity)
    # myproject/main.py
    from myproject.utils.helpers import process_data
    from myproject.data.processors import clean_data
    import myproject.utils.formatters as fmt
    
    # Relative imports (within package)
    # myproject/utils/formatters.py
    from .helpers import validate_input        # Same level
    from ..data.processors import clean_data   # Parent level
    from . import helpers                      # Import module from same package
    
    # myproject/utils/__init__.py
    from .helpers import *
    from .formatters import format_output
    
    # Rules for relative imports:
    # 1. Use single dot (.) for current package/directory
    # 2. Use double dot (..) for parent package/directory
    # 3. Only work within packages (not in main scripts)
    # 4. Cannot go above top-level package
    
    # Example with both approaches:
    # myproject/utils/helpers.py
    import os
    from typing import List, Dict
    
    # Absolute import for external packages
    import json
    import datetime
    
    # Relative import for internal modules
    from ..data import processors
    
    def process_data(data: List[Dict]) -> List[Dict]:
        # Use internal processor
        cleaned = processors.clean_data(data)
        return cleaned
    ```

??? question "Q11: How do you create namespace packages?"
    ```python
    # Namespace packages allow splitting a package across multiple directories
    # No __init__.py required in namespace package directories
    
    # Structure:
    # site-packages/
    #   namespace_pkg/
    #     subpkg1/
    #       __init__.py
    #       module1.py
    #   another_location/
    #     namespace_pkg/
    #       subpkg2/
    #         __init__.py
    #         module2.py
    
    # Method 1: PEP 420 - Implicit namespace packages (Python 3.3+)
    # Just don't create __init__.py in the namespace package directory
    
    # Method 2: pkgutil-style namespace packages
    # namespace_pkg/__init__.py (if you need one)
    __path__ = __import__('pkgutil').extend_path(__path__, __name__)
    
    # Method 3: pkg_resources-style namespace packages
    # namespace_pkg/__init__.py
    __import__('pkg_resources').declare_namespace(__name__)
    
    # Usage:
    from namespace_pkg.subpkg1 import module1
    from namespace_pkg.subpkg2 import module2
    
    # Both work even though they're in different physical locations
    ```

??? question "Q12: How do you handle package installation and setup.py?"
    ```python
    # setup.py - Traditional setup script
    from setuptools import setup, find_packages
    
    with open("README.md", "r", encoding="utf-8") as fh:
        long_description = fh.read()
    
    setup(
        name="my-awesome-package",
        version="0.1.0",
        author="Your Name",
        author_email="your.email@example.com",
        description="A small example package",
        long_description=long_description,
        long_description_content_type="text/markdown",
        url="https://github.com/yourusername/my-awesome-package",
        packages=find_packages(),
        classifiers=[
            "Programming Language :: Python :: 3",
            "License :: OSI Approved :: MIT License",
            "Operating System :: OS Independent",
        ],
        python_requires='>=3.6',
        install_requires=[
            'requests>=2.25.0',
            'numpy>=1.19.0',
        ],
        extras_require={
            'dev': ['pytest>=6.0', 'black', 'flake8'],
            'docs': ['sphinx', 'sphinx-rtd-theme'],
        },
        entry_points={
            'console_scripts': [
                'my-tool=my_package.cli:main',
            ],
        },
    )
    
    # pyproject.toml - Modern approach (PEP 518)
    """
    [build-system]
    requires = ["setuptools>=45", "wheel"]
    build-backend = "setuptools.build_meta"
    
    [project]
    name = "my-awesome-package"
    version = "0.1.0"
    description = "A small example package"
    readme = "README.md"
    authors = [{name = "Your Name", email = "your.email@example.com"}]
    classifiers = [
        "Programming Language :: Python :: 3",
        "License :: OSI Approved :: MIT License",
        "Operating System :: OS Independent",
    ]
    requires-python = ">=3.6"
    dependencies = [
        "requests>=2.25.0",
        "numpy>=1.19.0",
    ]
    
    [project.optional-dependencies]
    dev = ["pytest>=6.0", "black", "flake8"]
    docs = ["sphinx", "sphinx-rtd-theme"]
    
    [project.scripts]
    my-tool = "my_package.cli:main"
    """
    ```

---

## üöÄ Advanced Module Topics

??? question "Q13: How do you implement lazy loading and module caching?"
    ```python
    import importlib
    from functools import lru_cache
    
    class LazyImporter:
        """Lazy import modules only when needed"""
        
        def __init__(self, module_name):
            self.module_name = module_name
            self._module = None
        
        def __getattr__(self, name):
            if self._module is None:
                self._module = importlib.import_module(self.module_name)
            return getattr(self._module, name)
    
    # Usage
    np = LazyImporter('numpy')
    # numpy is only imported when we actually use it
    array = np.array([1, 2, 3, 4])
    
    # Module factory with caching
    @lru_cache(maxsize=None)
    def get_module(module_name):
        """Cache imported modules"""
        try:
            return importlib.import_module(module_name)
        except ImportError:
            return None
    
    # Conditional imports with fallbacks
    def get_json_module():
        """Try to get the fastest JSON module available"""
        modules_to_try = ['ujson', 'orjson', 'json']
        
        for module_name in modules_to_try:
            module = get_module(module_name)
            if module is not None:
                return module
        
        raise ImportError("No JSON module available")
    
    json_module = get_json_module()
    data = json_module.loads('{"key": "value"}')
    ```

??? question "Q14: How do you implement module reloading for development?"
    ```python
    import importlib
    import sys
    
    # Simple module reloading
    def reload_module(module_name):
        """Reload a module if it's already imported"""
        if module_name in sys.modules:
            importlib.reload(sys.modules[module_name])
        else:
            importlib.import_module(module_name)
    
    # Advanced auto-reloader for development
    import os
    import time
    from pathlib import Path
    
    class AutoReloader:
        def __init__(self):
            self.module_timestamps = {}
        
        def watch_module(self, module_name):
            """Add a module to the watch list"""
            try:
                module = sys.modules[module_name]
                if hasattr(module, '__file__') and module.__file__:
                    file_path = Path(module.__file__)
                    if file_path.exists():
                        self.module_timestamps[module_name] = file_path.stat().st_mtime
            except KeyError:
                print(f"Module {module_name} not imported yet")
        
        def check_and_reload(self):
            """Check for changes and reload if necessary"""
            for module_name, last_timestamp in list(self.module_timestamps.items()):
                try:
                    module = sys.modules[module_name]
                    if hasattr(module, '__file__') and module.__file__:
                        file_path = Path(module.__file__)
                        if file_path.exists():
                            current_timestamp = file_path.stat().st_mtime
                            if current_timestamp > last_timestamp:
                                print(f"Reloading {module_name}...")
                                importlib.reload(module)
                                self.module_timestamps[module_name] = current_timestamp
                except Exception as e:
                    print(f"Error reloading {module_name}: {e}")
    
    # Usage in development
    reloader = AutoReloader()
    import my_module
    reloader.watch_module('my_module')
    
    # In development loop
    while True:
        reloader.check_and_reload()
        # Your development code here
        time.sleep(1)
    ```

??? question "Q15: How do you implement module plugins and dynamic loading?"
    ```python
    import importlib
    import pkgutil
    from abc import ABC, abstractmethod
    from typing import List, Type
    
    # Plugin interface
    class Plugin(ABC):
        @abstractmethod
        def execute(self, data):
            pass
        
        @abstractmethod
        def get_name(self) -> str:
            pass
    
    # Plugin manager
    class PluginManager:
        def __init__(self, plugin_package_name='plugins'):
            self.plugin_package = plugin_package_name
            self.plugins: List[Plugin] = []
        
        def discover_plugins(self):
            """Dynamically discover and load plugins"""
            try:
                # Import the plugin package
                plugin_package = importlib.import_module(self.plugin_package)
                
                # Iterate through all modules in the package
                for importer, modname, ispkg in pkgutil.iter_modules(
                    plugin_package.__path__, 
                    plugin_package.__name__ + "."
                ):
                    try:
                        module = importlib.import_module(modname)
                        self._register_plugin_from_module(module)
                    except Exception as e:
                        print(f"Error loading plugin {modname}: {e}")
                        
            except ImportError:
                print(f"Plugin package '{self.plugin_package}' not found")
        
        def _register_plugin_from_module(self, module):
            """Register plugins from a module"""
            for name in dir(module):
                obj = getattr(module, name)
                if (isinstance(obj, type) and 
                    issubclass(obj, Plugin) and 
                    obj != Plugin):
                    
                    plugin_instance = obj()
                    self.plugins.append(plugin_instance)
                    print(f"Registered plugin: {plugin_instance.get_name()}")
        
        def execute_plugins(self, data):
            """Execute all registered plugins"""
            results = {}
            for plugin in self.plugins:
                try:
                    result = plugin.execute(data)
                    results[plugin.get_name()] = result
                except Exception as e:
                    results[plugin.get_name()] = f"Error: {e}"
            return results
    
    # Example plugin implementation
    # plugins/text_processor.py
    """
    from main import Plugin
    
    class UpperCasePlugin(Plugin):
        def execute(self, data):
            return data.upper()
        
        def get_name(self) -> str:
            return "UpperCase"
    
    class ReversPlugin(Plugin):
        def execute(self, data):
            return data[::-1]
        
        def get_name(self) -> str:
            return "Reverse"
    """
    
    # Usage
    manager = PluginManager()
    manager.discover_plugins()
    results = manager.execute_plugins("Hello World")
    print(results)
    ```

??? question "Q16: How do you handle module conflicts and version management?"
    ```python
    import sys
    import importlib.util
    from pathlib import Path
    
    class ModuleVersionManager:
        """Manage different versions of modules"""
        
        def __init__(self):
            self.version_paths = {}
        
        def add_version_path(self, module_name, version, path):
            """Add a specific version path for a module"""
            if module_name not in self.version_paths:
                self.version_paths[module_name] = {}
            self.version_paths[module_name][version] = Path(path)
        
        def import_version(self, module_name, version=None):
            """Import a specific version of a module"""
            if version is None:
                # Import latest version or default
                return importlib.import_module(module_name)
            
            if (module_name in self.version_paths and 
                version in self.version_paths[module_name]):
                
                version_path = self.version_paths[module_name][version]
                spec = importlib.util.spec_from_file_location(
                    f"{module_name}_v{version}", 
                    version_path
                )
                
                if spec and spec.loader:
                    module = importlib.util.module_from_spec(spec)
                    spec.loader.exec_module(module)
                    return module
            
            raise ImportError(f"Version {version} of {module_name} not found")
    
    # Usage
    version_manager = ModuleVersionManager()
    version_manager.add_version_path('my_lib', '1.0', '/path/to/my_lib_v1.py')
    version_manager.add_version_path('my_lib', '2.0', '/path/to/my_lib_v2.py')
    
    # Import specific versions
    lib_v1 = version_manager.import_version('my_lib', '1.0')
    lib_v2 = version_manager.import_version('my_lib', '2.0')
    
    # Module conflict resolution
    def resolve_import_conflict(module_name, preferred_locations=None):
        """Resolve import conflicts by checking multiple locations"""
        if preferred_locations is None:
            preferred_locations = sys.path
        
        for location in preferred_locations:
            module_path = Path(location) / f"{module_name}.py"
            if module_path.exists():
                spec = importlib.util.spec_from_file_location(
                    module_name, module_path
                )
                if spec and spec.loader:
                    module = importlib.util.module_from_spec(spec)
                    spec.loader.exec_module(module)
                    print(f"Loaded {module_name} from {module_path}")
                    return module
        
        raise ImportError(f"Could not resolve import for {module_name}")
    
    # Check for module conflicts
    def check_module_conflicts():
        """Check for potential module naming conflicts"""
        module_locations = {}
        
        for path in sys.path:
            path_obj = Path(path)
            if path_obj.exists():
                for py_file in path_obj.glob("*.py"):
                    module_name = py_file.stem
                    if module_name not in module_locations:
                        module_locations[module_name] = []
                    module_locations[module_name].append(str(py_file))
        
        # Report conflicts
        conflicts = {name: paths for name, paths in module_locations.items() 
                    if len(paths) > 1}
        
        if conflicts:
            print("Module naming conflicts detected:")
            for module, paths in conflicts.items():
                print(f"  {module}:")
                for path in paths:
                    print(f"    - {path}")
        
        return conflicts
    
    conflicts = check_module_conflicts()
    ```

---

## üéØ Practice Challenges

??? question "Challenge 1: Create a configurable benchmark decorator"
    ```python
    import functools
    import time
    import statistics
    from typing import Callable, Any, Dict
    
    def benchmark(
        runs: int = 100,
        warmup: int = 10,
        return_stats: bool = False,
        print_results: bool = True
    ):
        """
        Decorator to benchmark function execution
        
        Args:
            runs: Number of times to run the function
            warmup: Number of warmup runs (excluded from timing)
            return_stats: Whether to return timing statistics
            print_results: Whether to print benchmark results
        """
        def decorator(func: Callable) -> Callable:
            @functools.wraps(func)
            def wrapper(*args, **kwargs):
                # Warmup runs
                for _ in range(warmup):
                    func(*args, **kwargs)
                
                # Actual benchmark runs
                times = []
                for _ in range(runs):
                    start = time.perf_counter()
                    result = func(*args, **kwargs)
                    end = time.perf_counter()
                    times.append(end - start)
                
                # Calculate statistics
                mean_time = statistics.mean(times)
                median_time = statistics.median(times)
                min_time = min(times)
                max_time = max(times)
                std_dev = statistics.stdev(times) if len(times) > 1 else 0
                
                if print_results:
                    print(f"Benchmark results for {func.__name__}:")
                    print(f"  Runs: {runs} (after {warmup} warmup runs)")
                    print(f"  Mean: {mean_time:.6f}s")
                    print(f"  Median: {median_time:.6f}s")
                    print(f"  Min: {min_time:.6f}s")
                    print(f"  Max: {max_time:.6f}s")
                    print(f"  Std Dev: {std_dev:.6f}s")
                
                if return_stats:
                    stats = {
                        'mean': mean_time,
                        'median': median_time,
                        'min': min_time,
                        'max': max_time,
                        'std_dev': std_dev,
                        'all_times': times
                    }
                    return result, stats
                
                return result
            
            return wrapper
        return decorator
    
    # Usage examples
    @benchmark(runs=1000, warmup=50)
    def fibonacci(n):
        if n <= 1:
            return n
        return fibonacci(n-1) + fibonacci(n-2)
    
    @benchmark(runs=500, return_stats=True, print_results=False)
    def list_comprehension_test():
        return [x**2 for x in range(1000)]
    
    # Test the benchmarks
    result1 = fibonacci(10)
    result2, stats = list_comprehension_test()
    print(f"List comprehension stats: {stats}")
    ```

??? question "Challenge 2: Build a smart module importer with fallbacks"
    ```python
    import importlib
    import sys
    from typing import Any, Dict, List, Optional, Union
    from functools import wraps
    
    class SmartImporter:
        """Smart module importer with fallbacks and lazy loading"""
        
        def __init__(self):
            self._cache: Dict[str, Any] = {}
            self._fallbacks: Dict[str, List[str]] = {}
            self._lazy_modules: Dict[str, 'LazyModule'] = {}
        
        def add_fallback(self, primary: str, fallbacks: List[str]):
            """Add fallback modules for a primary module"""
            self._fallbacks[primary] = fallbacks
        
        def import_with_fallback(self, module_name: str) -> Optional[Any]:
            """Import module with fallback options"""
            # Check cache first
            if module_name in self._cache:
                return self._cache[module_name]
            
            # Try primary module
            modules_to_try = [module_name]
            if module_name in self._fallbacks:
                modules_to_try.extend(self._fallbacks[module_name])
            
            for name in modules_to_try:
                try:
                    module = importlib.import_module(name)
                    self._cache[module_name] = module
                    if name != module_name:
                        print(f"Using fallback {name} for {module_name}")
                    return module
                except ImportError:
                    continue
            
            print(f"Warning: Could not import {module_name} or any fallbacks")
            return None
        
        def lazy_import(self, module_name: str) -> 'LazyModule':
            """Create a lazy-loading module proxy"""
            if module_name not in self._lazy_modules:
                self._lazy_modules[module_name] = LazyModule(module_name, self)
            return self._lazy_modules[module_name]
        
        def require_module(self, module_name: str, feature_name: str = None):
            """Decorator to ensure a module is available"""
            def decorator(func):
                @wraps(func)
                def wrapper(*args, **kwargs):
                    module = self.import_with_fallback(module_name)
                    if module is None:
                        feature = feature_name or func.__name__
                        raise ImportError(
                            f"Function '{feature}' requires {module_name} but it's not available"
                        )
                    return func(*args, **kwargs)
                return wrapper
            return decorator
    
    class LazyModule:
        """Proxy object that imports module only when accessed"""
        
        def __init__(self, module_name: str, importer: SmartImporter):
            self._module_name = module_name
            self._importer = importer
            self._module = None
        
        def _load_module(self):
            if self._module is None:
                self._module = self._importer.import_with_fallback(self._module_name)
                if self._module is None:
                    raise ImportError(f"Could not load module {self._module_name}")
        
        def __getattr__(self, name):
            self._load_module()
            return getattr(self._module, name)
        
        def __call__(self, *args, **kwargs):
            self._load_module()
            return self._module(*args, **kwargs)
    
    # Usage examples
    importer = SmartImporter()
    
    # Set up fallbacks
    importer.add_fallback('ujson', ['orjson', 'json'])
    importer.add_fallback('numpy', ['array'])  # Fallback to built-in array
    
    # Import with fallbacks
    json_lib = importer.import_with_fallback('ujson')
    if json_lib:
        data = json_lib.loads('{"key": "value"}')
    
    # Lazy importing
    np = importer.lazy_import('numpy')
    # numpy won't be imported until we actually use it
    # array = np.array([1, 2, 3])  # This would trigger the import
    
    # Require decorator
    @importer.require_module('requests', 'web scraping')
    def fetch_data(url):
        import requests
        return requests.get(url)
    ```

??? question "Challenge 3: Create a package with automatic sub-module discovery"
    ```python
    # auto_package/__init__.py
    """
    Auto-discovering package that dynamically loads all sub-modules
    """
    
    import os
    import importlib
    import pkgutil
    from pathlib import Path
    from typing import Dict, Any, List
    
    class AutoPackage:
        """Automatically discover and load package modules"""
        
        def __init__(self, package_name: str):
            self.package_name = package_name
            self.modules: Dict[str, Any] = {}
            self.functions: Dict[str, Any] = {}
            self.classes: Dict[str, Any] = {}
            self._discover_modules()
        
        def _discover_modules(self):
            """Discover and load all modules in the package"""
            try:
                package = importlib.import_module(self.package_name)
                package_path = package.__path__
                
                for importer, modname, ispkg in pkgutil.iter_modules(package_path):
                    full_name = f"{self.package_name}.{modname}"
                    try:
                        module = importlib.import_module(full_name)
                        self.modules[modname] = module
                        self._extract_module_contents(modname, module)
                        print(f"Loaded module: {modname}")
                    except Exception as e:
                        print(f"Failed to load {modname}: {e}")
            
            except ImportError as e:
                print(f"Could not import package {self.package_name}: {e}")
        
        def _extract_module_contents(self, module_name: str, module: Any):
            """Extract functions and classes from module"""
            for name in dir(module):
                if not name.startswith('_'):
                    obj = getattr(module, name)
                    
                    if callable(obj) and hasattr(obj, '__module__'):
                        if obj.__module__ == f"{self.package_name}.{module_name}":
                            # It's a function or method defined in this module
                            if isinstance(obj, type):
                                self.classes[name] = obj
                            else:
                                self.functions[name] = obj
        
        def get_function(self, name: str):
            """Get function by name from any module"""
            return self.functions.get(name)
        
        def get_class(self, name: str):
            """Get class by name from any module"""
            return self.classes.get(name)
        
        def list_functions(self) -> List[str]:
            """List all available functions"""
            return list(self.functions.keys())
        
        def list_classes(self) -> List[str]:
            """List all available classes"""
            return list(self.classes.keys())
        
        def list_modules(self) -> List[str]:
            """List all loaded modules"""
            return list(self.modules.keys())
        
        def execute_function(self, name: str, *args, **kwargs):
            """Execute a function by name"""
            func = self.get_function(name)
            if func:
                return func(*args, **kwargs)
            else:
                raise ValueError(f"Function {name} not found")
        
        def create_instance(self, class_name: str, *args, **kwargs):
            """Create instance of a class by name"""
            cls = self.get_class(class_name)
            if cls:
                return cls(*args, **kwargs)
            else:
                raise ValueError(f"Class {class_name} not found")
    
    # Example usage in package __init__.py
    _auto_package = AutoPackage(__name__)
    
    # Make all functions and classes available at package level
    for name, func in _auto_package.functions.items():
        globals()[name] = func
    
    for name, cls in _auto_package.classes.items():
        globals()[name] = cls
    
    # Provide discovery utilities
    def list_available_functions():
        return _auto_package.list_functions()
    
    def list_available_classes():
        return _auto_package.list_classes()
    
    def get_module_info():
        return {
            'modules': _auto_package.list_modules(),
            'functions': _auto_package.list_functions(),
            'classes': _auto_package.list_classes()
        }
    
    # Example sub-modules:
    
    # auto_package/math_utils.py
    """
    def add_numbers(a, b):
        return a + b
    
    def multiply_numbers(a, b):
        return a * b
    
    class Calculator:
        def __init__(self):
            self.history = []
        
        def calculate(self, operation, a, b):
            if operation == 'add':
                result = add_numbers(a, b)
            elif operation == 'multiply':
                result = multiply_numbers(a, b)
            else:
                raise ValueError("Unknown operation")
            
            self.history.append((operation, a, b, result))
            return result
    """
    
    # auto_package/string_utils.py
    """
    def reverse_string(s):
        return s[::-1]
    
    def capitalize_words(s):
        return ' '.join(word.capitalize() for word in s.split())
    
    class StringProcessor:
        def __init__(self, default_case='lower'):
            self.default_case = default_case
        
        def process(self, text):
            if self.default_case == 'lower':
                return text.lower()
            elif self.default_case == 'upper':
                return text.upper()
            return text
    """
    
    # Usage:
    # import auto_package
    # 
    # # All functions are automatically available
    # result = auto_package.add_numbers(5, 3)
    # text = auto_package.reverse_string("hello")
    # 
    # # All classes are automatically available
    # calc = auto_package.Calculator()
    # processor = auto_package.StringProcessor('upper')
    # 
    # # Discovery methods
    # print("Available functions:", auto_package.list_available_functions())
    # print("Available classes:", auto_package.list_available_classes())
    # print("Module info:", auto_package.get_module_info())
    ```

??? question "Challenge 4: Implement a module dependency resolver"
    ```python
    import importlib
    import sys
    from typing import Dict, List, Set, Optional
    from collections import defaultdict, deque
    import ast
    import inspect
    
    class DependencyResolver:
        """Resolve and manage module dependencies"""
        
        def __init__(self):
            self.dependencies: Dict[str, Set[str]] = defaultdict(set)
            self.reverse_dependencies: Dict[str, Set[str]] = defaultdict(set)
            self.loaded_modules: Set[str] = set()
        
        def analyze_module_dependencies(self, module_name: str) -> Set[str]:
            """Analyze dependencies of a module by parsing its AST"""
            try:
                module = importlib.import_module(module_name)
                if not hasattr(module, '__file__') or module.__file__ is None:
                    return set()
                
                with open(module.__file__, 'r', encoding='utf-8') as f:
                    source = f.read()
                
                tree = ast.parse(source)
                dependencies = set()
                
                for node in ast.walk(tree):
                    if isinstance(node, ast.Import):
                        for alias in node.names:
                            dependencies.add(alias.name.split('.')[0])
                    elif isinstance(node, ast.ImportFrom):
                        if node.module:
                            dependencies.add(node.module.split('.')[0])
                
                return dependencies
                
            except Exception as e:
                print(f"Error analyzing {module_name}: {e}")
                return set()
        
        def build_dependency_graph(self, modules: List[str]):
            """Build dependency graph for given modules"""
            to_analyze = deque(modules)
            analyzed = set()
            
            while to_analyze:
                module_name = to_analyze.popleft()
                if module_name in analyzed:
                    continue
                
                analyzed.add(module_name)
                deps = self.analyze_module_dependencies(module_name)
                self.dependencies[module_name] = deps
                
                # Update reverse dependencies
                for dep in deps:
                    self.reverse_dependencies[dep].add(module_name)
                
                # Add new dependencies to analyze
                for dep in deps:
                    if dep not in analyzed and dep not in to_analyze:
                        to_analyze.append(dep)
        
        def topological_sort(self, modules: List[str]) -> List[str]:
            """Return modules in dependency order (dependencies first)"""
            # Build dependency graph
            self.build_dependency_graph(modules)
            
            # Kahn's algorithm for topological sorting
            in_degree = defaultdict(int)
            graph = defaultdict(list)
            
            # Build graph and calculate in-degrees
            for module in modules:
                if module not in in_degree:
                    in_degree[module] = 0
                
                for dep in self.dependencies[module]:
                    if dep in modules:  # Only consider dependencies within our module set
                        graph[dep].append(module)
                        in_degree[module] += 1
            
            # Find modules with no dependencies
            queue = deque([module for module in modules if in_degree[module] == 0])
            result = []
            
            while queue:
                module = queue.popleft()
                result.append(module)
                
                # Reduce in-degree of dependent modules
                for dependent in graph[module]:
                    in_degree[dependent] -= 1
                    if in_degree[dependent] == 0:
                        queue.append(dependent)
            
            if len(result) != len(modules):
                # Circular dependency detected
                remaining = set(modules) - set(result)
                raise ValueError(f"Circular dependency detected in modules: {remaining}")
            
            return result
        
        def detect_circular_dependencies(self, modules: List[str]) -> List[List[str]]:
            """Detect circular dependencies using DFS"""
            self.build_dependency_graph(modules)
            
            WHITE, GRAY, BLACK = 0, 1, 2
            colors = {module: WHITE for module in modules}
            cycles = []
            
            def dfs(module, path):
                if colors[module] == GRAY:
                    # Found a cycle
                    cycle_start = path.index(module)
                    cycles.append(path[cycle_start:] + [module])
                    return
                
                if colors[module] == BLACK:
                    return
                
                colors[module] = GRAY
                path.append(module)
                
                for dep in self.dependencies[module]:
                    if dep in modules:
                        dfs(dep, path.copy())
                
                colors[module] = BLACK
            
            for module in modules:
                if colors[module] == WHITE:
                    dfs(module, [])
            
            return cycles
        
        def get_dependency_tree(self, module_name: str, max_depth: int = 3) -> Dict:
            """Get dependency tree for a module"""
            def build_tree(module, depth):
                if depth > max_depth:
                    return {"name": module, "dependencies": "..."}
                
                deps = self.dependencies.get(module, set())
                return {
                    "name": module,
                    "dependencies": [build_tree(dep, depth + 1) for dep in sorted(deps)]
                }
            
            if module_name not in self.dependencies:
                self.analyze_module_dependencies(module_name)
            
            return build_tree(module_name, 0)
        
        def find_unused_modules(self, all_modules: List[str], entry_points: List[str]) -> Set[str]:
            """Find modules that are not used (not reachable from entry points)"""
            self.build_dependency_graph(all_modules)
            
            # BFS from entry points to find all reachable modules
            reachable = set()
            queue = deque(entry_points)
            
            while queue:
                module = queue.popleft()
                if module in reachable:
                    continue
                
                reachable.add(module)
                
                # Add modules that depend on this module
                for dependent in self.reverse_dependencies[module]:
                    if dependent not in reachable:
                        queue.append(dependent)
                
                # Add dependencies of this module
                for dep in self.dependencies[module]:
                    if dep not in reachable and dep in all_modules:
                        queue.append(dep)
            
            return set(all_modules) - reachable
    
    # Usage examples
    resolver = DependencyResolver()
    
    # Analyze dependencies
    modules_to_check = ['json', 'os', 'sys', 'math']
    
    try:
        # Get dependency order
        ordered_modules = resolver.topological_sort(modules_to_check)
        print("Dependency order:", ordered_modules)
        
        # Check for circular dependencies
        cycles = resolver.detect_circular_dependencies(modules_to_check)
        if cycles:
            print("Circular dependencies found:", cycles)
        else:
            print("No circular dependencies detected")
        
        # Get dependency tree
        tree = resolver.get_dependency_tree('json')
        print("Dependency tree for 'json':", tree)
        
        # Find unused modules
        all_modules = ['json', 'os', 'sys', 'math', 'random']
        entry_points = ['json']
        unused = resolver.find_unused_modules(all_modules, entry_points)
        print("Unused modules:", unused)
        
    except ValueError as e:
        print(f"Dependency resolution error: {e}")
    ```

---

## üìã Summary and Best Practices

### Key Takeaways:

1. **Benchmarking**: Use `timeit` for micro-benchmarks, `time.perf_counter()` for custom timing, and consider memory profiling
2. **Module Creation**: Use `__name__ == '__main__'` for executable scripts, create clean APIs with `__all__`
3. **Import Strategies**: Prefer absolute imports, use relative imports within packages, implement lazy loading for optional dependencies
4. **Package Design**: Use `__init__.py` effectively, implement namespace packages for large projects
5. **Advanced Patterns**: Implement plugin systems, module reloading for development, and dependency management

### Best Practices:

- **Performance**: Always benchmark before optimizing, use appropriate tools for different scenarios
- **Modularity**: Keep modules focused and cohesive, minimize dependencies
- **Import Management**: Handle import errors gracefully, provide fallback options
- **Documentation**: Document module interfaces clearly, include usage examples
- **Testing**: Test modules independently, use `if __name__ == '__main__'` for self-testing

### Common Pitfalls to Avoid:

- Circular imports (use delayed imports or restructure code)
- Modifying `sys.path` at runtime (prefer proper package installation)
- Using `from module import *` (makes code less readable and maintainable)
- Not handling ImportError exceptions
- Creating deep package hierarchies unnecessarily

This comprehensive guide covers the essential concepts and advanced techniques for working with Python modules, packages, and benchmarking. Practice these examples to master Python's module system!